commit 10bb4ca45730d4501bfafc1ebd71e076fb328ac6
Author: Manbir Sandhu <mana24129@hotmail.com>
Date:   Sun Mar 20 20:25:10 2022 -0600

    Final banknote test

diff --git a/src/selfcheckout_test/BanknoteTest.java b/src/selfcheckout_test/BanknoteTest.java
index 08b994d..7155fb3 100644
--- a/src/selfcheckout_test/BanknoteTest.java
+++ b/src/selfcheckout_test/BanknoteTest.java
@@ -18,7 +18,6 @@ import org.lsmr.selfcheckout.products.BarcodedProduct;
 import selfcheckout_software.BanknoteController;
 
 public class BanknoteTest {
-	
 	private BanknoteController pay;
 	private SelfCheckoutStation s;
 	
@@ -44,13 +43,22 @@ public class BanknoteTest {
 	
 	// Customer paying for a $10 item
 	@Test
-	public void testBanknoteControllerMany() throws DisabledException, OverloadException {
+	public void testBanknoteControllerEnough() throws DisabledException, OverloadException {
 		
 		s.banknoteInput.accept(new Banknote(Currency.getInstance("CAD"),5));
 		s.banknoteInput.accept(new Banknote(Currency.getInstance("CAD"),10));
 		assertEquals(pay.hasSufficientFunds(new BigDecimal(10)),true);
 	}
 	
+	// Customer paying for a $10 item
+	@Test
+	public void testBanknoteControllerMany() throws DisabledException, OverloadException {
+		for(int i = 0;i<500;i++) {
+			s.banknoteInput.accept(new Banknote(Currency.getInstance("CAD"),5));
+		}
+		assertEquals(pay.getCurrentFunds(),500*5);
+	}
+	
 	// Customer does not have sufficient funds for $10
 	@Test
 	public void testBanknoteControllerNotEnough() throws DisabledException, OverloadException {

commit 5e4b74e23dc19a6071a29e8ed061857e1a99708c
Merge: 9ddb3f4 a38ec8b
Author: Manbir Sandhu <mana24129@hotmail.com>
Date:   Sun Mar 20 19:48:21 2022 -0600

    Merge branch 'main' of https://github.com/Manbir1/SENG300Iteration1 into main

commit 9ddb3f4969021c5b23ef4cdb682aee51a8348601
Author: Manbir Sandhu <mana24129@hotmail.com>
Date:   Sun Mar 20 19:46:50 2022 -0600

    Finished testing for banknote

diff --git a/src/selfcheckout_test/BanknoteTest.java b/src/selfcheckout_test/BanknoteTest.java
index 4b96ee2..08b994d 100644
--- a/src/selfcheckout_test/BanknoteTest.java
+++ b/src/selfcheckout_test/BanknoteTest.java
@@ -62,12 +62,17 @@ public class BanknoteTest {
 	
 	@Test
 	public void testBanknoteControllerFull() throws DisabledException, OverloadException {
-		Barcode itemCode = new Barcode(new Numeral[] {Numeral.one,Numeral.one});
-		for(int i = 0;i<s.BANKNOTE_STORAGE_CAPACITY;i++)
-			do {
+		for(int i = 0;i<s.BANKNOTE_STORAGE_CAPACITY;i++) {
 			s.banknoteInput.accept(new Banknote(Currency.getInstance("CAD"),5));
-			}while(s.banknoteInput.)
-		//assertEquals(pay.getCurrentFunds(),5*s.BANKNOTE_STORAGE_CAPACITY);
+			while(!s.banknoteInput.hasSpace()) {
+				s.banknoteInput.removeDanglingBanknote();
+				s.banknoteInput.accept(new Banknote(Currency.getInstance("CAD"),5));
+			}
+		}
+		
+		s.banknoteInput.accept(new Banknote(Currency.getInstance("CAD"),5));
+		
+		assertEquals(5*s.BANKNOTE_STORAGE_CAPACITY,pay.getCurrentFunds());
 	}
 	
 	@Test

commit a38ec8be532e4685e7edbd3049a7e1a481c464b1
Author: kev9268 <99704077+kev9268@users.noreply.github.com>
Date:   Sun Mar 20 19:44:40 2022 -0600

    Update testBagging.java

diff --git a/src/selfcheckout_test/testBagging.java b/src/selfcheckout_test/testBagging.java
index b4f8810..b5f2ae3 100644
--- a/src/selfcheckout_test/testBagging.java
+++ b/src/selfcheckout_test/testBagging.java
@@ -42,7 +42,7 @@ public class testBagging {
 		this.e = new ElectronicScale(50,1);
 		this.test = new baggingItem(e);
 		item1 = new ItemClass(5);
-		item2 = new ItemClass(50);
+		item2 = new ItemClass(60);
 		item3 = new ItemClass(7);
 		
 	}

commit a415017a89eb7275c2719f0a83e804c16fc1bf42
Author: kev9268 <kevinhoang9268@gmail.com>
Date:   Sun Mar 20 19:42:21 2022 -0600

    Fixed bugs and has full coverage

diff --git a/src/selfcheckout_software/baggingItem.java b/src/selfcheckout_software/baggingItem.java
index e94dcdd..fadd09b 100644
--- a/src/selfcheckout_software/baggingItem.java
+++ b/src/selfcheckout_software/baggingItem.java
@@ -20,37 +20,30 @@ public class baggingItem implements ElectronicScaleObserver{
 	private ElectronicScale electronic;
 	
 	private ArrayList<Item> items = new ArrayList<>();
-	
-	double expectedWeight;
-	
+	private double counter=0;
+
 	public baggingItem(ElectronicScale e) {
 		this.electronic = e
 ;	}
 	
 	public void bagItem(Item i, ElectronicScale e) throws OverloadException, SimulationException {
-		double maxWeight = e.getWeightLimit();
-		double current = e.getCurrentWeight();
-		if (e.getCurrentWeight()==0) {			//logic to make sure that the scale is empty before actually scanning items
-			current = e.getCurrentWeight();
+		try {
 			e.add(i);
-		} else {								//proceeds normally after the first scanned item	
-			e.add(i);
-			current = e.getCurrentWeight();
-		}
-		double itemWeight = i.getWeight();
-		expectedWeight = current + itemWeight;
-		double updatedWeight = e.getCurrentWeight();
-		System.out.println(expectedWeight);
-		if (updatedWeight>maxWeight) {
+			
+			double current = e.getCurrentWeight();
+			double itemWeight = i.getWeight();
+			counter+=itemWeight;
+
+			System.out.println(current);
+
+			if (counter!=current) {
+				throw new SimulationException("Please put the correct items in the bagging area");
+			}
+		}catch(OverloadException o) {
 			throw new OverloadException();
 		}
-		if (updatedWeight!=expectedWeight) {
-			throw new SimulationException("Please put the correct items in the bagging area");
-		}
+		
 		}
-	public double get_expected_weight() {
-		return this.expectedWeight;
-	}
 
 	@Override
 	public void enabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
diff --git a/src/selfcheckout_test/testBagging.java b/src/selfcheckout_test/testBagging.java
index 906cafa..b4f8810 100644
--- a/src/selfcheckout_test/testBagging.java
+++ b/src/selfcheckout_test/testBagging.java
@@ -51,22 +51,20 @@ public class testBagging {
 	public void testBaggingItem() throws OverloadException{
 		e.endConfigurationPhase();
 		test.bagItem(item3, e);
-		assertEquals((double)7, test.get_expected_weight(),1);
+		Assert.assertEquals(e.getCurrentWeight(),7.0,0.1);
 		
 	}
 	
-	@Test (expected = OverloadException.class)
+	@Test (expected=OverloadException.class)
 	public void testOverweightLimit() throws OverloadException{
 		e.endConfigurationPhase();
 		test.bagItem(item2, e);
-		test.bagItem(item1, e);
-	}
+
+		}
 	
 	@Test (expected = SimulationException.class)
 	public void testWrongItem() throws OverloadException{
 		e.endConfigurationPhase();
-		
-		test.bagItem(item1, e);
 		e.add(item3);
 		test.bagItem(item1, e);
 	}

commit 7b4e9179e812a7a1fe26dd7615e0ff1f8cadf645
Author: lexahoa <sparr@LAPTOP-V521ED67>
Date:   Sun Mar 20 21:33:47 2022 -0400

    wish_checkout updating

diff --git a/src/selfcheckout_software/wish_checkout.java b/src/selfcheckout_software/wish_checkout.java
index 57499f5..c29ec0c 100644
--- a/src/selfcheckout_software/wish_checkout.java
+++ b/src/selfcheckout_software/wish_checkout.java
@@ -40,7 +40,7 @@ public class wish_checkout extends AbstractDevice<AbstractDeviceObserver> implem
 				}
 				
 			}
-			//....might need to call the matched payment method
+			//....might need to call the matched payment method ///
 			
 	}
 
diff --git a/src/selfcheckout_test/test_wish_to_checkout.java b/src/selfcheckout_test/test_wish_to_checkout.java
index 00b9919..58cc553 100644
--- a/src/selfcheckout_test/test_wish_to_checkout.java
+++ b/src/selfcheckout_test/test_wish_to_checkout.java
@@ -88,6 +88,6 @@ public class test_wish_to_checkout {
 		AbstractDeviceObserverStub extra_obStub = new AbstractDeviceObserverStub();
 		test_object.attach(extra_obStub);
 		test_object.accept(payment);
-	}
+	} ///
 
 }

commit 48bddbf7a72d3423c781b540c321126ab35de54a
Merge: ac9db2d 8b60594
Author: lexahoa <sparr@LAPTOP-V521ED67>
Date:   Sun Mar 20 21:29:47 2022 -0400

    Merge branch 'main' of https://github.com/Manbir1/SENG300Iteration1

commit ac9db2d989d882c9d164b6201003758779d492f5
Author: lexahoa <sparr@LAPTOP-V521ED67>
Date:   Sun Mar 20 21:29:36 2022 -0400

    fix

diff --git a/bin/selfcheckout_software/BanknoteController.class b/bin/selfcheckout_software/BanknoteController.class
index 6e53cfe..fc2e325 100644
Binary files a/bin/selfcheckout_software/BanknoteController.class and b/bin/selfcheckout_software/BanknoteController.class differ

commit 8b60594dfd1011ae08fbc4c71e788a65cd47ed43
Author: Justin Yu <60626089+justinjelly@users.noreply.github.com>
Date:   Sun Mar 20 19:28:04 2022 -0600

    added setStorageFull

diff --git a/src/selfcheckout_software/CoinController.java b/src/selfcheckout_software/CoinController.java
index 54e1256..f02fd3b 100644
--- a/src/selfcheckout_software/CoinController.java
+++ b/src/selfcheckout_software/CoinController.java
@@ -12,7 +12,7 @@ public class CoinController implements CoinValidatorObserver, CoinStorageUnitObs
 	
 	private Coin c;
 	private BigDecimal availableFunds = new BigDecimal(0);
-	private Boolean storageFull;
+	private Boolean storageFull = false;
 	
 	public CoinController(Coin c) {
 		this.c = c;
@@ -42,7 +42,16 @@ public class CoinController implements CoinValidatorObserver, CoinStorageUnitObs
 	public BigDecimal getAvailableFunds() {
 		return availableFunds;
 	}
+	
+	public Boolean getStorageFull() {
+		return storageFull;
+	}
+	
+	public void setStorageFull(Boolean value) {
+		storageFull = value;
+	}
 
+	
 	@Override
 	public void coinsFull(CoinStorageUnit unit) {
 		storageFull = true;

commit 15610fa5dd8b255b799a3acb333fbe09d4b322c2
Merge: b89565c 1cb561e
Author: lexahoa <sparr@LAPTOP-V521ED67>
Date:   Sun Mar 20 21:24:14 2022 -0400

    Merge branch 'main' of https://github.com/Manbir1/SENG300Iteration1

commit b89565c01b691ee2d433e06efadaf9a967221432
Author: lexahoa <sparr@LAPTOP-V521ED67>
Date:   Sun Mar 20 21:24:07 2022 -0400

    bug fix

diff --git a/bin/selfcheckout_test/test_wish_to_checkout.class b/bin/selfcheckout_test/test_wish_to_checkout.class
index 9e8ba8c..f6d5bba 100644
Binary files a/bin/selfcheckout_test/test_wish_to_checkout.class and b/bin/selfcheckout_test/test_wish_to_checkout.class differ
diff --git a/src/selfcheckout_test/test_wish_to_checkout.java b/src/selfcheckout_test/test_wish_to_checkout.java
index ade1fec..00b9919 100644
--- a/src/selfcheckout_test/test_wish_to_checkout.java
+++ b/src/selfcheckout_test/test_wish_to_checkout.java
@@ -83,5 +83,11 @@ public class test_wish_to_checkout {
 		
 	}
 	
+	@Test
+	public void test_not_expected_observer() throws OverloadException, DisabledException {
+		AbstractDeviceObserverStub extra_obStub = new AbstractDeviceObserverStub();
+		test_object.attach(extra_obStub);
+		test_object.accept(payment);
+	}
 
 }

commit 1cb561ed0ecf26c7fc958117348d2af590f3ad95
Merge: a338c94 0518b9e
Author: Manbir Sandhu <mana24129@hotmail.com>
Date:   Sun Mar 20 19:18:20 2022 -0600

    Merge branch 'main' of https://github.com/Manbir1/SENG300Iteration1 into main

commit a338c94976d7620477cee5a59fde7ee72bc803f6
Author: Manbir Sandhu <mana24129@hotmail.com>
Date:   Sun Mar 20 19:17:35 2022 -0600

    Added comments to Banknote Controller

diff --git a/src/selfcheckout_software/BanknoteController.java b/src/selfcheckout_software/BanknoteController.java
index cc13658..50add30 100644
--- a/src/selfcheckout_software/BanknoteController.java
+++ b/src/selfcheckout_software/BanknoteController.java
@@ -12,12 +12,22 @@ import org.lsmr.selfcheckout.devices.observers.BanknoteValidatorObserver;
 
 public class BanknoteController implements BanknoteValidatorObserver, BanknoteStorageUnitObserver{
 
-	private int availableFunds;
+	private long availableFunds;
 	private int validBanknotes = 0;
 	private int invalidBanknotes = 0;
 	private boolean isFull = false;
 	
+	
+	/*
+	 * Constructor for the BanknoteController class
+	 * Simulates the use case for the user entering a banknote
+	 * 
+	 * @param SelfCheckoutStation s
+	 * 	The self checkout station which this class will be listening too
+	 * */
 	public BanknoteController(SelfCheckoutStation s) {
+		
+		// Attaching this object to listen to the banknoteStorage and banknoteValidtor objects
 		s.banknoteValidator.attach(this);
 		s.banknoteStorage.attach(this);
 		availableFunds = 0;
@@ -29,20 +39,30 @@ public class BanknoteController implements BanknoteValidatorObserver, BanknoteSt
 	@Override
 	public void disabled(AbstractDevice<? extends AbstractDeviceObserver> device) {}
 
+	/*
+	 * Implementing validBanknoteDetected function from the interface of BanknoteValidatorObserver
+	 * */
 	@Override
 	public void validBanknoteDetected(BanknoteValidator validator, Currency currency, int value) {
+		
+		// If the storage unit for the banknote is not full
+		// we add the dollar value to availableFunds
 		if(!isFull) {
 			availableFunds+=value;
 			validBanknotes++;
 		}
 		
 	}
-
+	
+	/*
+	 * Implementing invalidBanknoteDetected function from the interface of BanknoteValidatorObserver
+	 * */
 	@Override
 	public void invalidBanknoteDetected(BanknoteValidator validator) {
 		invalidBanknotes++;
 	}
 
+	// Used to determine if the storage unit for the banknote is full
 	@Override
 	public void banknotesFull(BanknoteStorageUnit unit) {
 		isFull = true;
@@ -60,11 +80,18 @@ public class BanknoteController implements BanknoteValidatorObserver, BanknoteSt
 		isFull = false;
 	}
 	
-	public boolean hasSufficientFunds(float price) {
-		return availableFunds>price;
+	
+	/*
+	 * Checking it the current availableFunds is sufficient for purchase
+	 * */
+	public boolean hasSufficientFunds(BigDecimal price) {
+		return new BigDecimal(availableFunds).compareTo(price)>=0;
 	}
 	
-	public int getCurrentFunds() {
+	// Getters and setters for the current funds of the customer, and the number
+	// of valid and invalid banknotes
+	
+	public long getCurrentFunds() {
 		return availableFunds;
 	}
 	
diff --git a/src/selfcheckout_test/BanknoteTest.java b/src/selfcheckout_test/BanknoteTest.java
index 8dbdf0b..4b96ee2 100644
--- a/src/selfcheckout_test/BanknoteTest.java
+++ b/src/selfcheckout_test/BanknoteTest.java
@@ -19,21 +19,11 @@ import selfcheckout_software.BanknoteController;
 
 public class BanknoteTest {
 	
-	private HashMap<Barcode, BarcodedProduct> products = new HashMap<Barcode, BarcodedProduct>();
 	private BanknoteController pay;
 	private SelfCheckoutStation s;
 	
 	@Before
-	public void setup() {
-		products.put(new Barcode(new Numeral[] {Numeral.one,Numeral.one}), 
-				new BarcodedProduct(new Barcode(new Numeral[] {Numeral.one,Numeral.one}), "Bread", new BigDecimal(4.99)));
-		products.put(new Barcode(new Numeral[] {Numeral.two,Numeral.two}), 
-				new BarcodedProduct(new Barcode(new Numeral[] {Numeral.two,Numeral.two}), "Milk", new BigDecimal(2.50)));
-		products.put(new Barcode(new Numeral[] {Numeral.three,Numeral.three}), 
-				new BarcodedProduct(new Barcode(new Numeral[] {Numeral.three,Numeral.three}), "Oreos", new BigDecimal(10.99)));
-		products.put(new Barcode(new Numeral[] {Numeral.four,Numeral.four}), 
-				new BarcodedProduct(new Barcode(new Numeral[] {Numeral.four,Numeral.four}), "Orange", new BigDecimal(0.99)));
-	    
+	public void setup() {	    
 	    Currency currency = Currency.getInstance("CAD");
 	    int[] banknoteDenoms = new int[] {5,10,20,50};
 	    BigDecimal[] coinDenominations = new BigDecimal[]{new BigDecimal("0.05"), new BigDecimal("0.10"), 
@@ -46,18 +36,38 @@ public class BanknoteTest {
 	
 	@Test
 	public void testBanknoteControllerRegular() throws DisabledException, OverloadException {
-		Barcode itemCode = new Barcode(new Numeral[] {Numeral.one,Numeral.one});
 		s.banknoteInput.accept(new Banknote(Currency.getInstance("CAD"),5));
 		s.banknoteInput.accept(new Banknote(Currency.getInstance("CAD"),10));
 		assertEquals(pay.getCurrentFunds(),15);
+		assertEquals(pay.getValidBanknotes(),2);
+	}
+	
+	// Customer paying for a $10 item
+	@Test
+	public void testBanknoteControllerMany() throws DisabledException, OverloadException {
+		
+		s.banknoteInput.accept(new Banknote(Currency.getInstance("CAD"),5));
+		s.banknoteInput.accept(new Banknote(Currency.getInstance("CAD"),10));
+		assertEquals(pay.hasSufficientFunds(new BigDecimal(10)),true);
+	}
+	
+	// Customer does not have sufficient funds for $10
+	@Test
+	public void testBanknoteControllerNotEnough() throws DisabledException, OverloadException {
+		
+		s.banknoteInput.accept(new Banknote(Currency.getInstance("CAD"),5));
+		s.banknoteInput.accept(new Banknote(Currency.getInstance("CAD"),10));
+		assertEquals(pay.hasSufficientFunds(new BigDecimal(20)),false);
 	}
 	
 	@Test
 	public void testBanknoteControllerFull() throws DisabledException, OverloadException {
 		Barcode itemCode = new Barcode(new Numeral[] {Numeral.one,Numeral.one});
-		for(int i = 0;i<75;i++)
+		for(int i = 0;i<s.BANKNOTE_STORAGE_CAPACITY;i++)
+			do {
 			s.banknoteInput.accept(new Banknote(Currency.getInstance("CAD"),5));
-		assertEquals(pay.getCurrentFunds(),5*s.BANKNOTE_STORAGE_CAPACITY);
+			}while(s.banknoteInput.)
+		//assertEquals(pay.getCurrentFunds(),5*s.BANKNOTE_STORAGE_CAPACITY);
 	}
 	
 	@Test
@@ -67,7 +77,17 @@ public class BanknoteTest {
 		assertEquals(1,pay.getInvalidBanknotes());
 	}
 	
-	
+    @Test
+    public void testPayWithOnlyInvalidDenominationBanknotes() throws DisabledException, OverloadException {   
+        s.banknoteInput.accept(new Banknote(Currency.getInstance("CAD"),7));
+        assertEquals(pay.getInvalidBanknotes(), 1);
+    }
+    
+    @Test (expected = DisabledException.class)
+    public void testPayWithDisabledBanknoteSlot() throws DisabledException, OverloadException {
+        s.banknoteInput.disable();
+        s.banknoteInput.accept(new Banknote(Currency.getInstance("CAD"),10));
+    }    
 	
 	
 }

commit a0cd93bce5f4152b6bf41688292e6bd8a3d20157
Merge: 6e14027 0518b9e
Author: lexahoa <sparr@LAPTOP-V521ED67>
Date:   Sun Mar 20 21:15:48 2022 -0400

    Merge branch 'main' of https://github.com/Manbir1/SENG300Iteration1

commit 6e14027993c02c387256d6febab9b9320ee13128
Author: lexahoa <sparr@LAPTOP-V521ED67>
Date:   Sun Mar 20 21:15:30 2022 -0400

    fix one test case

diff --git a/bin/selfcheckout_test/test_wish_to_checkout$1.class b/bin/selfcheckout_test/test_wish_to_checkout$1.class
index 92dde9c..0774c98 100644
Binary files a/bin/selfcheckout_test/test_wish_to_checkout$1.class and b/bin/selfcheckout_test/test_wish_to_checkout$1.class differ
diff --git a/bin/selfcheckout_test/test_wish_to_checkout$2.class b/bin/selfcheckout_test/test_wish_to_checkout$2.class
index ebf4290..ad43f3b 100644
Binary files a/bin/selfcheckout_test/test_wish_to_checkout$2.class and b/bin/selfcheckout_test/test_wish_to_checkout$2.class differ
diff --git a/bin/selfcheckout_test/test_wish_to_checkout.class b/bin/selfcheckout_test/test_wish_to_checkout.class
index 34c833f..9e8ba8c 100644
Binary files a/bin/selfcheckout_test/test_wish_to_checkout.class and b/bin/selfcheckout_test/test_wish_to_checkout.class differ
diff --git a/src/selfcheckout_software/wish_checkout.java b/src/selfcheckout_software/wish_checkout.java
index 6d8f7ab..57499f5 100644
--- a/src/selfcheckout_software/wish_checkout.java
+++ b/src/selfcheckout_software/wish_checkout.java
@@ -19,7 +19,7 @@ public class wish_checkout extends AbstractDevice<AbstractDeviceObserver> implem
 		this.electronic = e;
 	}
 	
-	public void wish_checkout(AbstractDeviceObserver payment_method) throws OverloadException, DisabledException  {
+	public void wish_to_checkout(AbstractDeviceObserver payment_method) throws OverloadException, DisabledException  {
 		
 			this.attach(payment_method);
 			while(true) {
diff --git a/src/selfcheckout_test/test_wish_to_checkout.java b/src/selfcheckout_test/test_wish_to_checkout.java
index 660abe1..ade1fec 100644
--- a/src/selfcheckout_test/test_wish_to_checkout.java
+++ b/src/selfcheckout_test/test_wish_to_checkout.java
@@ -32,11 +32,13 @@ public class test_wish_to_checkout {
 		
 	}
 	
-	@Test(expected = SimulationException.class)
+	@Test
 	public void test_attachment() throws OverloadException, DisabledException {
-		test_object.wish_checkout(payment);
-		test_object.detach(payment);
+		test_object.endConfigurationPhase();
+		E.endConfigurationPhase();
+		test_object.wish_to_checkout(payment);
 		test_object.detach(payment);
+		assertFalse(test_object.detach(payment));
 	}
 	
 	@Test(expected = SimulationException.class)
@@ -45,12 +47,12 @@ public class test_wish_to_checkout {
 		Item test_item1 = new Item(20) {};
 		Item test_item2 = new Item(40) {};
 		E.endConfigurationPhase();
+		test_object.endConfigurationPhase();
 		E.add(test_item1);
 		E.enable();
-		
 		E.add(test_item2);
-		
-		test_object.wish_checkout(payment);
+
+		test_object.wish_to_checkout(payment);
 		
 	}
 	
@@ -60,7 +62,7 @@ public class test_wish_to_checkout {
 		test_object.attach(extra_obStub);
 		E.endConfigurationPhase();
 		test_object.endConfigurationPhase();
-		test_object.wish_checkout(payment);
+		test_object.wish_to_checkout(payment);
 		
 	}
 	
@@ -70,7 +72,7 @@ public class test_wish_to_checkout {
 		E.attach(w_observer);
 		E.endConfigurationPhase();
 		E.enable();
-		test_object.wish_checkout(payment);
+		test_object.wish_to_checkout(payment);
 		assertTrue("this should be true",test_object.isDisabled());
 		
 	}

commit 0518b9eae4c044054ca9f6dffd09b650bc87621c
Author: Justin Yu <60626089+justinjelly@users.noreply.github.com>
Date:   Sun Mar 20 19:04:55 2022 -0600

    Update and rename testPayWithCoin.java to testCoinController.java

diff --git a/src/selfcheckout_test/testPayWithCoin.java b/src/selfcheckout_test/testCoinController.java
similarity index 93%
rename from src/selfcheckout_test/testPayWithCoin.java
rename to src/selfcheckout_test/testCoinController.java
index 0f6d9d2..17197cb 100644
--- a/src/selfcheckout_test/testPayWithCoin.java
+++ b/src/selfcheckout_test/testCoinController.java
@@ -16,10 +16,10 @@ import org.lsmr.selfcheckout.devices.observers.*;
 
 import junit.extensions.TestSetup;
 
-public class testPayWithCoin {
+public class testCoinController {
 	
 	private BigDecimal coinValue;
-	private PayWithCoin test_object;
+	private CoinController test_object;
 	private Coin c;
 	private CoinValidator v;
 	private Currency currency = Currency.getInstance("CAD");
@@ -30,7 +30,7 @@ public class testPayWithCoin {
 		this.coinValue = new BigDecimal(1);
 		//this.c = new Coin(currency, coinValue);	
 		this.denoms = Arrays.asList(new BigDecimal(1));
-		this.test_object = new PayWithCoin(c);
+		this.test_object = new CoinController(c);
 		this.v = new CoinValidator(currency, denoms);
 	}
 	
@@ -69,5 +69,7 @@ public class testPayWithCoin {
 	
 	
 	
+	
+	
 
 }

commit 0fe20a41e1d0ae6b38709235a203fe73252a541d
Author: Justin Yu <60626089+justinjelly@users.noreply.github.com>
Date:   Sun Mar 20 19:03:10 2022 -0600

    Update CoinController.java

diff --git a/src/selfcheckout_software/CoinController.java b/src/selfcheckout_software/CoinController.java
index c248098..54e1256 100644
--- a/src/selfcheckout_software/CoinController.java
+++ b/src/selfcheckout_software/CoinController.java
@@ -14,7 +14,7 @@ public class CoinController implements CoinValidatorObserver, CoinStorageUnitObs
 	private BigDecimal availableFunds = new BigDecimal(0);
 	private Boolean storageFull;
 	
-	public PayWithCoin(Coin c) {
+	public CoinController(Coin c) {
 		this.c = c;
 	}
 	

commit d4d3642fa485410a9a24d10d45200e0271762fdc
Author: Justin Yu <60626089+justinjelly@users.noreply.github.com>
Date:   Sun Mar 20 19:01:49 2022 -0600

    Update and rename PayWithCoin.java to CoinController.java

diff --git a/src/selfcheckout_software/PayWithCoin.java b/src/selfcheckout_software/CoinController.java
similarity index 94%
rename from src/selfcheckout_software/PayWithCoin.java
rename to src/selfcheckout_software/CoinController.java
index f2379d8..c248098 100644
--- a/src/selfcheckout_software/PayWithCoin.java
+++ b/src/selfcheckout_software/CoinController.java
@@ -8,7 +8,7 @@ import org.lsmr.selfcheckout.devices.observers.*;
 
 // logic for the use case "customer wants to pay with coin" by implementing the CoinValidatorObserver
 // and adding value of a coin to a local variable availableFunds if the proper event occurs (a valid coin is detected). 
-public class PayWithCoin implements CoinValidatorObserver, CoinStorageUnitObserver {
+public class CoinController implements CoinValidatorObserver, CoinStorageUnitObserver {
 	
 	private Coin c;
 	private BigDecimal availableFunds = new BigDecimal(0);

commit 08d9d6e78f244831f0abd72442dd9906cafe3fcf
Merge: e77479c 68dbf40
Author: lexahoa <sparr@LAPTOP-V521ED67>
Date:   Sun Mar 20 20:51:59 2022 -0400

    Merge branch 'main' of https://github.com/Manbir1/SENG300Iteration1

commit e77479cd260f66b626562f43543aab8beebc3f12
Author: lexahoa <sparr@LAPTOP-V521ED67>
Date:   Sun Mar 20 20:51:49 2022 -0400

    rename SCSLogic to wish_checkout

diff --git a/bin/selfcheckout_software/SCSLogic.class b/bin/selfcheckout_software/SCSLogic.class
deleted file mode 100644
index e4dccb7..0000000
Binary files a/bin/selfcheckout_software/SCSLogic.class and /dev/null differ
diff --git a/bin/selfcheckout_test/test_wish_to_checkout.class b/bin/selfcheckout_test/test_wish_to_checkout.class
index 2067023..34c833f 100644
Binary files a/bin/selfcheckout_test/test_wish_to_checkout.class and b/bin/selfcheckout_test/test_wish_to_checkout.class differ
diff --git a/src/selfcheckout_software/baggingItem.java b/src/selfcheckout_software/baggingItem.java
index 6fd3f1e..e94dcdd 100644
--- a/src/selfcheckout_software/baggingItem.java
+++ b/src/selfcheckout_software/baggingItem.java
@@ -10,7 +10,7 @@ import org.lsmr.selfcheckout.devices.OverloadException;
 import org.lsmr.selfcheckout.devices.SimulationException;
 import org.lsmr.selfcheckout.devices.observers.AbstractDeviceObserver;
 import org.lsmr.selfcheckout.devices.observers.ElectronicScaleObserver;
-import selfcheckout_software.SCSLogic;
+import selfcheckout_software.wish_checkout;
 import selfcheckout_test.test_wish_to_checkout;
 
 public class baggingItem implements ElectronicScaleObserver{
diff --git a/src/selfcheckout_software/SCSLogic.java b/src/selfcheckout_software/wish_checkout.java
similarity index 90%
rename from src/selfcheckout_software/SCSLogic.java
rename to src/selfcheckout_software/wish_checkout.java
index a4720d8..6d8f7ab 100644
--- a/src/selfcheckout_software/SCSLogic.java
+++ b/src/selfcheckout_software/wish_checkout.java
@@ -8,14 +8,14 @@ import org.lsmr.selfcheckout.devices.OverloadException;
 import org.lsmr.selfcheckout.devices.SimulationException;
 import org.lsmr.selfcheckout.devices.observers.AbstractDeviceObserver;
 
-public class SCSLogic extends AbstractDevice<AbstractDeviceObserver> implements Acceptor<AbstractDeviceObserver>{
+public class wish_checkout extends AbstractDevice<AbstractDeviceObserver> implements Acceptor<AbstractDeviceObserver>{
 	
 	private ElectronicScale electronic;
 	
 	
 	
 	
-	public SCSLogic(ElectronicScale e) {
+	public wish_checkout(ElectronicScale e) {
 		this.electronic = e;
 	}
 	
diff --git a/src/selfcheckout_test/testBagging.java b/src/selfcheckout_test/testBagging.java
index 689ae44..906cafa 100644
--- a/src/selfcheckout_test/testBagging.java
+++ b/src/selfcheckout_test/testBagging.java
@@ -35,7 +35,7 @@ public class testBagging {
 	private Item item2;
 	private Item item3;
 	private Item item4;
-	private logic test;
+	private baggingItem test;
 	
 	@Before
 	public void setUp() throws Exception {
diff --git a/src/selfcheckout_test/test_wish_to_checkout.java b/src/selfcheckout_test/test_wish_to_checkout.java
index 501267a..660abe1 100644
--- a/src/selfcheckout_test/test_wish_to_checkout.java
+++ b/src/selfcheckout_test/test_wish_to_checkout.java
@@ -18,7 +18,7 @@ import junit.framework.Assert;
 
 public class test_wish_to_checkout {
 
-	private SCSLogic test_object;
+	private wish_checkout test_object;
 	private AbstractDeviceObserverStub payment;
 	private ElectronicScaleObserverStub w_observer;
 	private ElectronicScale E;
@@ -26,7 +26,7 @@ public class test_wish_to_checkout {
 	@Before
 	public void TestSetup() {
 		this.E = new ElectronicScale(100, 1);
-		this.test_object = new SCSLogic(E);
+		this.test_object = new wish_checkout(E);
 		this.payment = new AbstractDeviceObserverStub();
 		this.w_observer = new ElectronicScaleObserverStub();
 		

commit 68dbf4046790d375ab5f923c95efdb0608589bb1
Author: Justin Yu <60626089+justinjelly@users.noreply.github.com>
Date:   Sun Mar 20 18:49:46 2022 -0600

    adding more test cases

diff --git a/src/selfcheckout_test/testPayWithCoin.java b/src/selfcheckout_test/testPayWithCoin.java
index 42ec8f5..0f6d9d2 100644
--- a/src/selfcheckout_test/testPayWithCoin.java
+++ b/src/selfcheckout_test/testPayWithCoin.java
@@ -41,6 +41,30 @@ public class testPayWithCoin {
 		assertEquals(test_object.getAvailableFunds(), value);
 	}
 	
+	@Test
+	public void testStorageUnitFull() {
+		test_object.setStorageFull(true);
+		
+		BigDecimal value = new BigDecimal(5);
+		BigDecimal expectedValue = new BigDecimal(0);
+		test_object.validCoinDetected(v, value);
+		assertEquals(test_object.getAvailableFunds(), expectedValue);
+	}
+	
+	@Test
+	public void testCoinsUnloaded() {
+		CoinStorageUnit unit = new CoinStorageUnit(100);
+		test_object.coinsUnloaded(unit);
+		assertEquals(test_object.getStorageFull(), false);
+	}
+	
+	@Test
+	public void testCoinsFull() {
+		CoinStorageUnit unit = new CoinStorageUnit(100);
+		test_object.coinsFull(unit);
+		assertEquals(test_object.getStorageFull(), true);
+	}
+	
 	
 	
 	

commit 2fefaa3924c22b65a160428a25bfe83a8e7222b3
Merge: dc01643 7c8cf22
Author: lexahoa <sparr@LAPTOP-V521ED67>
Date:   Sun Mar 20 20:47:08 2022 -0400

    Merge branch 'main' of https://github.com/Manbir1/SENG300Iteration1

commit dc016437ad77a3293c9977f24f2f0bc054182d20
Author: lexahoa <sparr@LAPTOP-V521ED67>
Date:   Sun Mar 20 20:47:03 2022 -0400

    fix

diff --git a/bin/selfcheckout_software/BanknoteController.class b/bin/selfcheckout_software/BanknoteController.class
index 2379e18..6e53cfe 100644
Binary files a/bin/selfcheckout_software/BanknoteController.class and b/bin/selfcheckout_software/BanknoteController.class differ
diff --git a/bin/selfcheckout_software/SCSLogic.class b/bin/selfcheckout_software/SCSLogic.class
index ce13634..e4dccb7 100644
Binary files a/bin/selfcheckout_software/SCSLogic.class and b/bin/selfcheckout_software/SCSLogic.class differ
diff --git a/src/selfcheckout_software/SCSLogic.java b/src/selfcheckout_software/SCSLogic.java
index d14b5da..a4720d8 100644
--- a/src/selfcheckout_software/SCSLogic.java
+++ b/src/selfcheckout_software/SCSLogic.java
@@ -19,9 +19,6 @@ public class SCSLogic extends AbstractDevice<AbstractDeviceObserver> implements
 		this.electronic = e;
 	}
 	
-	
-	
-	
 	public void wish_checkout(AbstractDeviceObserver payment_method) throws OverloadException, DisabledException  {
 		
 			this.attach(payment_method);
@@ -44,19 +41,9 @@ public class SCSLogic extends AbstractDevice<AbstractDeviceObserver> implements
 				
 			}
 			//....might need to call the matched payment method
-		
-		
+			
 	}
 
-
-
-
-
-
-
-
-
-
 	@Override
 	public void accept(AbstractDeviceObserver thing) throws OverloadException, DisabledException {
 		if(observers.size()==1 && observers.contains(thing)) {
diff --git a/src/selfcheckout_software/logic.java b/src/selfcheckout_software/logic.java
index 65bec34..75378a6 100644
--- a/src/selfcheckout_software/logic.java
+++ b/src/selfcheckout_software/logic.java
@@ -10,6 +10,8 @@ import org.lsmr.selfcheckout.devices.OverloadException;
 import org.lsmr.selfcheckout.devices.SimulationException;
 import org.lsmr.selfcheckout.devices.observers.AbstractDeviceObserver;
 import org.lsmr.selfcheckout.devices.observers.ElectronicScaleObserver;
+import selfcheckout_software.SCSLogic;
+import selfcheckout_test.test_wish_to_checkout;
 
 public class logic implements ElectronicScaleObserver{
 	

commit 7c8cf22886a4b51d6fa4baa4e7ea863d8996a264
Author: kev9268 <99704077+kev9268@users.noreply.github.com>
Date:   Sun Mar 20 18:46:56 2022 -0600

    Update and rename logicTest.java to testBagging.java

diff --git a/src/selfcheckout_test/logicTest.java b/src/selfcheckout_test/testBagging.java
similarity index 92%
rename from src/selfcheckout_test/logicTest.java
rename to src/selfcheckout_test/testBagging.java
index 1a89f03..689ae44 100644
--- a/src/selfcheckout_test/logicTest.java
+++ b/src/selfcheckout_test/testBagging.java
@@ -27,7 +27,7 @@ class ItemClass extends Item {
 		super(weight);
 	}
 }
-public class logicTest {
+public class testBagging {
 
 	private ElectronicScale e;
 	private ArrayList<Item> list;
@@ -40,7 +40,7 @@ public class logicTest {
 	@Before
 	public void setUp() throws Exception {
 		this.e = new ElectronicScale(50,1);
-		this.test = new logic(e);
+		this.test = new baggingItem(e);
 		item1 = new ItemClass(5);
 		item2 = new ItemClass(50);
 		item3 = new ItemClass(7);

commit d9ea399254d4567a7d6162be5850962773bf8c0f
Author: jameskhalil <87144837+jameskhalil@users.noreply.github.com>
Date:   Sun Mar 20 18:45:25 2022 -0600

    Update ScanItemController.java

diff --git a/src/selfcheckout_software/ScanItemController.java b/src/selfcheckout_software/ScanItemController.java
index 97aa0c6..859b381 100644
--- a/src/selfcheckout_software/ScanItemController.java
+++ b/src/selfcheckout_software/ScanItemController.java
@@ -72,4 +72,12 @@ public class ScanItemController implements BarcodeScannerObserver  {
 		total.add(product.getPrice());
 		expectedWeight += item.getWeight();
 	}
+	
+		public BigDecimal getTotal() {
+		return total;
+	}
+	
+	public double getExpectedWeight() {
+		return expectedWeight;
+	}	
 }

commit 016e6b9aa0bcc8f12c9126fb76a8fe8025308ad4
Author: kev9268 <99704077+kev9268@users.noreply.github.com>
Date:   Sun Mar 20 18:45:14 2022 -0600

    Update baggingItem.java

diff --git a/src/selfcheckout_software/baggingItem.java b/src/selfcheckout_software/baggingItem.java
index 65bec34..b7b2617 100644
--- a/src/selfcheckout_software/baggingItem.java
+++ b/src/selfcheckout_software/baggingItem.java
@@ -11,7 +11,7 @@ import org.lsmr.selfcheckout.devices.SimulationException;
 import org.lsmr.selfcheckout.devices.observers.AbstractDeviceObserver;
 import org.lsmr.selfcheckout.devices.observers.ElectronicScaleObserver;
 
-public class logic implements ElectronicScaleObserver{
+public class baggingItem implements ElectronicScaleObserver{
 	
 	
 	
@@ -21,7 +21,7 @@ public class logic implements ElectronicScaleObserver{
 	
 	double expectedWeight;
 	
-	public logic(ElectronicScale e) {
+	public baggingItem(ElectronicScale e) {
 		this.electronic = e
 ;	}
 	

commit 9536ca9666b84a9667cfc98dad609a1b5b1bed19
Author: kev9268 <99704077+kev9268@users.noreply.github.com>
Date:   Sun Mar 20 18:38:25 2022 -0600

    Rename logic.java to baggingItem.java

diff --git a/src/selfcheckout_software/logic.java b/src/selfcheckout_software/baggingItem.java
similarity index 100%
rename from src/selfcheckout_software/logic.java
rename to src/selfcheckout_software/baggingItem.java

commit 3ed6b70d4977d718fc629028fef2b47f5350dd27
Author: Justin Yu <60626089+justinjelly@users.noreply.github.com>
Date:   Sun Mar 20 18:32:25 2022 -0600

    Edit to detect if coinStorageUnit is full

diff --git a/src/selfcheckout_software/PayWithCoin.java b/src/selfcheckout_software/PayWithCoin.java
index 70f3d28..f2379d8 100644
--- a/src/selfcheckout_software/PayWithCoin.java
+++ b/src/selfcheckout_software/PayWithCoin.java
@@ -8,10 +8,11 @@ import org.lsmr.selfcheckout.devices.observers.*;
 
 // logic for the use case "customer wants to pay with coin" by implementing the CoinValidatorObserver
 // and adding value of a coin to a local variable availableFunds if the proper event occurs (a valid coin is detected). 
-public class PayWithCoin implements CoinValidatorObserver {
+public class PayWithCoin implements CoinValidatorObserver, CoinStorageUnitObserver {
 	
 	private Coin c;
 	private BigDecimal availableFunds = new BigDecimal(0);
+	private Boolean storageFull;
 	
 	public PayWithCoin(Coin c) {
 		this.c = c;
@@ -28,7 +29,9 @@ public class PayWithCoin implements CoinValidatorObserver {
 	// validator determines the coin is valid, add value of coin to sum
 	@Override
 	public void validCoinDetected(CoinValidator validator, BigDecimal value) {
-		availableFunds = availableFunds.add(value);
+		if(!storageFull) {
+			availableFunds = availableFunds.add(value);
+		}
 	}
 
 	// validator determines the coin is not valid, do nothing
@@ -40,4 +43,22 @@ public class PayWithCoin implements CoinValidatorObserver {
 		return availableFunds;
 	}
 
+	@Override
+	public void coinsFull(CoinStorageUnit unit) {
+		storageFull = true;
+	}
+
+	@Override
+	public void coinAdded(CoinStorageUnit unit) {
+	}
+
+	@Override
+	public void coinsLoaded(CoinStorageUnit unit) {
+	}
+
+	@Override
+	public void coinsUnloaded(CoinStorageUnit unit) {
+		storageFull = false;
+	}
+
 }

commit cd0840d48ccbe4fdc64f0fd55125fca3753e810f
Merge: 1e5d146 8f687d6
Author: Manbir Sandhu <mana24129@hotmail.com>
Date:   Sun Mar 20 18:14:53 2022 -0600

    Merge branch 'main' of https://github.com/Manbir1/SENG300Iteration1 into main

commit 1e5d1462b0663de4bf89120cb67113edb4dd81f3
Author: Manbir Sandhu <mana24129@hotmail.com>
Date:   Sun Mar 20 18:14:09 2022 -0600

    Added more tests

diff --git a/src/selfcheckout_software/BanknoteController.java b/src/selfcheckout_software/BanknoteController.java
index a3134c2..cc13658 100644
--- a/src/selfcheckout_software/BanknoteController.java
+++ b/src/selfcheckout_software/BanknoteController.java
@@ -14,6 +14,7 @@ public class BanknoteController implements BanknoteValidatorObserver, BanknoteSt
 
 	private int availableFunds;
 	private int validBanknotes = 0;
+	private int invalidBanknotes = 0;
 	private boolean isFull = false;
 	
 	public BanknoteController(SelfCheckoutStation s) {
@@ -32,13 +33,14 @@ public class BanknoteController implements BanknoteValidatorObserver, BanknoteSt
 	public void validBanknoteDetected(BanknoteValidator validator, Currency currency, int value) {
 		if(!isFull) {
 			availableFunds+=value;
+			validBanknotes++;
 		}
 		
 	}
 
 	@Override
 	public void invalidBanknoteDetected(BanknoteValidator validator) {
-		
+		invalidBanknotes++;
 	}
 
 	@Override
@@ -66,5 +68,13 @@ public class BanknoteController implements BanknoteValidatorObserver, BanknoteSt
 		return availableFunds;
 	}
 	
+	public int getValidBanknotes() {
+		return validBanknotes;
+	}
+	
+	public int getInvalidBanknotes() {
+		return invalidBanknotes;
+	}
+	
 	
 }
diff --git a/src/selfcheckout_test/BanknoteTest.java b/src/selfcheckout_test/BanknoteTest.java
index 382fcb8..8dbdf0b 100644
--- a/src/selfcheckout_test/BanknoteTest.java
+++ b/src/selfcheckout_test/BanknoteTest.java
@@ -52,5 +52,22 @@ public class BanknoteTest {
 		assertEquals(pay.getCurrentFunds(),15);
 	}
 	
+	@Test
+	public void testBanknoteControllerFull() throws DisabledException, OverloadException {
+		Barcode itemCode = new Barcode(new Numeral[] {Numeral.one,Numeral.one});
+		for(int i = 0;i<75;i++)
+			s.banknoteInput.accept(new Banknote(Currency.getInstance("CAD"),5));
+		assertEquals(pay.getCurrentFunds(),5*s.BANKNOTE_STORAGE_CAPACITY);
+	}
+	
+	@Test
+	public void testBanknoteControllerInvalidBanknote() throws DisabledException, OverloadException {
+		s.banknoteInput.accept(new Banknote(Currency.getInstance("USD"),5));
+		assertEquals(0,pay.getCurrentFunds());
+		assertEquals(1,pay.getInvalidBanknotes());
+	}
+	
+	
+	
 	
 }

commit 8f687d6bea4612ed6db64059d35124cca371a4b6
Author: lexahoa <sparr@LAPTOP-V521ED67>
Date:   Sun Mar 20 18:51:31 2022 -0400

    wish_to_checkout test now has 100% coverage

diff --git a/bin/selfcheckout_software/SCSLogic.class b/bin/selfcheckout_software/SCSLogic.class
index ad40b28..ce13634 100644
Binary files a/bin/selfcheckout_software/SCSLogic.class and b/bin/selfcheckout_software/SCSLogic.class differ
diff --git a/bin/selfcheckout_test/test_wish_to_checkout.class b/bin/selfcheckout_test/test_wish_to_checkout.class
index 5697495..2067023 100644
Binary files a/bin/selfcheckout_test/test_wish_to_checkout.class and b/bin/selfcheckout_test/test_wish_to_checkout.class differ
diff --git a/src/selfcheckout_software/SCSLogic.java b/src/selfcheckout_software/SCSLogic.java
index d466e31..d14b5da 100644
--- a/src/selfcheckout_software/SCSLogic.java
+++ b/src/selfcheckout_software/SCSLogic.java
@@ -24,7 +24,6 @@ public class SCSLogic extends AbstractDevice<AbstractDeviceObserver> implements
 	
 	public void wish_checkout(AbstractDeviceObserver payment_method) throws OverloadException, DisabledException  {
 		
-		try {
 			this.attach(payment_method);
 			while(true) {
 				if (!electronic.isDisabled()) {  // keep checking the weight of bagging area, check if the weight has changed
@@ -45,15 +44,6 @@ public class SCSLogic extends AbstractDevice<AbstractDeviceObserver> implements
 				
 			}
 			//....might need to call the matched payment method
-			
-		} catch (OverloadException e) {
-			throw e;
-		}catch (DisabledException e) {
-		    throw e;
-		}
-		
-		
-		
 		
 		
 	}
@@ -69,7 +59,11 @@ public class SCSLogic extends AbstractDevice<AbstractDeviceObserver> implements
 
 	@Override
 	public void accept(AbstractDeviceObserver thing) throws OverloadException, DisabledException {
-			thing.enabled(this);
+		if(observers.size()==1 && observers.contains(thing)) {
+			for(AbstractDeviceObserver A : observers) {
+				A.enabled(this);
+			}
+		}
 	}
 
 
diff --git a/src/selfcheckout_software/ScanItemController.java b/src/selfcheckout_software/ScanItemController.java
index dbabd3b..97aa0c6 100644
--- a/src/selfcheckout_software/ScanItemController.java
+++ b/src/selfcheckout_software/ScanItemController.java
@@ -69,7 +69,7 @@ public class ScanItemController implements BarcodeScannerObserver  {
 		}
 		if(item == null) throw new SimulationException("Barcode does not exist in items");
 		
-		total += product.getPrice();
+		total.add(product.getPrice());
 		expectedWeight += item.getWeight();
 	}
 }
diff --git a/src/selfcheckout_test/ScanItemTest.java b/src/selfcheckout_test/ScanItemTest.java
index 81a9efa..a341d29 100644
--- a/src/selfcheckout_test/ScanItemTest.java
+++ b/src/selfcheckout_test/ScanItemTest.java
@@ -1,6 +1,7 @@
 package selfcheckout_test;
 
 import org.junit.Test;
+import org.lsmr.selfcheckout.devices.SimulationException;
 
 public class ScanItemTest {
 
diff --git a/src/selfcheckout_test/test_wish_to_checkout.java b/src/selfcheckout_test/test_wish_to_checkout.java
index d05d71e..501267a 100644
--- a/src/selfcheckout_test/test_wish_to_checkout.java
+++ b/src/selfcheckout_test/test_wish_to_checkout.java
@@ -44,6 +44,7 @@ public class test_wish_to_checkout {
 		E.attach(w_observer);
 		Item test_item1 = new Item(20) {};
 		Item test_item2 = new Item(40) {};
+		E.endConfigurationPhase();
 		E.add(test_item1);
 		E.enable();
 		
@@ -53,6 +54,16 @@ public class test_wish_to_checkout {
 		
 	}
 	
+	@Test(expected = SimulationException.class)
+	public void test_fail_to_accept()throws OverloadException,DisabledException{
+		AbstractDeviceObserverStub extra_obStub = new AbstractDeviceObserverStub();
+		test_object.attach(extra_obStub);
+		E.endConfigurationPhase();
+		test_object.endConfigurationPhase();
+		test_object.wish_checkout(payment);
+		
+	}
+	
 	@Test
 	public void test_normal_wish() throws OverloadException, DisabledException {
 		test_object.endConfigurationPhase();
@@ -62,6 +73,11 @@ public class test_wish_to_checkout {
 		test_object.wish_checkout(payment);
 		assertTrue("this should be true",test_object.isDisabled());
 		
+	}
+	
+	@Test
+	public void test_has_space() {
+		assertFalse(test_object.hasSpace());
 		
 	}
 	

commit 06b0140f56719397d83814d5a0f2616b08fa66a2
Merge: c69015e dfa2868
Author: Manbir Sandhu <mana24129@hotmail.com>
Date:   Sun Mar 20 16:39:41 2022 -0600

    Merge branch 'main' of https://github.com/Manbir1/SENG300Iteration1 into main

commit c69015eac140ce09e9000bbb7cde204a82cf9cf4
Author: Manbir Sandhu <mana24129@hotmail.com>
Date:   Sun Mar 20 16:38:14 2022 -0600

    started testing

diff --git a/src/selfcheckout_test/BanknoteTest.java b/src/selfcheckout_test/BanknoteTest.java
new file mode 100644
index 0000000..382fcb8
--- /dev/null
+++ b/src/selfcheckout_test/BanknoteTest.java
@@ -0,0 +1,56 @@
+package selfcheckout_test;
+import static org.junit.Assert.*;
+
+import java.math.BigDecimal;
+import java.util.Currency;
+import java.util.HashMap;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.lsmr.selfcheckout.Banknote;
+import org.lsmr.selfcheckout.Barcode;
+import org.lsmr.selfcheckout.Numeral;
+import org.lsmr.selfcheckout.devices.DisabledException;
+import org.lsmr.selfcheckout.devices.OverloadException;
+import org.lsmr.selfcheckout.devices.SelfCheckoutStation;
+import org.lsmr.selfcheckout.products.BarcodedProduct;
+
+import selfcheckout_software.BanknoteController;
+
+public class BanknoteTest {
+	
+	private HashMap<Barcode, BarcodedProduct> products = new HashMap<Barcode, BarcodedProduct>();
+	private BanknoteController pay;
+	private SelfCheckoutStation s;
+	
+	@Before
+	public void setup() {
+		products.put(new Barcode(new Numeral[] {Numeral.one,Numeral.one}), 
+				new BarcodedProduct(new Barcode(new Numeral[] {Numeral.one,Numeral.one}), "Bread", new BigDecimal(4.99)));
+		products.put(new Barcode(new Numeral[] {Numeral.two,Numeral.two}), 
+				new BarcodedProduct(new Barcode(new Numeral[] {Numeral.two,Numeral.two}), "Milk", new BigDecimal(2.50)));
+		products.put(new Barcode(new Numeral[] {Numeral.three,Numeral.three}), 
+				new BarcodedProduct(new Barcode(new Numeral[] {Numeral.three,Numeral.three}), "Oreos", new BigDecimal(10.99)));
+		products.put(new Barcode(new Numeral[] {Numeral.four,Numeral.four}), 
+				new BarcodedProduct(new Barcode(new Numeral[] {Numeral.four,Numeral.four}), "Orange", new BigDecimal(0.99)));
+	    
+	    Currency currency = Currency.getInstance("CAD");
+	    int[] banknoteDenoms = new int[] {5,10,20,50};
+	    BigDecimal[] coinDenominations = new BigDecimal[]{new BigDecimal("0.05"), new BigDecimal("0.10"), 
+	    		new BigDecimal("0.25"), new BigDecimal("0.50"), new BigDecimal("1.00"), new BigDecimal("2.00")};
+	    
+	    
+	    s = new SelfCheckoutStation(currency,banknoteDenoms,coinDenominations,Integer.MAX_VALUE,1);
+	    pay = new BanknoteController(s);
+	}
+	
+	@Test
+	public void testBanknoteControllerRegular() throws DisabledException, OverloadException {
+		Barcode itemCode = new Barcode(new Numeral[] {Numeral.one,Numeral.one});
+		s.banknoteInput.accept(new Banknote(Currency.getInstance("CAD"),5));
+		s.banknoteInput.accept(new Banknote(Currency.getInstance("CAD"),10));
+		assertEquals(pay.getCurrentFunds(),15);
+	}
+	
+	
+}

commit dfa2868b2813b9afbd07c3990379a992297624d8
Author: jameskhalil <87144837+jameskhalil@users.noreply.github.com>
Date:   Sun Mar 20 16:31:07 2022 -0600

    Update ScanItemController.java

diff --git a/src/selfcheckout_software/ScanItemController.java b/src/selfcheckout_software/ScanItemController.java
index 8e2dc13..dbabd3b 100644
--- a/src/selfcheckout_software/ScanItemController.java
+++ b/src/selfcheckout_software/ScanItemController.java
@@ -13,7 +13,6 @@ import org.lsmr.selfcheckout.products.Product;
 
 public class ScanItemController implements BarcodeScannerObserver  {
 	
-	private ArrayList<Product> product = new ArrayList<Product>();
 	private BigDecimal total;
 	private double expectedWeight;
 	
@@ -70,7 +69,7 @@ public class ScanItemController implements BarcodeScannerObserver  {
 		}
 		if(item == null) throw new SimulationException("Barcode does not exist in items");
 		
-		total = total.add(product.getPrice());
+		total += product.getPrice();
 		expectedWeight += item.getWeight();
 	}
 }

commit 115413fb61a1991036a3dc5310470dcf00f1b9dc
Author: jameskhalil <87144837+jameskhalil@users.noreply.github.com>
Date:   Sun Mar 20 16:30:23 2022 -0600

    Create ScanItemTest.java

diff --git a/src/selfcheckout_test/ScanItemTest.java b/src/selfcheckout_test/ScanItemTest.java
new file mode 100644
index 0000000..81a9efa
--- /dev/null
+++ b/src/selfcheckout_test/ScanItemTest.java
@@ -0,0 +1,26 @@
+package selfcheckout_test;
+
+import org.junit.Test;
+
+public class ScanItemTest {
+
+	@Test(expected = SimulationException.class)
+	public void noProduct() {
+		
+	}
+	
+	@Test(expected = SimulationException.class)
+	public void noItem() {
+		
+	}
+	
+	@Test()
+	public void correctTotal() {
+		
+	}
+	
+	@Test()
+	public void correctWeight() {
+		
+	}
+}

commit d0895fecb38ece8fabdecd48af466507059d35cb
Author: jameskhalil <87144837+jameskhalil@users.noreply.github.com>
Date:   Sun Mar 20 16:30:06 2022 -0600

    Delete ScanItemTest.java

diff --git a/ScanItemTest.java b/ScanItemTest.java
deleted file mode 100644
index 81a9efa..0000000
--- a/ScanItemTest.java
+++ /dev/null
@@ -1,26 +0,0 @@
-package selfcheckout_test;
-
-import org.junit.Test;
-
-public class ScanItemTest {
-
-	@Test(expected = SimulationException.class)
-	public void noProduct() {
-		
-	}
-	
-	@Test(expected = SimulationException.class)
-	public void noItem() {
-		
-	}
-	
-	@Test()
-	public void correctTotal() {
-		
-	}
-	
-	@Test()
-	public void correctWeight() {
-		
-	}
-}

commit fa28ff1a942d4dc44b5a3be8856cf74324b08005
Author: jameskhalil <87144837+jameskhalil@users.noreply.github.com>
Date:   Sun Mar 20 16:29:25 2022 -0600

    Create ScanItemTest.java

diff --git a/ScanItemTest.java b/ScanItemTest.java
new file mode 100644
index 0000000..81a9efa
--- /dev/null
+++ b/ScanItemTest.java
@@ -0,0 +1,26 @@
+package selfcheckout_test;
+
+import org.junit.Test;
+
+public class ScanItemTest {
+
+	@Test(expected = SimulationException.class)
+	public void noProduct() {
+		
+	}
+	
+	@Test(expected = SimulationException.class)
+	public void noItem() {
+		
+	}
+	
+	@Test()
+	public void correctTotal() {
+		
+	}
+	
+	@Test()
+	public void correctWeight() {
+		
+	}
+}

commit 5b7fa54828ae438186f8292ee0a2fa41698ce5e8
Author: Justin Yu <60626089+justinjelly@users.noreply.github.com>
Date:   Sun Mar 20 15:43:11 2022 -0600

    Create testPayWithCoin.java

diff --git a/src/selfcheckout_test/testPayWithCoin.java b/src/selfcheckout_test/testPayWithCoin.java
new file mode 100644
index 0000000..42ec8f5
--- /dev/null
+++ b/src/selfcheckout_test/testPayWithCoin.java
@@ -0,0 +1,49 @@
+package selfcheckout_test;
+import selfcheckout_software.*;
+
+import static org.junit.Assert.*;
+
+import java.math.BigDecimal;
+import java.util.Arrays;
+import java.util.Currency;
+import java.util.List;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.lsmr.selfcheckout.*;
+import org.lsmr.selfcheckout.devices.*;
+import org.lsmr.selfcheckout.devices.observers.*;
+
+import junit.extensions.TestSetup;
+
+public class testPayWithCoin {
+	
+	private BigDecimal coinValue;
+	private PayWithCoin test_object;
+	private Coin c;
+	private CoinValidator v;
+	private Currency currency = Currency.getInstance("CAD");
+	private List<BigDecimal> denoms;
+	
+	@Before 
+	public void TestSetup() {
+		this.coinValue = new BigDecimal(1);
+		//this.c = new Coin(currency, coinValue);	
+		this.denoms = Arrays.asList(new BigDecimal(1));
+		this.test_object = new PayWithCoin(c);
+		this.v = new CoinValidator(currency, denoms);
+	}
+	
+	@Test
+	public void testValidCoinDetected() {
+		BigDecimal value = new BigDecimal(5);
+		test_object.validCoinDetected(v, value);
+		assertEquals(test_object.getAvailableFunds(), value);
+	}
+	
+	
+	
+	
+	
+
+}

commit e94afabcd9ad009917879935f616535e3a25881f
Author: Justin Yu <60626089+justinjelly@users.noreply.github.com>
Date:   Sun Mar 20 15:41:51 2022 -0600

    Create PayWithCoin.java
    
    for use case #4

diff --git a/src/selfcheckout_software/PayWithCoin.java b/src/selfcheckout_software/PayWithCoin.java
new file mode 100644
index 0000000..70f3d28
--- /dev/null
+++ b/src/selfcheckout_software/PayWithCoin.java
@@ -0,0 +1,43 @@
+package selfcheckout_software;
+
+import java.math.BigDecimal;
+
+import org.lsmr.selfcheckout.*;
+import org.lsmr.selfcheckout.devices.*;
+import org.lsmr.selfcheckout.devices.observers.*;
+
+// logic for the use case "customer wants to pay with coin" by implementing the CoinValidatorObserver
+// and adding value of a coin to a local variable availableFunds if the proper event occurs (a valid coin is detected). 
+public class PayWithCoin implements CoinValidatorObserver {
+	
+	private Coin c;
+	private BigDecimal availableFunds = new BigDecimal(0);
+	
+	public PayWithCoin(Coin c) {
+		this.c = c;
+	}
+	
+	@Override
+	public void enabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
+	}
+
+	@Override
+	public void disabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
+	}
+
+	// validator determines the coin is valid, add value of coin to sum
+	@Override
+	public void validCoinDetected(CoinValidator validator, BigDecimal value) {
+		availableFunds = availableFunds.add(value);
+	}
+
+	// validator determines the coin is not valid, do nothing
+	@Override
+	public void invalidCoinDetected(CoinValidator validator) {	
+	}
+	
+	public BigDecimal getAvailableFunds() {
+		return availableFunds;
+	}
+
+}

commit c5c95bb9bce33e9906720f05daa2c669a7510ff1
Author: lexahoa <sparr@LAPTOP-V521ED67>
Date:   Sun Mar 20 17:19:26 2022 -0400

    fix some small bugs

diff --git a/.classpath b/.classpath
index b536906..46a3f0e 100644
--- a/.classpath
+++ b/.classpath
@@ -1,6 +1,6 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <classpath>
-	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/jdk-17.0.1">
+	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/jre">
 		<attributes>
 			<attribute name="module" value="true"/>
 		</attributes>
diff --git a/.settings/org.eclipse.jdt.core.prefs b/.settings/org.eclipse.jdt.core.prefs
index 8c9943d..59fe89d 100644
--- a/.settings/org.eclipse.jdt.core.prefs
+++ b/.settings/org.eclipse.jdt.core.prefs
@@ -1,5 +1,6 @@
 eclipse.preferences.version=1
 org.eclipse.jdt.core.compiler.codegen.inlineJsrBytecode=enabled
+org.eclipse.jdt.core.compiler.codegen.methodParameters=do not generate
 org.eclipse.jdt.core.compiler.codegen.targetPlatform=17
 org.eclipse.jdt.core.compiler.codegen.unusedLocal=preserve
 org.eclipse.jdt.core.compiler.compliance=17
@@ -10,5 +11,5 @@ org.eclipse.jdt.core.compiler.problem.assertIdentifier=error
 org.eclipse.jdt.core.compiler.problem.enablePreviewFeatures=disabled
 org.eclipse.jdt.core.compiler.problem.enumIdentifier=error
 org.eclipse.jdt.core.compiler.problem.reportPreviewFeatures=warning
-org.eclipse.jdt.core.compiler.release=enabled
+org.eclipse.jdt.core.compiler.release=disabled
 org.eclipse.jdt.core.compiler.source=17
diff --git a/bin/.gitignore b/bin/.gitignore
new file mode 100644
index 0000000..9f39a93
--- /dev/null
+++ b/bin/.gitignore
@@ -0,0 +1,2 @@
+/selfcheckout_software/
+/selfcheckout_test/
diff --git a/src/selfcheckout_software/ScanItemController.java b/src/selfcheckout_software/ScanItemController.java
index adc727d..8e2dc13 100644
--- a/src/selfcheckout_software/ScanItemController.java
+++ b/src/selfcheckout_software/ScanItemController.java
@@ -11,7 +11,7 @@ import org.lsmr.selfcheckout.devices.observers.BarcodeScannerObserver;
 import org.lsmr.selfcheckout.products.BarcodedProduct;
 import org.lsmr.selfcheckout.products.Product;
 
-public class ScanItemController implements BarcodeScannerObserver,  {
+public class ScanItemController implements BarcodeScannerObserver  {
 	
 	private ArrayList<Product> product = new ArrayList<Product>();
 	private BigDecimal total;
@@ -52,15 +52,15 @@ public class ScanItemController implements BarcodeScannerObserver,  {
 	 *             If there is no product or item with the respective barcode
 	 */
 	public void addItem(Barcode barcode, BarcodedProduct[] productList, BarcodedItem[] itemList){
-		BarcodedProduct product;
-		BarcodedItem item;
+		BarcodedProduct product = null;
+		BarcodedItem item = null;
 		for(int i = 0; i < productList.length; i++) {
 			if(barcode==productList[i].getBarcode()) {
 				product = productList[i];
 				break;
 			}
 		}
-		if(product == null) throw new SimulationException("Barcode does not exist in products")
+		if(product == null) throw new SimulationException("Barcode does not exist in products");
 		
 		for(int i = 0; i < itemList.length; i++) {
 			if(barcode==itemList[i].getBarcode()) {
@@ -68,9 +68,9 @@ public class ScanItemController implements BarcodeScannerObserver,  {
 				break;
 			}
 		}
-		if(item == null) throw new SimulationException("Barcode does not exist in items")
+		if(item == null) throw new SimulationException("Barcode does not exist in items");
 		
-		total += product.getPrice();
+		total = total.add(product.getPrice());
 		expectedWeight += item.getWeight();
 	}
 }
diff --git a/src/selfcheckout_software/logic.java b/src/selfcheckout_software/logic.java
index f0868a6..65bec34 100644
--- a/src/selfcheckout_software/logic.java
+++ b/src/selfcheckout_software/logic.java
@@ -1,4 +1,4 @@
-package selfcheckout_software
+package selfcheckout_software;
 import java.util.ArrayList;
 
 import org.lsmr.selfcheckout.Item;
@@ -46,6 +46,9 @@ public class logic implements ElectronicScaleObserver{
 			throw new SimulationException("Please put the correct items in the bagging area");
 		}
 		}
+	public double get_expected_weight() {
+		return this.expectedWeight;
+	}
 
 	@Override
 	public void enabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
diff --git a/src/selfcheckout_test/logicTest.java b/src/selfcheckout_test/logicTest.java
index 7e958c9..1a89f03 100644
--- a/src/selfcheckout_test/logicTest.java
+++ b/src/selfcheckout_test/logicTest.java
@@ -1,4 +1,5 @@
 package selfcheckout_test;
+import selfcheckout_software.*;
 import static org.junit.Assert.*;
 
 import java.util.ArrayList;
@@ -50,7 +51,7 @@ public class logicTest {
 	public void testBaggingItem() throws OverloadException{
 		e.endConfigurationPhase();
 		test.bagItem(item3, e);
-		Assert.assertTrue(test.expectedWeight==7);
+		assertEquals((double)7, test.get_expected_weight(),1);
 		
 	}
 	

commit 5d31754b0d989b26a44b4c720e69a20def220752
Author: jameskhalil <87144837+jameskhalil@users.noreply.github.com>
Date:   Sun Mar 20 12:32:17 2022 -0600

    Update ScanItemController.java

diff --git a/src/selfcheckout_software/ScanItemController.java b/src/selfcheckout_software/ScanItemController.java
index e636bbe..adc727d 100644
--- a/src/selfcheckout_software/ScanItemController.java
+++ b/src/selfcheckout_software/ScanItemController.java
@@ -5,6 +5,7 @@ import org.lsmr.selfcheckout.Barcode;
 import org.lsmr.selfcheckout.BarcodedItem;
 import org.lsmr.selfcheckout.devices.AbstractDevice;
 import org.lsmr.selfcheckout.devices.BarcodeScanner;
+import org.lsmr.selfcheckout.devices.SimulationException;
 import org.lsmr.selfcheckout.devices.observers.AbstractDeviceObserver;
 import org.lsmr.selfcheckout.devices.observers.BarcodeScannerObserver;
 import org.lsmr.selfcheckout.products.BarcodedProduct;
@@ -14,6 +15,7 @@ public class ScanItemController implements BarcodeScannerObserver,  {
 	
 	private ArrayList<Product> product = new ArrayList<Product>();
 	private BigDecimal total;
+	private double expectedWeight;
 	
 	public ScanItemController() {
 		
@@ -37,10 +39,38 @@ public class ScanItemController implements BarcodeScannerObserver,  {
 		
 	}
 	
-	public void addItem(BarcodedProduct Item) {
-		product.add(Item);
-		total += Item.getPrice();
+	/**
+	 * Adds the weight and price of the item and product related to the barcode
+	 * 
+	 * @param barcode
+	 *            The barcode that was scanned in
+	 * @param productList
+	 * 			  List of all products with a barcode
+	 * @param itemList
+	 * 			  List of all items with a barcode
+	 * @throws SimulationException
+	 *             If there is no product or item with the respective barcode
+	 */
+	public void addItem(Barcode barcode, BarcodedProduct[] productList, BarcodedItem[] itemList){
+		BarcodedProduct product;
+		BarcodedItem item;
+		for(int i = 0; i < productList.length; i++) {
+			if(barcode==productList[i].getBarcode()) {
+				product = productList[i];
+				break;
+			}
+		}
+		if(product == null) throw new SimulationException("Barcode does not exist in products")
 		
+		for(int i = 0; i < itemList.length; i++) {
+			if(barcode==itemList[i].getBarcode()) {
+				item = itemList[i];
+				break;
+			}
+		}
+		if(item == null) throw new SimulationException("Barcode does not exist in items")
+		
+		total += product.getPrice();
+		expectedWeight += item.getWeight();
 	}
-	
 }

commit e3f5f8f91455546010b8afa861221a69b72801f8
Author: kev9268 <99704077+kev9268@users.noreply.github.com>
Date:   Sun Mar 20 08:55:14 2022 -0600

    Update logic.java

diff --git a/src/selfcheckout_software/logic.java b/src/selfcheckout_software/logic.java
index a0d4569..f0868a6 100644
--- a/src/selfcheckout_software/logic.java
+++ b/src/selfcheckout_software/logic.java
@@ -1,4 +1,4 @@
-
+package selfcheckout_software
 import java.util.ArrayList;
 
 import org.lsmr.selfcheckout.Item;

commit 64aefcc0631c94dc0193262266f2c8ef1dd4f8a5
Author: kev9268 <99704077+kev9268@users.noreply.github.com>
Date:   Sun Mar 20 08:54:52 2022 -0600

    Update logicTest.java

diff --git a/src/selfcheckout_test/logicTest.java b/src/selfcheckout_test/logicTest.java
index 032c5c9..7e958c9 100644
--- a/src/selfcheckout_test/logicTest.java
+++ b/src/selfcheckout_test/logicTest.java
@@ -1,3 +1,4 @@
+package selfcheckout_test;
 import static org.junit.Assert.*;
 
 import java.util.ArrayList;

commit 0d4aa5c8351691f19780b4d26bbe65da108101fb
Author: kev9268 <99704077+kev9268@users.noreply.github.com>
Date:   Sun Mar 20 08:54:11 2022 -0600

    Add files via upload

diff --git a/src/selfcheckout_test/logicTest.java b/src/selfcheckout_test/logicTest.java
new file mode 100644
index 0000000..032c5c9
--- /dev/null
+++ b/src/selfcheckout_test/logicTest.java
@@ -0,0 +1,73 @@
+import static org.junit.Assert.*;
+
+import java.util.ArrayList;
+
+import org.junit.Before;
+import org.junit.Test;
+
+import org.lsmr.selfcheckout.Item;
+import org.lsmr.selfcheckout.devices.AbstractDevice;
+import org.lsmr.selfcheckout.devices.Acceptor;
+import org.lsmr.selfcheckout.devices.DisabledException;
+import org.lsmr.selfcheckout.devices.ElectronicScale;
+import org.lsmr.selfcheckout.devices.OverloadException;
+import org.lsmr.selfcheckout.devices.SimulationException;
+import org.lsmr.selfcheckout.devices.observers.AbstractDeviceObserver;
+import org.lsmr.selfcheckout.devices.observers.ElectronicScaleObserver;
+
+import junit.framework.Assert;
+
+class ItemClass extends Item {
+	ItemClass() {
+		super(10);
+	}
+	ItemClass(double weight) {
+		super(weight);
+	}
+}
+public class logicTest {
+
+	private ElectronicScale e;
+	private ArrayList<Item> list;
+	private Item item1;
+	private Item item2;
+	private Item item3;
+	private Item item4;
+	private logic test;
+	
+	@Before
+	public void setUp() throws Exception {
+		this.e = new ElectronicScale(50,1);
+		this.test = new logic(e);
+		item1 = new ItemClass(5);
+		item2 = new ItemClass(50);
+		item3 = new ItemClass(7);
+		
+	}
+
+	@Test
+	public void testBaggingItem() throws OverloadException{
+		e.endConfigurationPhase();
+		test.bagItem(item3, e);
+		Assert.assertTrue(test.expectedWeight==7);
+		
+	}
+	
+	@Test (expected = OverloadException.class)
+	public void testOverweightLimit() throws OverloadException{
+		e.endConfigurationPhase();
+		test.bagItem(item2, e);
+		test.bagItem(item1, e);
+	}
+	
+	@Test (expected = SimulationException.class)
+	public void testWrongItem() throws OverloadException{
+		e.endConfigurationPhase();
+		
+		test.bagItem(item1, e);
+		e.add(item3);
+		test.bagItem(item1, e);
+	}
+	
+
+}

commit ff2d1b060ed4a33a1d2560b0721b3da7e33ba900
Author: kev9268 <99704077+kev9268@users.noreply.github.com>
Date:   Sun Mar 20 08:53:06 2022 -0600

    Add files via upload

diff --git a/src/selfcheckout_software/logic.java b/src/selfcheckout_software/logic.java
new file mode 100644
index 0000000..a0d4569
--- /dev/null
+++ b/src/selfcheckout_software/logic.java
@@ -0,0 +1,82 @@
+
+import java.util.ArrayList;
+
+import org.lsmr.selfcheckout.Item;
+import org.lsmr.selfcheckout.devices.AbstractDevice;
+import org.lsmr.selfcheckout.devices.Acceptor;
+import org.lsmr.selfcheckout.devices.DisabledException;
+import org.lsmr.selfcheckout.devices.ElectronicScale;
+import org.lsmr.selfcheckout.devices.OverloadException;
+import org.lsmr.selfcheckout.devices.SimulationException;
+import org.lsmr.selfcheckout.devices.observers.AbstractDeviceObserver;
+import org.lsmr.selfcheckout.devices.observers.ElectronicScaleObserver;
+
+public class logic implements ElectronicScaleObserver{
+	
+	
+	
+	private ElectronicScale electronic;
+	
+	private ArrayList<Item> items = new ArrayList<>();
+	
+	double expectedWeight;
+	
+	public logic(ElectronicScale e) {
+		this.electronic = e
+;	}
+	
+	public void bagItem(Item i, ElectronicScale e) throws OverloadException, SimulationException {
+		double maxWeight = e.getWeightLimit();
+		double current = e.getCurrentWeight();
+		if (e.getCurrentWeight()==0) {			//logic to make sure that the scale is empty before actually scanning items
+			current = e.getCurrentWeight();
+			e.add(i);
+		} else {								//proceeds normally after the first scanned item	
+			e.add(i);
+			current = e.getCurrentWeight();
+		}
+		double itemWeight = i.getWeight();
+		expectedWeight = current + itemWeight;
+		double updatedWeight = e.getCurrentWeight();
+		System.out.println(expectedWeight);
+		if (updatedWeight>maxWeight) {
+			throw new OverloadException();
+		}
+		if (updatedWeight!=expectedWeight) {
+			throw new SimulationException("Please put the correct items in the bagging area");
+		}
+		}
+
+	@Override
+	public void enabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
+		// TODO Auto-generated method stub
+		
+	}
+
+	@Override
+	public void disabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
+		// TODO Auto-generated method stub
+		
+	}
+
+	@Override
+	public void weightChanged(ElectronicScale scale, double weightInGrams) {
+		// TODO Auto-generated method stub
+		
+	}
+
+	@Override
+	public void overload(ElectronicScale scale) {
+		// TODO Auto-generated method stub
+		
+	}
+
+	@Override
+	public void outOfOverload(ElectronicScale scale) {
+		// TODO Auto-generated method stub
+		
+	}
+
+	
+
+}

commit 35f5b9649e38f62f78384781ff3c1c50aa88c4ff
Author: jameskhalil <87144837+jameskhalil@users.noreply.github.com>
Date:   Sat Mar 19 20:08:55 2022 -0600

    Create ScanItemController.java

diff --git a/src/selfcheckout_software/ScanItemController.java b/src/selfcheckout_software/ScanItemController.java
new file mode 100644
index 0000000..e636bbe
--- /dev/null
+++ b/src/selfcheckout_software/ScanItemController.java
@@ -0,0 +1,46 @@
+package selfcheckout_software;
+import java.math.BigDecimal;
+import java.util.ArrayList;
+import org.lsmr.selfcheckout.Barcode;
+import org.lsmr.selfcheckout.BarcodedItem;
+import org.lsmr.selfcheckout.devices.AbstractDevice;
+import org.lsmr.selfcheckout.devices.BarcodeScanner;
+import org.lsmr.selfcheckout.devices.observers.AbstractDeviceObserver;
+import org.lsmr.selfcheckout.devices.observers.BarcodeScannerObserver;
+import org.lsmr.selfcheckout.products.BarcodedProduct;
+import org.lsmr.selfcheckout.products.Product;
+
+public class ScanItemController implements BarcodeScannerObserver,  {
+	
+	private ArrayList<Product> product = new ArrayList<Product>();
+	private BigDecimal total;
+	
+	public ScanItemController() {
+		
+	}
+
+	@Override
+	public void enabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
+		// TODO Auto-generated method stub
+		
+	}
+
+	@Override
+	public void disabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
+		// TODO Auto-generated method stub
+		
+	}
+
+	@Override
+	public void barcodeScanned(BarcodeScanner barcodeScanner, Barcode barcode) {
+		// TODO Auto-generated method stub
+		
+	}
+	
+	public void addItem(BarcodedProduct Item) {
+		product.add(Item);
+		total += Item.getPrice();
+		
+	}
+	
+}

commit a1646241ec39b5a74ddfb3b6f29979155cc5faa6
Author: lexahoa <sparr@LAPTOP-V521ED67>
Date:   Fri Mar 18 22:51:29 2022 -0400

    some updates, new package and extra junit lib

diff --git a/.classpath b/.classpath
index 8cf4aa1..b536906 100644
--- a/.classpath
+++ b/.classpath
@@ -1,10 +1,11 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <classpath>
-	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/JavaSE-17">
+	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/jdk-17.0.1">
 		<attributes>
 			<attribute name="module" value="true"/>
 		</attributes>
 	</classpathentry>
+	<classpathentry kind="con" path="org.eclipse.jdt.junit.JUNIT_CONTAINER/4"/>
 	<classpathentry kind="src" path="src"/>
 	<classpathentry kind="src" path="SCS - Hardware - v1.0/src"/>
 	<classpathentry kind="output" path="bin"/>
diff --git a/bin/BanknoteController.class b/bin/BanknoteController.class
deleted file mode 100644
index 6c0aa0b..0000000
Binary files a/bin/BanknoteController.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/Banknote.class b/bin/org/lsmr/selfcheckout/Banknote.class
index 0416eb6..3b81981 100644
Binary files a/bin/org/lsmr/selfcheckout/Banknote.class and b/bin/org/lsmr/selfcheckout/Banknote.class differ
diff --git a/bin/org/lsmr/selfcheckout/Barcode.class b/bin/org/lsmr/selfcheckout/Barcode.class
index 464a475..2a9a140 100644
Binary files a/bin/org/lsmr/selfcheckout/Barcode.class and b/bin/org/lsmr/selfcheckout/Barcode.class differ
diff --git a/bin/org/lsmr/selfcheckout/BarcodedItem.class b/bin/org/lsmr/selfcheckout/BarcodedItem.class
index de7368f..904e34b 100644
Binary files a/bin/org/lsmr/selfcheckout/BarcodedItem.class and b/bin/org/lsmr/selfcheckout/BarcodedItem.class differ
diff --git a/bin/org/lsmr/selfcheckout/BlockedCardException.class b/bin/org/lsmr/selfcheckout/BlockedCardException.class
index 0342831..98d47e2 100644
Binary files a/bin/org/lsmr/selfcheckout/BlockedCardException.class and b/bin/org/lsmr/selfcheckout/BlockedCardException.class differ
diff --git a/bin/org/lsmr/selfcheckout/Card$CardData.class b/bin/org/lsmr/selfcheckout/Card$CardData.class
index 3a5a24b..21aecb0 100644
Binary files a/bin/org/lsmr/selfcheckout/Card$CardData.class and b/bin/org/lsmr/selfcheckout/Card$CardData.class differ
diff --git a/bin/org/lsmr/selfcheckout/Card$CardInsertData.class b/bin/org/lsmr/selfcheckout/Card$CardInsertData.class
index b1844b6..b8fe14c 100644
Binary files a/bin/org/lsmr/selfcheckout/Card$CardInsertData.class and b/bin/org/lsmr/selfcheckout/Card$CardInsertData.class differ
diff --git a/bin/org/lsmr/selfcheckout/Card$CardSwipeData.class b/bin/org/lsmr/selfcheckout/Card$CardSwipeData.class
index 38d5704..9ab14eb 100644
Binary files a/bin/org/lsmr/selfcheckout/Card$CardSwipeData.class and b/bin/org/lsmr/selfcheckout/Card$CardSwipeData.class differ
diff --git a/bin/org/lsmr/selfcheckout/Card$CardTapData.class b/bin/org/lsmr/selfcheckout/Card$CardTapData.class
index c51bac1..cf9b332 100644
Binary files a/bin/org/lsmr/selfcheckout/Card$CardTapData.class and b/bin/org/lsmr/selfcheckout/Card$CardTapData.class differ
diff --git a/bin/org/lsmr/selfcheckout/Card.class b/bin/org/lsmr/selfcheckout/Card.class
index 7ca0563..dd0466e 100644
Binary files a/bin/org/lsmr/selfcheckout/Card.class and b/bin/org/lsmr/selfcheckout/Card.class differ
diff --git a/bin/org/lsmr/selfcheckout/ChipFailureException.class b/bin/org/lsmr/selfcheckout/ChipFailureException.class
index f4aaf48..b846f50 100644
Binary files a/bin/org/lsmr/selfcheckout/ChipFailureException.class and b/bin/org/lsmr/selfcheckout/ChipFailureException.class differ
diff --git a/bin/org/lsmr/selfcheckout/Coin.class b/bin/org/lsmr/selfcheckout/Coin.class
index 55e3cde..a518210 100644
Binary files a/bin/org/lsmr/selfcheckout/Coin.class and b/bin/org/lsmr/selfcheckout/Coin.class differ
diff --git a/bin/org/lsmr/selfcheckout/IllegalDigitException.class b/bin/org/lsmr/selfcheckout/IllegalDigitException.class
index ecf0201..ba0d46d 100644
Binary files a/bin/org/lsmr/selfcheckout/IllegalDigitException.class and b/bin/org/lsmr/selfcheckout/IllegalDigitException.class differ
diff --git a/bin/org/lsmr/selfcheckout/InvalidPINException.class b/bin/org/lsmr/selfcheckout/InvalidPINException.class
index 9a7fdaa..e1db508 100644
Binary files a/bin/org/lsmr/selfcheckout/InvalidPINException.class and b/bin/org/lsmr/selfcheckout/InvalidPINException.class differ
diff --git a/bin/org/lsmr/selfcheckout/Item.class b/bin/org/lsmr/selfcheckout/Item.class
index a3468c5..b93ecba 100644
Binary files a/bin/org/lsmr/selfcheckout/Item.class and b/bin/org/lsmr/selfcheckout/Item.class differ
diff --git a/bin/org/lsmr/selfcheckout/MagneticStripeFailureException.class b/bin/org/lsmr/selfcheckout/MagneticStripeFailureException.class
index f3ef20e..59dd493 100644
Binary files a/bin/org/lsmr/selfcheckout/MagneticStripeFailureException.class and b/bin/org/lsmr/selfcheckout/MagneticStripeFailureException.class differ
diff --git a/bin/org/lsmr/selfcheckout/Numeral.class b/bin/org/lsmr/selfcheckout/Numeral.class
index fa00a27..7bf788b 100644
Binary files a/bin/org/lsmr/selfcheckout/Numeral.class and b/bin/org/lsmr/selfcheckout/Numeral.class differ
diff --git a/bin/org/lsmr/selfcheckout/PLUCodedItem.class b/bin/org/lsmr/selfcheckout/PLUCodedItem.class
index eec7e69..fad72b2 100644
Binary files a/bin/org/lsmr/selfcheckout/PLUCodedItem.class and b/bin/org/lsmr/selfcheckout/PLUCodedItem.class differ
diff --git a/bin/org/lsmr/selfcheckout/PriceLookupCode.class b/bin/org/lsmr/selfcheckout/PriceLookupCode.class
index 22ee588..babd198 100644
Binary files a/bin/org/lsmr/selfcheckout/PriceLookupCode.class and b/bin/org/lsmr/selfcheckout/PriceLookupCode.class differ
diff --git a/bin/org/lsmr/selfcheckout/TapFailureException.class b/bin/org/lsmr/selfcheckout/TapFailureException.class
index b22f856..8bddf8b 100644
Binary files a/bin/org/lsmr/selfcheckout/TapFailureException.class and b/bin/org/lsmr/selfcheckout/TapFailureException.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/AbstractDevice$Phase.class b/bin/org/lsmr/selfcheckout/devices/AbstractDevice$Phase.class
index f66cc1a..f4b5c50 100644
Binary files a/bin/org/lsmr/selfcheckout/devices/AbstractDevice$Phase.class and b/bin/org/lsmr/selfcheckout/devices/AbstractDevice$Phase.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/AbstractDevice.class b/bin/org/lsmr/selfcheckout/devices/AbstractDevice.class
index 7135fa4..3ce33b9 100644
Binary files a/bin/org/lsmr/selfcheckout/devices/AbstractDevice.class and b/bin/org/lsmr/selfcheckout/devices/AbstractDevice.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/Acceptor.class b/bin/org/lsmr/selfcheckout/devices/Acceptor.class
index 45c016e..9113c51 100644
Binary files a/bin/org/lsmr/selfcheckout/devices/Acceptor.class and b/bin/org/lsmr/selfcheckout/devices/Acceptor.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/BanknoteDispenser.class b/bin/org/lsmr/selfcheckout/devices/BanknoteDispenser.class
index 34485ac..aa24008 100644
Binary files a/bin/org/lsmr/selfcheckout/devices/BanknoteDispenser.class and b/bin/org/lsmr/selfcheckout/devices/BanknoteDispenser.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/BanknoteSlot.class b/bin/org/lsmr/selfcheckout/devices/BanknoteSlot.class
index 79a1500..f729648 100644
Binary files a/bin/org/lsmr/selfcheckout/devices/BanknoteSlot.class and b/bin/org/lsmr/selfcheckout/devices/BanknoteSlot.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/BanknoteStorageUnit.class b/bin/org/lsmr/selfcheckout/devices/BanknoteStorageUnit.class
index 9af0ff3..ea63e8f 100644
Binary files a/bin/org/lsmr/selfcheckout/devices/BanknoteStorageUnit.class and b/bin/org/lsmr/selfcheckout/devices/BanknoteStorageUnit.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/BanknoteValidator.class b/bin/org/lsmr/selfcheckout/devices/BanknoteValidator.class
index c008572..f308fb9 100644
Binary files a/bin/org/lsmr/selfcheckout/devices/BanknoteValidator.class and b/bin/org/lsmr/selfcheckout/devices/BanknoteValidator.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/BarcodeScanner.class b/bin/org/lsmr/selfcheckout/devices/BarcodeScanner.class
index 1b0049f..b46b109 100644
Binary files a/bin/org/lsmr/selfcheckout/devices/BarcodeScanner.class and b/bin/org/lsmr/selfcheckout/devices/BarcodeScanner.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/BidirectionalChannel.class b/bin/org/lsmr/selfcheckout/devices/BidirectionalChannel.class
index adfe35a..c7344b7 100644
Binary files a/bin/org/lsmr/selfcheckout/devices/BidirectionalChannel.class and b/bin/org/lsmr/selfcheckout/devices/BidirectionalChannel.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/CardReader.class b/bin/org/lsmr/selfcheckout/devices/CardReader.class
index bc75481..109a005 100644
Binary files a/bin/org/lsmr/selfcheckout/devices/CardReader.class and b/bin/org/lsmr/selfcheckout/devices/CardReader.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/CoinDispenser.class b/bin/org/lsmr/selfcheckout/devices/CoinDispenser.class
index e949320..2066e9b 100644
Binary files a/bin/org/lsmr/selfcheckout/devices/CoinDispenser.class and b/bin/org/lsmr/selfcheckout/devices/CoinDispenser.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/CoinSlot.class b/bin/org/lsmr/selfcheckout/devices/CoinSlot.class
index b06c85d..781b206 100644
Binary files a/bin/org/lsmr/selfcheckout/devices/CoinSlot.class and b/bin/org/lsmr/selfcheckout/devices/CoinSlot.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/CoinStorageUnit.class b/bin/org/lsmr/selfcheckout/devices/CoinStorageUnit.class
index 4fa1b4f..e755e04 100644
Binary files a/bin/org/lsmr/selfcheckout/devices/CoinStorageUnit.class and b/bin/org/lsmr/selfcheckout/devices/CoinStorageUnit.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/CoinTray.class b/bin/org/lsmr/selfcheckout/devices/CoinTray.class
index 91f3706..6e55b32 100644
Binary files a/bin/org/lsmr/selfcheckout/devices/CoinTray.class and b/bin/org/lsmr/selfcheckout/devices/CoinTray.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/CoinValidator.class b/bin/org/lsmr/selfcheckout/devices/CoinValidator.class
index f87b5f2..fe0c4c9 100644
Binary files a/bin/org/lsmr/selfcheckout/devices/CoinValidator.class and b/bin/org/lsmr/selfcheckout/devices/CoinValidator.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/DisabledException.class b/bin/org/lsmr/selfcheckout/devices/DisabledException.class
index 160c02e..f4bf3c3 100644
Binary files a/bin/org/lsmr/selfcheckout/devices/DisabledException.class and b/bin/org/lsmr/selfcheckout/devices/DisabledException.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/ElectronicScale.class b/bin/org/lsmr/selfcheckout/devices/ElectronicScale.class
index 23e2f9c..8b9ef5d 100644
Binary files a/bin/org/lsmr/selfcheckout/devices/ElectronicScale.class and b/bin/org/lsmr/selfcheckout/devices/ElectronicScale.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/Emitter.class b/bin/org/lsmr/selfcheckout/devices/Emitter.class
index 7a295ba..d2bb395 100644
Binary files a/bin/org/lsmr/selfcheckout/devices/Emitter.class and b/bin/org/lsmr/selfcheckout/devices/Emitter.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/EmptyException.class b/bin/org/lsmr/selfcheckout/devices/EmptyException.class
index 877ad17..1aa1d89 100644
Binary files a/bin/org/lsmr/selfcheckout/devices/EmptyException.class and b/bin/org/lsmr/selfcheckout/devices/EmptyException.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/FlowThroughEmitter.class b/bin/org/lsmr/selfcheckout/devices/FlowThroughEmitter.class
index c8cb670..0577624 100644
Binary files a/bin/org/lsmr/selfcheckout/devices/FlowThroughEmitter.class and b/bin/org/lsmr/selfcheckout/devices/FlowThroughEmitter.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/FromStorageEmitter.class b/bin/org/lsmr/selfcheckout/devices/FromStorageEmitter.class
index 962fb88..1e1ffbd 100644
Binary files a/bin/org/lsmr/selfcheckout/devices/FromStorageEmitter.class and b/bin/org/lsmr/selfcheckout/devices/FromStorageEmitter.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/OverloadException.class b/bin/org/lsmr/selfcheckout/devices/OverloadException.class
index 026d948..6ab58bc 100644
Binary files a/bin/org/lsmr/selfcheckout/devices/OverloadException.class and b/bin/org/lsmr/selfcheckout/devices/OverloadException.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/ReceiptPrinter.class b/bin/org/lsmr/selfcheckout/devices/ReceiptPrinter.class
index a3cbbad..a7104d5 100644
Binary files a/bin/org/lsmr/selfcheckout/devices/ReceiptPrinter.class and b/bin/org/lsmr/selfcheckout/devices/ReceiptPrinter.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/SelfCheckoutStation.class b/bin/org/lsmr/selfcheckout/devices/SelfCheckoutStation.class
index d8362c2..56e7dfc 100644
Binary files a/bin/org/lsmr/selfcheckout/devices/SelfCheckoutStation.class and b/bin/org/lsmr/selfcheckout/devices/SelfCheckoutStation.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/SimulationException.class b/bin/org/lsmr/selfcheckout/devices/SimulationException.class
index 4f0bdb9..2b4c563 100644
Binary files a/bin/org/lsmr/selfcheckout/devices/SimulationException.class and b/bin/org/lsmr/selfcheckout/devices/SimulationException.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/UnidirectionalChannel.class b/bin/org/lsmr/selfcheckout/devices/UnidirectionalChannel.class
index 4dc61ad..a24b91e 100644
Binary files a/bin/org/lsmr/selfcheckout/devices/UnidirectionalChannel.class and b/bin/org/lsmr/selfcheckout/devices/UnidirectionalChannel.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/AbstractDeviceObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/AbstractDeviceObserver.class
index 185b861..247e22d 100644
Binary files a/bin/org/lsmr/selfcheckout/devices/observers/AbstractDeviceObserver.class and b/bin/org/lsmr/selfcheckout/devices/observers/AbstractDeviceObserver.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/BanknoteDispenserObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/BanknoteDispenserObserver.class
index dcb2f02..2d6cddc 100644
Binary files a/bin/org/lsmr/selfcheckout/devices/observers/BanknoteDispenserObserver.class and b/bin/org/lsmr/selfcheckout/devices/observers/BanknoteDispenserObserver.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/BanknoteSlotObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/BanknoteSlotObserver.class
index a89eead..221e426 100644
Binary files a/bin/org/lsmr/selfcheckout/devices/observers/BanknoteSlotObserver.class and b/bin/org/lsmr/selfcheckout/devices/observers/BanknoteSlotObserver.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/BanknoteStorageUnitObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/BanknoteStorageUnitObserver.class
index 2671b9f..043983d 100644
Binary files a/bin/org/lsmr/selfcheckout/devices/observers/BanknoteStorageUnitObserver.class and b/bin/org/lsmr/selfcheckout/devices/observers/BanknoteStorageUnitObserver.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/BanknoteValidatorObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/BanknoteValidatorObserver.class
index 2f6bb87..8838fb1 100644
Binary files a/bin/org/lsmr/selfcheckout/devices/observers/BanknoteValidatorObserver.class and b/bin/org/lsmr/selfcheckout/devices/observers/BanknoteValidatorObserver.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/BarcodeScannerObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/BarcodeScannerObserver.class
index 7c4bb1e..56fc44a 100644
Binary files a/bin/org/lsmr/selfcheckout/devices/observers/BarcodeScannerObserver.class and b/bin/org/lsmr/selfcheckout/devices/observers/BarcodeScannerObserver.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/CardReaderObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/CardReaderObserver.class
index 1718764..26fe866 100644
Binary files a/bin/org/lsmr/selfcheckout/devices/observers/CardReaderObserver.class and b/bin/org/lsmr/selfcheckout/devices/observers/CardReaderObserver.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/CoinDispenserObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/CoinDispenserObserver.class
index 9283409..057849f 100644
Binary files a/bin/org/lsmr/selfcheckout/devices/observers/CoinDispenserObserver.class and b/bin/org/lsmr/selfcheckout/devices/observers/CoinDispenserObserver.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/CoinSlotObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/CoinSlotObserver.class
index 3b00362..af69753 100644
Binary files a/bin/org/lsmr/selfcheckout/devices/observers/CoinSlotObserver.class and b/bin/org/lsmr/selfcheckout/devices/observers/CoinSlotObserver.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/CoinStorageUnitObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/CoinStorageUnitObserver.class
index da91d12..f6b4b05 100644
Binary files a/bin/org/lsmr/selfcheckout/devices/observers/CoinStorageUnitObserver.class and b/bin/org/lsmr/selfcheckout/devices/observers/CoinStorageUnitObserver.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/CoinTrayObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/CoinTrayObserver.class
index bf26991..6bd2a6e 100644
Binary files a/bin/org/lsmr/selfcheckout/devices/observers/CoinTrayObserver.class and b/bin/org/lsmr/selfcheckout/devices/observers/CoinTrayObserver.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/CoinValidatorObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/CoinValidatorObserver.class
index 817e5dc..a1b2c79 100644
Binary files a/bin/org/lsmr/selfcheckout/devices/observers/CoinValidatorObserver.class and b/bin/org/lsmr/selfcheckout/devices/observers/CoinValidatorObserver.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/ElectronicScaleObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/ElectronicScaleObserver.class
index cfcc4eb..af886a7 100644
Binary files a/bin/org/lsmr/selfcheckout/devices/observers/ElectronicScaleObserver.class and b/bin/org/lsmr/selfcheckout/devices/observers/ElectronicScaleObserver.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/ReceiptPrinterObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/ReceiptPrinterObserver.class
index f4d748e..d93a2ee 100644
Binary files a/bin/org/lsmr/selfcheckout/devices/observers/ReceiptPrinterObserver.class and b/bin/org/lsmr/selfcheckout/devices/observers/ReceiptPrinterObserver.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/TouchScreenObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/TouchScreenObserver.class
index 9e96845..ea9378e 100644
Binary files a/bin/org/lsmr/selfcheckout/devices/observers/TouchScreenObserver.class and b/bin/org/lsmr/selfcheckout/devices/observers/TouchScreenObserver.class differ
diff --git a/bin/org/lsmr/selfcheckout/products/BarcodedProduct.class b/bin/org/lsmr/selfcheckout/products/BarcodedProduct.class
index 5d971c7..bd46533 100644
Binary files a/bin/org/lsmr/selfcheckout/products/BarcodedProduct.class and b/bin/org/lsmr/selfcheckout/products/BarcodedProduct.class differ
diff --git a/bin/org/lsmr/selfcheckout/products/PLUCodedProduct.class b/bin/org/lsmr/selfcheckout/products/PLUCodedProduct.class
index 2c232ee..95698b3 100644
Binary files a/bin/org/lsmr/selfcheckout/products/PLUCodedProduct.class and b/bin/org/lsmr/selfcheckout/products/PLUCodedProduct.class differ
diff --git a/bin/org/lsmr/selfcheckout/products/Product.class b/bin/org/lsmr/selfcheckout/products/Product.class
index e0f34c2..c7ee9be 100644
Binary files a/bin/org/lsmr/selfcheckout/products/Product.class and b/bin/org/lsmr/selfcheckout/products/Product.class differ
diff --git a/bin/selfcheckout_software/BanknoteController.class b/bin/selfcheckout_software/BanknoteController.class
new file mode 100644
index 0000000..2379e18
Binary files /dev/null and b/bin/selfcheckout_software/BanknoteController.class differ
diff --git a/bin/selfcheckout_software/SCSLogic.class b/bin/selfcheckout_software/SCSLogic.class
new file mode 100644
index 0000000..ad40b28
Binary files /dev/null and b/bin/selfcheckout_software/SCSLogic.class differ
diff --git a/bin/selfcheckout_test/AbstractDeviceObserverStub.class b/bin/selfcheckout_test/AbstractDeviceObserverStub.class
new file mode 100644
index 0000000..35d86a6
Binary files /dev/null and b/bin/selfcheckout_test/AbstractDeviceObserverStub.class differ
diff --git a/bin/selfcheckout_test/ElectronicScaleObserverStub.class b/bin/selfcheckout_test/ElectronicScaleObserverStub.class
new file mode 100644
index 0000000..a5cd325
Binary files /dev/null and b/bin/selfcheckout_test/ElectronicScaleObserverStub.class differ
diff --git a/bin/selfcheckout_test/test_wish_to_checkout$1.class b/bin/selfcheckout_test/test_wish_to_checkout$1.class
new file mode 100644
index 0000000..92dde9c
Binary files /dev/null and b/bin/selfcheckout_test/test_wish_to_checkout$1.class differ
diff --git a/bin/selfcheckout_test/test_wish_to_checkout$2.class b/bin/selfcheckout_test/test_wish_to_checkout$2.class
new file mode 100644
index 0000000..ebf4290
Binary files /dev/null and b/bin/selfcheckout_test/test_wish_to_checkout$2.class differ
diff --git a/bin/selfcheckout_test/test_wish_to_checkout.class b/bin/selfcheckout_test/test_wish_to_checkout.class
new file mode 100644
index 0000000..5697495
Binary files /dev/null and b/bin/selfcheckout_test/test_wish_to_checkout.class differ
diff --git a/src/BanknoteController.java b/src/selfcheckout_software/BanknoteController.java
similarity index 98%
rename from src/BanknoteController.java
rename to src/selfcheckout_software/BanknoteController.java
index a663689..a3134c2 100644
--- a/src/BanknoteController.java
+++ b/src/selfcheckout_software/BanknoteController.java
@@ -1,3 +1,4 @@
+package selfcheckout_software;
 import java.math.BigDecimal;
 import java.util.Currency;
 
diff --git a/src/selfcheckout_software/SCSLogic.java b/src/selfcheckout_software/SCSLogic.java
new file mode 100644
index 0000000..d466e31
--- /dev/null
+++ b/src/selfcheckout_software/SCSLogic.java
@@ -0,0 +1,83 @@
+package selfcheckout_software;
+
+import org.lsmr.selfcheckout.devices.AbstractDevice;
+import org.lsmr.selfcheckout.devices.Acceptor;
+import org.lsmr.selfcheckout.devices.DisabledException;
+import org.lsmr.selfcheckout.devices.ElectronicScale;
+import org.lsmr.selfcheckout.devices.OverloadException;
+import org.lsmr.selfcheckout.devices.SimulationException;
+import org.lsmr.selfcheckout.devices.observers.AbstractDeviceObserver;
+
+public class SCSLogic extends AbstractDevice<AbstractDeviceObserver> implements Acceptor<AbstractDeviceObserver>{
+	
+	private ElectronicScale electronic;
+	
+	
+	
+	
+	public SCSLogic(ElectronicScale e) {
+		this.electronic = e;
+	}
+	
+	
+	
+	
+	public void wish_checkout(AbstractDeviceObserver payment_method) throws OverloadException, DisabledException  {
+		
+		try {
+			this.attach(payment_method);
+			while(true) {
+				if (!electronic.isDisabled()) {  // keep checking the weight of bagging area, check if the weight has changed
+					
+					this.accept(payment_method);
+					
+					if (this.isDisabled()) {
+						break;
+					}
+					else { //this should never been run
+						throw new SimulationException("can't receive payment method");
+					}
+					
+				}
+				else {
+					throw new SimulationException("the weight has changed");
+				}
+				
+			}
+			//....might need to call the matched payment method
+			
+		} catch (OverloadException e) {
+			throw e;
+		}catch (DisabledException e) {
+		    throw e;
+		}
+		
+		
+		
+		
+		
+	}
+
+
+
+
+
+
+
+
+
+
+	@Override
+	public void accept(AbstractDeviceObserver thing) throws OverloadException, DisabledException {
+			thing.enabled(this);
+	}
+
+
+
+	@Override
+	public boolean hasSpace() { //not used yet
+		// TODO Auto-generated method stub
+		return false;
+	}
+	
+}
diff --git a/src/selfcheckout_test/AbstractDeviceObserverStub.java b/src/selfcheckout_test/AbstractDeviceObserverStub.java
new file mode 100644
index 0000000..5d7fe00
--- /dev/null
+++ b/src/selfcheckout_test/AbstractDeviceObserverStub.java
@@ -0,0 +1,19 @@
+package selfcheckout_test;
+
+import org.lsmr.selfcheckout.devices.AbstractDevice;
+import org.lsmr.selfcheckout.devices.observers.AbstractDeviceObserver;
+
+public class AbstractDeviceObserverStub implements AbstractDeviceObserver {
+
+	@Override
+	public void enabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
+		device.disable();	
+	}
+
+	@Override
+	public void disabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
+		// TODO Auto-generated method stub
+		
+	}
+
+}
diff --git a/src/selfcheckout_test/ElectronicScaleObserverStub.java b/src/selfcheckout_test/ElectronicScaleObserverStub.java
new file mode 100644
index 0000000..4f713f4
--- /dev/null
+++ b/src/selfcheckout_test/ElectronicScaleObserverStub.java
@@ -0,0 +1,40 @@
+package selfcheckout_test;
+
+import org.lsmr.selfcheckout.devices.AbstractDevice;
+import org.lsmr.selfcheckout.devices.ElectronicScale;
+import org.lsmr.selfcheckout.devices.observers.AbstractDeviceObserver;
+import org.lsmr.selfcheckout.devices.observers.ElectronicScaleObserver;
+
+public class ElectronicScaleObserverStub implements ElectronicScaleObserver {
+
+	@Override
+	public void enabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
+		// TODO Auto-generated method stub
+		
+	}
+
+	@Override
+	public void disabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
+		// TODO Auto-generated method stub
+		
+	}
+
+	@Override
+	public void weightChanged(ElectronicScale scale, double weightInGrams) {
+		scale.disable();
+		
+	}
+
+	@Override
+	public void overload(ElectronicScale scale) {
+		// TODO Auto-generated method stub
+		
+	}
+
+	@Override
+	public void outOfOverload(ElectronicScale scale) {
+		// TODO Auto-generated method stub
+		
+	}
+
+}
diff --git a/src/selfcheckout_test/test_wish_to_checkout.java b/src/selfcheckout_test/test_wish_to_checkout.java
new file mode 100644
index 0000000..d05d71e
--- /dev/null
+++ b/src/selfcheckout_test/test_wish_to_checkout.java
@@ -0,0 +1,69 @@
+package selfcheckout_test;
+import selfcheckout_software.*;
+
+import static org.junit.Assert.*;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.lsmr.selfcheckout.Item;
+import org.lsmr.selfcheckout.devices.AbstractDevice;
+import org.lsmr.selfcheckout.devices.DisabledException;
+import org.lsmr.selfcheckout.devices.ElectronicScale;
+import org.lsmr.selfcheckout.devices.OverloadException;
+import org.lsmr.selfcheckout.devices.SimulationException;
+import org.lsmr.selfcheckout.devices.observers.AbstractDeviceObserver;
+
+import junit.extensions.TestSetup;
+import junit.framework.Assert;
+
+public class test_wish_to_checkout {
+
+	private SCSLogic test_object;
+	private AbstractDeviceObserverStub payment;
+	private ElectronicScaleObserverStub w_observer;
+	private ElectronicScale E;
+	
+	@Before
+	public void TestSetup() {
+		this.E = new ElectronicScale(100, 1);
+		this.test_object = new SCSLogic(E);
+		this.payment = new AbstractDeviceObserverStub();
+		this.w_observer = new ElectronicScaleObserverStub();
+		
+	}
+	
+	@Test(expected = SimulationException.class)
+	public void test_attachment() throws OverloadException, DisabledException {
+		test_object.wish_checkout(payment);
+		test_object.detach(payment);
+		test_object.detach(payment);
+	}
+	
+	@Test(expected = SimulationException.class)
+	public void test_weight_changed() throws OverloadException, DisabledException {
+		E.attach(w_observer);
+		Item test_item1 = new Item(20) {};
+		Item test_item2 = new Item(40) {};
+		E.add(test_item1);
+		E.enable();
+		
+		E.add(test_item2);
+		
+		test_object.wish_checkout(payment);
+		
+	}
+	
+	@Test
+	public void test_normal_wish() throws OverloadException, DisabledException {
+		test_object.endConfigurationPhase();
+		E.attach(w_observer);
+		E.endConfigurationPhase();
+		E.enable();
+		test_object.wish_checkout(payment);
+		assertTrue("this should be true",test_object.isDisabled());
+		
+		
+	}
+	
+
+}

commit 448b302fe0b3c936dcb47f65a65e89d02ed80bc3
Merge: ea7721e a7a89b3
Author: lexahoa <sparr@LAPTOP-V521ED67>
Date:   Fri Mar 18 22:46:10 2022 -0400

    Merge branch 'main' of https://github.com/Manbir1/SENG300Iteration1

commit ea7721e16893fa03d99226f0305559a9a21e1d2d
Author: lexahoa <sparr@LAPTOP-V521ED67>
Date:   Fri Mar 18 22:45:38 2022 -0400

    delete

diff --git a/.classpath b/.classpath
deleted file mode 100644
index 46a3f0e..0000000
--- a/.classpath
+++ /dev/null
@@ -1,12 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<classpath>
-	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/jre">
-		<attributes>
-			<attribute name="module" value="true"/>
-		</attributes>
-	</classpathentry>
-	<classpathentry kind="con" path="org.eclipse.jdt.junit.JUNIT_CONTAINER/4"/>
-	<classpathentry kind="src" path="src"/>
-	<classpathentry kind="src" path="SCS - Hardware - v1.0/src"/>
-	<classpathentry kind="output" path="bin"/>
-</classpath>
diff --git a/.project b/.project
deleted file mode 100644
index 711bba8..0000000
--- a/.project
+++ /dev/null
@@ -1,17 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<projectDescription>
-	<name>SCS - Software</name>
-	<comment></comment>
-	<projects>
-	</projects>
-	<buildSpec>
-		<buildCommand>
-			<name>org.eclipse.jdt.core.javabuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-	</buildSpec>
-	<natures>
-		<nature>org.eclipse.jdt.core.javanature</nature>
-	</natures>
-</projectDescription>
diff --git a/.settings/org.eclipse.jdt.core.prefs b/.settings/org.eclipse.jdt.core.prefs
deleted file mode 100644
index 59fe89d..0000000
--- a/.settings/org.eclipse.jdt.core.prefs
+++ /dev/null
@@ -1,15 +0,0 @@
-eclipse.preferences.version=1
-org.eclipse.jdt.core.compiler.codegen.inlineJsrBytecode=enabled
-org.eclipse.jdt.core.compiler.codegen.methodParameters=do not generate
-org.eclipse.jdt.core.compiler.codegen.targetPlatform=17
-org.eclipse.jdt.core.compiler.codegen.unusedLocal=preserve
-org.eclipse.jdt.core.compiler.compliance=17
-org.eclipse.jdt.core.compiler.debug.lineNumber=generate
-org.eclipse.jdt.core.compiler.debug.localVariable=generate
-org.eclipse.jdt.core.compiler.debug.sourceFile=generate
-org.eclipse.jdt.core.compiler.problem.assertIdentifier=error
-org.eclipse.jdt.core.compiler.problem.enablePreviewFeatures=disabled
-org.eclipse.jdt.core.compiler.problem.enumIdentifier=error
-org.eclipse.jdt.core.compiler.problem.reportPreviewFeatures=warning
-org.eclipse.jdt.core.compiler.release=disabled
-org.eclipse.jdt.core.compiler.source=17
diff --git a/README.txt b/README.txt
deleted file mode 100644
index a0c9153..0000000
--- a/README.txt
+++ /dev/null
@@ -1,28 +0,0 @@
-Requirements:
-1.Customer scans an item -(James, Bassel)
-  -Takes in barcode of item
-  -Gathers items information (Price,weight,etc)
-  -Adds cost of item to currect cost
-2.Customer places item in bagging area (Kevin)
-  -Checks for weight of item
-  -Get current weight for electronic scale
-  -Expect new weight on the electronic scale to be the addition of the weight of newly scanned item
-3.Customer wishes to checkout (zhongmin)
-  -keep looping and checking the weight
-  -check how the customer willing to pay (e.g. button pressed)
-4.Customer pays with a coin (Justin)
-  -Coin slot observer to check if slot is open
-  -Observe what coin inserted
-  -Add ammount of money based on what coin was inserted
-  -Check if cost is reached everytime coin is inserted
-5.Customer pays with a banknote - (Manbir)
-  -Banknote slot observer to check if slot is open
-  -Observe what banknote inserted
-  -Add ammount of money based on what banknote was inserted
-  -Check if cost is reached everytime banknote is inserted
-
-TestCases:
--Each person who works on the software control also works on the test cases.
--Check your partner's test cases (2 and 4 check each other's test case, and 3 and 5 check each other's test cases)
--If you think your partner is missing a test case for their task, you can message them to tell them what they should add (you can also add it yourself but that might get messy so it's best to check)
--1 will be 2 people, who will both work on the test cases and version control.
diff --git a/SCS - Hardware - v1.0/.classpath b/SCS - Hardware - v1.0/.classpath
deleted file mode 100644
index 6a189c4..0000000
--- a/SCS - Hardware - v1.0/.classpath	
+++ /dev/null
@@ -1,7 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<classpath>
-	<classpathentry kind="src" path="src"/>
-	<classpathentry kind="con" path="org.eclipse.jdt.junit.JUNIT_CONTAINER/4"/>
-	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER"/>
-	<classpathentry kind="output" path="bin"/>
-</classpath>
diff --git a/SCS - Hardware - v1.0/.project b/SCS - Hardware - v1.0/.project
deleted file mode 100644
index 57573c6..0000000
--- a/SCS - Hardware - v1.0/.project	
+++ /dev/null
@@ -1,17 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<projectDescription>
-	<name>SCS - Hardware - v1.0</name>
-	<comment></comment>
-	<projects>
-	</projects>
-	<buildSpec>
-		<buildCommand>
-			<name>org.eclipse.jdt.core.javabuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-	</buildSpec>
-	<natures>
-		<nature>org.eclipse.jdt.core.javanature</nature>
-	</natures>
-</projectDescription>
diff --git a/SCS - Hardware - v1.0/.settings/org.eclipse.jdt.core.prefs b/SCS - Hardware - v1.0/.settings/org.eclipse.jdt.core.prefs
deleted file mode 100644
index bb35fa0..0000000
--- a/SCS - Hardware - v1.0/.settings/org.eclipse.jdt.core.prefs	
+++ /dev/null
@@ -1,11 +0,0 @@
-eclipse.preferences.version=1
-org.eclipse.jdt.core.compiler.codegen.inlineJsrBytecode=enabled
-org.eclipse.jdt.core.compiler.codegen.targetPlatform=1.8
-org.eclipse.jdt.core.compiler.codegen.unusedLocal=preserve
-org.eclipse.jdt.core.compiler.compliance=1.8
-org.eclipse.jdt.core.compiler.debug.lineNumber=generate
-org.eclipse.jdt.core.compiler.debug.localVariable=generate
-org.eclipse.jdt.core.compiler.debug.sourceFile=generate
-org.eclipse.jdt.core.compiler.problem.assertIdentifier=error
-org.eclipse.jdt.core.compiler.problem.enumIdentifier=error
-org.eclipse.jdt.core.compiler.source=1.8
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Banknote.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Banknote.class
deleted file mode 100644
index fbc21cf..0000000
Binary files a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Banknote.class and /dev/null differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Barcode.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Barcode.class
deleted file mode 100644
index 5cea197..0000000
Binary files a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Barcode.class and /dev/null differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/BarcodedItem.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/BarcodedItem.class
deleted file mode 100644
index 2d68447..0000000
Binary files a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/BarcodedItem.class and /dev/null differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/BlockedCardException.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/BlockedCardException.class
deleted file mode 100644
index 536dd3d..0000000
Binary files a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/BlockedCardException.class and /dev/null differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Card$CardData.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Card$CardData.class
deleted file mode 100644
index 795e5b4..0000000
Binary files a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Card$CardData.class and /dev/null differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Card$CardInsertData.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Card$CardInsertData.class
deleted file mode 100644
index a2d7141..0000000
Binary files a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Card$CardInsertData.class and /dev/null differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Card$CardSwipeData.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Card$CardSwipeData.class
deleted file mode 100644
index a72d8a2..0000000
Binary files a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Card$CardSwipeData.class and /dev/null differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Card$CardTapData.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Card$CardTapData.class
deleted file mode 100644
index 8efccff..0000000
Binary files a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Card$CardTapData.class and /dev/null differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Card.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Card.class
deleted file mode 100644
index 262b944..0000000
Binary files a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Card.class and /dev/null differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/ChipFailureException.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/ChipFailureException.class
deleted file mode 100644
index fa389c2..0000000
Binary files a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/ChipFailureException.class and /dev/null differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Coin.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Coin.class
deleted file mode 100644
index 67690f1..0000000
Binary files a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Coin.class and /dev/null differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/IllegalDigitException.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/IllegalDigitException.class
deleted file mode 100644
index be8be69..0000000
Binary files a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/IllegalDigitException.class and /dev/null differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/InvalidPINException.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/InvalidPINException.class
deleted file mode 100644
index c08cda6..0000000
Binary files a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/InvalidPINException.class and /dev/null differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Item.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Item.class
deleted file mode 100644
index 69e38c1..0000000
Binary files a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Item.class and /dev/null differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/MagneticStripeFailureException.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/MagneticStripeFailureException.class
deleted file mode 100644
index 0f8b1e6..0000000
Binary files a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/MagneticStripeFailureException.class and /dev/null differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Numeral.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Numeral.class
deleted file mode 100644
index ac8cc6e..0000000
Binary files a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Numeral.class and /dev/null differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/PLUCodedItem.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/PLUCodedItem.class
deleted file mode 100644
index 941940c..0000000
Binary files a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/PLUCodedItem.class and /dev/null differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/PriceLookupCode.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/PriceLookupCode.class
deleted file mode 100644
index 0884227..0000000
Binary files a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/PriceLookupCode.class and /dev/null differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/TapFailureException.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/TapFailureException.class
deleted file mode 100644
index 8d9b145..0000000
Binary files a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/TapFailureException.class and /dev/null differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/AbstractDevice$Phase.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/AbstractDevice$Phase.class
deleted file mode 100644
index 1dae3ed..0000000
Binary files a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/AbstractDevice$Phase.class and /dev/null differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/AbstractDevice.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/AbstractDevice.class
deleted file mode 100644
index aff6c5e..0000000
Binary files a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/AbstractDevice.class and /dev/null differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/Acceptor.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/Acceptor.class
deleted file mode 100644
index 9043506..0000000
Binary files a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/Acceptor.class and /dev/null differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/BanknoteDispenser.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/BanknoteDispenser.class
deleted file mode 100644
index a829b5d..0000000
Binary files a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/BanknoteDispenser.class and /dev/null differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/BanknoteSlot.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/BanknoteSlot.class
deleted file mode 100644
index f18b4a4..0000000
Binary files a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/BanknoteSlot.class and /dev/null differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/BanknoteStorageUnit.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/BanknoteStorageUnit.class
deleted file mode 100644
index 21d4eff..0000000
Binary files a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/BanknoteStorageUnit.class and /dev/null differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/BanknoteValidator.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/BanknoteValidator.class
deleted file mode 100644
index a42c54f..0000000
Binary files a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/BanknoteValidator.class and /dev/null differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/BarcodeScanner.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/BarcodeScanner.class
deleted file mode 100644
index 093246f..0000000
Binary files a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/BarcodeScanner.class and /dev/null differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/BidirectionalChannel.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/BidirectionalChannel.class
deleted file mode 100644
index 8ae0603..0000000
Binary files a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/BidirectionalChannel.class and /dev/null differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/CardReader.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/CardReader.class
deleted file mode 100644
index 1a090b0..0000000
Binary files a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/CardReader.class and /dev/null differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/CoinDispenser.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/CoinDispenser.class
deleted file mode 100644
index d069691..0000000
Binary files a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/CoinDispenser.class and /dev/null differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/CoinSlot.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/CoinSlot.class
deleted file mode 100644
index db8f809..0000000
Binary files a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/CoinSlot.class and /dev/null differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/CoinStorageUnit.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/CoinStorageUnit.class
deleted file mode 100644
index db1e2c4..0000000
Binary files a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/CoinStorageUnit.class and /dev/null differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/CoinTray.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/CoinTray.class
deleted file mode 100644
index 6f49c78..0000000
Binary files a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/CoinTray.class and /dev/null differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/CoinValidator.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/CoinValidator.class
deleted file mode 100644
index de514e7..0000000
Binary files a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/CoinValidator.class and /dev/null differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/DisabledException.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/DisabledException.class
deleted file mode 100644
index 5c66261..0000000
Binary files a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/DisabledException.class and /dev/null differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/ElectronicScale.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/ElectronicScale.class
deleted file mode 100644
index a9314d0..0000000
Binary files a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/ElectronicScale.class and /dev/null differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/Emitter.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/Emitter.class
deleted file mode 100644
index b23e858..0000000
Binary files a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/Emitter.class and /dev/null differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/EmptyException.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/EmptyException.class
deleted file mode 100644
index dc98a0f..0000000
Binary files a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/EmptyException.class and /dev/null differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/FlowThroughEmitter.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/FlowThroughEmitter.class
deleted file mode 100644
index 7db53cc..0000000
Binary files a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/FlowThroughEmitter.class and /dev/null differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/FromStorageEmitter.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/FromStorageEmitter.class
deleted file mode 100644
index bc15cfc..0000000
Binary files a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/FromStorageEmitter.class and /dev/null differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/OverloadException.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/OverloadException.class
deleted file mode 100644
index ce0e2cd..0000000
Binary files a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/OverloadException.class and /dev/null differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/ReceiptPrinter.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/ReceiptPrinter.class
deleted file mode 100644
index 4db506b..0000000
Binary files a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/ReceiptPrinter.class and /dev/null differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/SelfCheckoutStation.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/SelfCheckoutStation.class
deleted file mode 100644
index 4c8882f..0000000
Binary files a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/SelfCheckoutStation.class and /dev/null differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/SimulationException.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/SimulationException.class
deleted file mode 100644
index d616ae5..0000000
Binary files a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/SimulationException.class and /dev/null differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/UnidirectionalChannel.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/UnidirectionalChannel.class
deleted file mode 100644
index 964485e..0000000
Binary files a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/UnidirectionalChannel.class and /dev/null differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/AbstractDeviceObserver.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/AbstractDeviceObserver.class
deleted file mode 100644
index 3b3f3af..0000000
Binary files a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/AbstractDeviceObserver.class and /dev/null differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/BanknoteDispenserObserver.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/BanknoteDispenserObserver.class
deleted file mode 100644
index ef277e1..0000000
Binary files a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/BanknoteDispenserObserver.class and /dev/null differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/BanknoteSlotObserver.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/BanknoteSlotObserver.class
deleted file mode 100644
index 8fa6c54..0000000
Binary files a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/BanknoteSlotObserver.class and /dev/null differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/BanknoteStorageUnitObserver.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/BanknoteStorageUnitObserver.class
deleted file mode 100644
index dbec2ad..0000000
Binary files a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/BanknoteStorageUnitObserver.class and /dev/null differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/BanknoteValidatorObserver.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/BanknoteValidatorObserver.class
deleted file mode 100644
index b779d7e..0000000
Binary files a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/BanknoteValidatorObserver.class and /dev/null differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/BarcodeScannerObserver.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/BarcodeScannerObserver.class
deleted file mode 100644
index 3ef8e5f..0000000
Binary files a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/BarcodeScannerObserver.class and /dev/null differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/CardReaderObserver.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/CardReaderObserver.class
deleted file mode 100644
index 21606de..0000000
Binary files a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/CardReaderObserver.class and /dev/null differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/CoinDispenserObserver.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/CoinDispenserObserver.class
deleted file mode 100644
index 7910341..0000000
Binary files a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/CoinDispenserObserver.class and /dev/null differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/CoinSlotObserver.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/CoinSlotObserver.class
deleted file mode 100644
index bd71242..0000000
Binary files a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/CoinSlotObserver.class and /dev/null differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/CoinStorageUnitObserver.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/CoinStorageUnitObserver.class
deleted file mode 100644
index b922285..0000000
Binary files a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/CoinStorageUnitObserver.class and /dev/null differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/CoinTrayObserver.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/CoinTrayObserver.class
deleted file mode 100644
index 1391af5..0000000
Binary files a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/CoinTrayObserver.class and /dev/null differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/CoinValidatorObserver.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/CoinValidatorObserver.class
deleted file mode 100644
index b11003b..0000000
Binary files a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/CoinValidatorObserver.class and /dev/null differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/ElectronicScaleObserver.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/ElectronicScaleObserver.class
deleted file mode 100644
index 6bf0d70..0000000
Binary files a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/ElectronicScaleObserver.class and /dev/null differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/ReceiptPrinterObserver.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/ReceiptPrinterObserver.class
deleted file mode 100644
index 9cd53cf..0000000
Binary files a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/ReceiptPrinterObserver.class and /dev/null differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/TouchScreenObserver.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/TouchScreenObserver.class
deleted file mode 100644
index ef726bb..0000000
Binary files a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/TouchScreenObserver.class and /dev/null differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/products/BarcodedProduct.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/products/BarcodedProduct.class
deleted file mode 100644
index aba29ee..0000000
Binary files a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/products/BarcodedProduct.class and /dev/null differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/products/PLUCodedProduct.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/products/PLUCodedProduct.class
deleted file mode 100644
index 80746e5..0000000
Binary files a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/products/PLUCodedProduct.class and /dev/null differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/products/Product.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/products/Product.class
deleted file mode 100644
index b3888c1..0000000
Binary files a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/products/Product.class and /dev/null differ
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/Banknote.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/Banknote.java
deleted file mode 100644
index ad0981e..0000000
--- a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/Banknote.java	
+++ /dev/null
@@ -1,66 +0,0 @@
-package org.lsmr.selfcheckout;
-
-import java.math.BigDecimal;
-import java.util.Currency;
-
-import org.lsmr.selfcheckout.devices.SimulationException;
-
-/**
- * Instances of this class represent individual banknotes. The value of a
- * banknote is assumed to always be a positive integer multiple of the base
- * currency.
- */
-public class Banknote {
-	private int value;
-	private Currency currency;
-
-	/**
-	 * Constructs a banknote.
-	 * @param currency
-	 *            The currency represented by this banknote.
-	 * @param value
-	 *            The value of the banknote, in multiples of the unit of currency.
-	 * 
-	 * @throws SimulationException
-	 *             If the value is &le;0.
-	 * @throws SimulationException
-	 *             If currency is null.
-	 */
-	public Banknote(Currency currency, int value) {
-		if(currency == null)
-			throw new SimulationException(new NullPointerException("currency is null"));
-
-		if(value <= 0)
-			throw new SimulationException(
-				new IllegalArgumentException("The value must be greater than 0: the argument passed was " + value));
-
-		this.value = value;
-		this.currency = currency;
-	}
-
-	/**
-	 * Accessor for the value.
-	 * 
-	 * @return The value of the banknote. Should always be &gt;0.
-	 */
-	public int getValue() {
-		return value;
-	}
-
-	/**
-	 * Accessor for the currency.
-	 * 
-	 * @return The currency for this banknote. Note that this is not the same as the
-	 *             "denomination" (e.g., a Canadian $10 bill is worth 10 Canadian
-	 *             dollars, so a Canadian $10 bill would have currency "Canadian
-	 *             dollars").
-	 */
-	public Currency getCurrency() {
-		return currency;
-	}
-
-	@Override
-	public String toString() {
-		return Integer.toString(value) + " " + currency;
-	}
-}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/Barcode.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/Barcode.java
deleted file mode 100644
index b989b61..0000000
--- a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/Barcode.java	
+++ /dev/null
@@ -1,109 +0,0 @@
-package org.lsmr.selfcheckout;
-
-import java.util.ArrayList;
-import java.util.Arrays;
-
-import org.lsmr.selfcheckout.devices.SimulationException;
-
-/**
- * Represents a barcode value (not the graphic barcode itself). Real-world
- * barcodes are a sequence of digits, so that is what is modelled here.
- */
-public class Barcode {
-	private Numeral[] digits;
-
-	/**
-	 * Constructs a barcode from an array of numerals.
-	 * 
-	 * @param code
-	 *            An array of numerals.
-	 * @throws SimulationException
-	 *             If any character in the input is not a digit between 0 and 9,
-	 *             inclusive.
-	 * @throws SimulationException
-	 *             If the code is null
-	 * @throws SimulationException
-	 *             If the code's length is &lt;1 or &gt;48.
-	 */
-	public Barcode(Numeral[] code) {
-		if(code == null)
-			throw new SimulationException(new NullPointerException("code is null"));
-
-		digits = new Numeral[code.length];
-
-		if(code.length < 1)
-			throw new SimulationException(
-				new IllegalArgumentException("A barcode cannot contain less than one digit."));
-
-		if(code.length > 48)
-			throw new SimulationException(
-				new IllegalArgumentException("A barcode cannot contain more than forty-eight digits."));
-
-		for(int i = 0; i < code.length; i++) {
-			if(code[i] == null)
-				throw new SimulationException(new NullPointerException("code[" + i + "] is null"));
-
-			digits[i] = code[i];
-		}
-	}
-
-	/**
-	 * Gets the count of digits in this code.
-	 * 
-	 * @return The count of digits.
-	 */
-	public int digitCount() {
-		return digits.length;
-	}
-
-	/**
-	 * Gets the digit at the indicated index within the code.
-	 * 
-	 * @param index
-	 *            The index of the digit, &ge;0 and &lt;count.
-	 * @return The digit at the indicated index.
-	 * @throws SimulationException
-	 *             If the index is outside the legal range.
-	 */
-	public Numeral getDigitAt(int index) {
-		try {
-			return digits[index];
-		}
-		catch(IndexOutOfBoundsException e) {
-			throw new SimulationException(e);
-		}
-	}
-
-	@Override
-	public String toString() {
-		char[] characters = new char[digits.length];
-
-		for(int i = 0; i < digits.length; i++)
-			characters[i] = Character.forDigit(digits[i].getValue(), 10);
-
-		return new String(characters);
-	}
-
-	@Override
-	public boolean equals(Object object) {
-		if(object instanceof Barcode) {
-			Barcode other = (Barcode)object;
-
-			if(other.digits.length != digits.length)
-				return false;
-
-			for(int i = 0; i < digits.length; i++)
-				if(!digits[i].equals(other.digits[i]))
-					return false;
-
-			return true;
-		}
-
-		return false;
-	}
-
-	@Override
-	public int hashCode() {
-		return Arrays.hashCode(digits);
-	}
-}
\ No newline at end of file
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/BarcodedItem.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/BarcodedItem.java
deleted file mode 100644
index cc57193..0000000
--- a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/BarcodedItem.java	
+++ /dev/null
@@ -1,41 +0,0 @@
-package org.lsmr.selfcheckout;
-
-import org.lsmr.selfcheckout.devices.SimulationException;
-import org.lsmr.selfcheckout.products.Product;
-
-/**
- * Represents items for sale, each with a particular barcode and weight.
- */
-public class BarcodedItem extends Item {
-	private Barcode barcode;
-
-	/**
-	 * Basic constructor.
-	 * 
-	 * @param kind
-	 *            The kind of product that this item is.
-	 * @param weightInGrams
-	 *            The real weight of the item.
-	 * @throws SimulationException
-	 *             If the barcode is null.
-	 * @throws SimulationException
-	 *             If the weight is &le;0.
-	 */
-	public BarcodedItem(Barcode barcode, double weightInGrams) {
-		super(weightInGrams);
-
-		if(barcode == null)
-			throw new SimulationException(new NullPointerException("barcode is null"));
-
-		this.barcode = barcode;
-	}
-
-	/**
-	 * Gets the barcode of this item.
-	 * 
-	 * @return The barcode.
-	 */
-	public Barcode getBarcode() {
-		return barcode;
-	}
-}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/BlockedCardException.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/BlockedCardException.java
deleted file mode 100644
index 63b13ba..0000000
--- a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/BlockedCardException.java	
+++ /dev/null
@@ -1,15 +0,0 @@
-package org.lsmr.selfcheckout;
-
-import java.io.IOException;
-
-/**
- * Represents exceptions arising from a blocked card.
- */
-public class BlockedCardException extends IOException {
-	private static final long serialVersionUID = 8824192400137175094L;
-
-	/**
-	 * Create an exception.
-	 */
-	public BlockedCardException() {}
-}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/Card.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/Card.java
deleted file mode 100644
index e3f6fb9..0000000
--- a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/Card.java	
+++ /dev/null
@@ -1,289 +0,0 @@
-package org.lsmr.selfcheckout;
-
-import java.io.IOException;
-import java.util.Random;
-import java.util.concurrent.ThreadLocalRandom;
-
-import org.lsmr.selfcheckout.devices.SimulationException;
-
-/**
- * Represents plastic cards (e.g., credit cards, debit cards, membership cards).
- */
-public final class Card {
-	private final String type;
-	private final String number;
-	private final String cardholder;
-	private final String cvv;
-	private final String pin;
-	public final boolean isTapEnabled;
-	public final boolean hasChip;
-	private int failedTrials = 0;
-	private boolean isBlocked;
-
-	/**
-	 * Create a card instance.
-	 * 
-	 * @param type
-	 *            The type of the card.
-	 * @param number
-	 *            The number of the card. This has to be a string of digits.
-	 * @param cardholder
-	 *            The name of the cardholder.
-	 * @param cvv
-	 *            The card verification value (CVV), a 3- or 4-digit value often on
-	 *            the back of the card. This can be null.
-	 * @param pin
-	 *            The personal identification number (PIN) for access to the card.
-	 *            This can be null if the card has no chip.
-	 * @param isTapEnabled
-	 *            Whether this card is capable of being tapped.
-	 * @param hasChip
-	 *            Whether this card has a chip.
-	 * @throws SimulationException
-	 *             If type, number, or cardholder is null.
-	 * @throws SimulationException
-	 *             If hasChip is true but pin is null.
-	 */
-	public Card(String type, String number, String cardholder, String cvv, String pin, boolean isTapEnabled,
-		boolean hasChip) {
-		if(type == null)
-			throw new SimulationException(new NullPointerException("type is null"));
-
-		if(number == null)
-			throw new SimulationException(new NullPointerException("number is null"));
-
-		if(cardholder == null)
-			throw new SimulationException(new NullPointerException("cardholder is null"));
-
-		if(hasChip && pin == null)
-			throw new SimulationException(new NullPointerException("has chip but pin is null"));
-
-		this.type = type;
-		this.number = number;
-		this.cardholder = cardholder;
-		this.cvv = cvv;
-		this.pin = pin;
-		this.isTapEnabled = isTapEnabled;
-		this.hasChip = hasChip;
-	}
-
-	private static final Random random = new Random(0);
-	private static final double PROBABILITY_OF_MAGNETIC_STRIPE_FAILURE = 0.01;
-	private static final double PROBABILITY_OF_TAP_FAILURE = 0.005;
-	private static final double PROBABILITY_OF_INSERT_FAILURE = 0.001;
-	private static final double PROBABILITY_OF_MAGNETIC_STRIPE_CORRUPTION = 0.001;
-	private static final double PROBABILITY_OF_CHIP_CORRUPTION = 0.00001;
-
-	/**
-	 * Simulates the action of swiping the card.
-	 * 
-	 * @return The card data.
-	 * @throws IOException
-	 *             If anything went wrong with the data transfer.
-	 */
-	public final CardSwipeData swipe() throws IOException {
-		if(isBlocked)
-			throw new BlockedCardException();
-
-		if(random.nextDouble() <= PROBABILITY_OF_MAGNETIC_STRIPE_FAILURE)
-			throw new MagneticStripeFailureException();
-
-		return new CardSwipeData();
-	}
-
-	/**
-	 * Simulates the action of tapping the card.
-	 * 
-	 * @return The card data.
-	 * @throws IOException
-	 *             If anything went wrong with the data transfer.
-	 */
-	public final CardTapData tap() throws IOException {
-		if(isBlocked)
-			throw new BlockedCardException();
-
-		if(isTapEnabled) {
-			if(random.nextDouble() <= PROBABILITY_OF_TAP_FAILURE)
-				throw new TapFailureException();
-
-			return new CardTapData();
-		}
-
-		return null;
-	}
-
-	/**
-	 * Simulates the action of inserting the card.
-	 * 
-	 * @return The card data.
-	 * @throws IOException
-	 *             If anything went wrong with the data transfer.
-	 */
-	public final CardInsertData insert(String pin) throws IOException {
-		if(isBlocked)
-			throw new BlockedCardException();
-
-		if(hasChip) {
-			if(random.nextDouble() <= PROBABILITY_OF_INSERT_FAILURE)
-				throw new ChipFailureException();
-
-			return new CardInsertData(pin);
-		}
-
-		return null;
-	}
-
-	private String randomize(String original, double probability) {
-		if(random.nextDouble() <= probability) {
-			int length = original.length();
-			int index = random.nextInt(length);
-			String first;
-
-			if(index == 0)
-				first = "";
-			else
-				first = original.substring(0, index);
-
-			char second = original.charAt(index);
-			second++;
-
-			String third;
-
-			if(index == length - 1)
-				third = "";
-			else
-				third = original.substring(index + 1, length);
-
-			return first + second + third;
-		}
-
-		return original;
-	}
-
-	/**
-	 * The abstract base type of card data.
-	 */
-	public interface CardData {
-		/**
-		 * Gets the type of the card.
-		 * 
-		 * @return The type of the card.
-		 */
-		public String getType();
-
-		/**
-		 * Gets the number of the card.
-		 * 
-		 * @return The number of the card.
-		 */
-		public String getNumber();
-
-		/**
-		 * Gets the cardholder's name.
-		 * 
-		 * @return The cardholder's name.
-		 */
-		public String getCardholder();
-
-		/**
-		 * Gets the card verification value (CVV) of the card.
-		 * 
-		 * @return The CVV of the card.
-		 * @throws UnsupportedOperationException
-		 *             If this operation is unsupported by this object.
-		 */
-		public String getCVV();
-	}
-
-	/**
-	 * The data from swiping a card.
-	 */
-	public class CardSwipeData implements CardData {
-		@Override
-		public String getType() {
-			return randomize(type, PROBABILITY_OF_MAGNETIC_STRIPE_CORRUPTION);
-		}
-
-		@Override
-		public String getNumber() {
-			return randomize(number, PROBABILITY_OF_MAGNETIC_STRIPE_CORRUPTION);
-		}
-
-		@Override
-		public String getCardholder() {
-			return randomize(cardholder, PROBABILITY_OF_MAGNETIC_STRIPE_CORRUPTION);
-		}
-
-		@Override
-		public String getCVV() {
-			throw new UnsupportedOperationException();
-		}
-	}
-
-	/**
-	 * The data from tapping a card.
-	 */
-	public final class CardTapData implements CardData {
-		@Override
-		public String getType() {
-			return randomize(type, PROBABILITY_OF_CHIP_CORRUPTION);
-		}
-
-		@Override
-		public String getNumber() {
-			return randomize(number, PROBABILITY_OF_CHIP_CORRUPTION);
-		}
-
-		@Override
-		public String getCardholder() {
-			return randomize(cardholder, PROBABILITY_OF_CHIP_CORRUPTION);
-		}
-
-		@Override
-		public String getCVV() {
-			return randomize(cvv, PROBABILITY_OF_CHIP_CORRUPTION);
-		}
-	}
-
-	/**
-	 * The data from inserting a card.
-	 */
-	public final class CardInsertData implements CardData {
-		CardInsertData(String pin) throws InvalidPINException {
-			if(!testPIN(pin))
-				throw new InvalidPINException();
-		}
-
-		@Override
-		public String getType() {
-			return randomize(type, PROBABILITY_OF_CHIP_CORRUPTION);
-		}
-
-		@Override
-		public String getNumber() {
-			return randomize(number, PROBABILITY_OF_CHIP_CORRUPTION);
-		}
-
-		@Override
-		public String getCardholder() {
-			return randomize(cardholder, PROBABILITY_OF_CHIP_CORRUPTION);
-		}
-
-		@Override
-		public String getCVV() {
-			return randomize(cvv, PROBABILITY_OF_CHIP_CORRUPTION);
-		}
-
-		private boolean testPIN(String pinToTest) {
-			if(pinToTest == pin) {
-				failedTrials = 0;
-				return true;
-			}
-
-			if(++failedTrials >= 3)
-				isBlocked = true;
-
-			return false;
-		}
-	}
-}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/ChipFailureException.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/ChipFailureException.java
deleted file mode 100644
index 971cf50..0000000
--- a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/ChipFailureException.java	
+++ /dev/null
@@ -1,15 +0,0 @@
-package org.lsmr.selfcheckout;
-
-import java.io.IOException;
-
-/**
- * Represents exceptions arising from failures of the chip.
- */
-public class ChipFailureException extends IOException {
-	private static final long serialVersionUID = 3518203688837080092L;
-
-	/**
-	 * Create an exception.
-	 */
-	public ChipFailureException() {}
-}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/Coin.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/Coin.java
deleted file mode 100644
index 5681c26..0000000
--- a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/Coin.java	
+++ /dev/null
@@ -1,98 +0,0 @@
-package org.lsmr.selfcheckout;
-
-import java.math.BigDecimal;
-import java.util.Currency;
-
-import org.lsmr.selfcheckout.devices.SimulationException;
-
-/**
- * Instances of this class represent individual coins.
- */
-public class Coin {
-	private BigDecimal value;
-	private Currency currency;
-
-	/**
-	 * Rather than specifying a currency for every coin, a default currency can be
-	 * specified which will be used when the currency is not specified.
-	 */
-	public static Currency DEFAULT_CURRENCY;
-
-	/**
-	 * Constructs a coin, using the default currency.
-	 * 
-	 * @param value
-	 *            The value of the coin, in multiples of the unit of currency.
-	 * @throws SimulationException
-	 *             If the value is &le;0.
-	 * @throws SimulationException
-	 *             If the argument is null.
-	 */
-	public Coin(BigDecimal value) {
-		if(value == null)
-			throw new SimulationException(new NullPointerException("value is null"));
-
-		if(DEFAULT_CURRENCY == null)
-			throw new SimulationException(new NullPointerException("Default currency is null"));
-
-		if(value.compareTo(BigDecimal.ZERO) <= 0)
-			throw new SimulationException(
-				new IllegalArgumentException("The value must be greater than 0: the argument passed was " + value));
-
-		this.value = value;
-		this.currency = DEFAULT_CURRENCY;
-	}
-		
-	/**
-	 * Constructs a coin.
-	 * 
-	 * @param currency
-	 *            The currency represented by this coin.
-	 * @param value
-	 *            The value of the coin, in multiples of the unit of currency.
-	 * @throws SimulationException
-	 *             If the value is &le;0.
-	 * @throws SimulationException
-	 *             If either argument is null.
-	 */
-	public Coin(Currency currency, BigDecimal value) {
-		if(value == null)
-			throw new SimulationException(new NullPointerException("value is null"));
-
-		if(currency == null)
-			throw new SimulationException(new NullPointerException("currency is null"));
-
-		if(value.compareTo(BigDecimal.ZERO) <= 0)
-			throw new SimulationException(
-				new IllegalArgumentException("The value must be greater than 0: the argument passed was " + value));
-
-		this.value = value;
-		this.currency = currency;
-	}
-
-	/**
-	 * Accessor for the value.
-	 * 
-	 * @return The value of the coin. Should always be greater than 0.
-	 */
-	public BigDecimal getValue() {
-		return value;
-	}
-
-	/**
-	 * Accessor for the currency.
-	 * 
-	 * @return The currency for this coin. Note that this is not the same as the
-	 *             "denomination" (e.g., a Canadian dime is worth 0.1 Canadian
-	 *             dollars, so a Canadian dime would have currency "Canadian
-	 *             dollars").
-	 */
-	public Currency getCurrency() {
-		return currency;
-	}
-
-	@Override
-	public String toString() {
-		return value.toString() + " " + currency;
-	}
-}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/IllegalDigitException.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/IllegalDigitException.java
deleted file mode 100644
index d93a133..0000000
--- a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/IllegalDigitException.java	
+++ /dev/null
@@ -1,19 +0,0 @@
-package org.lsmr.selfcheckout;
-
-/**
- * Signals that an illegal character has been used where a digit (0-9) was
- * expected.
- */
-public class IllegalDigitException extends IllegalArgumentException {
-	private static final long serialVersionUID = 3352152121776245096L;
-
-	/**
-	 * Constructs an exception with an error message.
-	 * 
-	 * @param message
-	 *            The error message to display.
-	 */
-	public IllegalDigitException(String message) {
-		super(message);
-	}
-}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/InvalidPINException.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/InvalidPINException.java
deleted file mode 100644
index 2d0b327..0000000
--- a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/InvalidPINException.java	
+++ /dev/null
@@ -1,15 +0,0 @@
-package org.lsmr.selfcheckout;
-
-import java.io.IOException;
-
-/**
- * Represents exceptions arising from entry of an invalid PIN.
- */
-public class InvalidPINException extends IOException {
-	private static final long serialVersionUID = 5461848339919309513L;
-
-	/**
-	 * Create an exception.
-	 */
-	public InvalidPINException() {}
-}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/Item.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/Item.java
deleted file mode 100644
index 3279604..0000000
--- a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/Item.java	
+++ /dev/null
@@ -1,35 +0,0 @@
-package org.lsmr.selfcheckout;
-
-import org.lsmr.selfcheckout.devices.SimulationException;
-import org.lsmr.selfcheckout.products.Product;
-
-/**
- * Abstract base class of items for sale, each with a particular weight.
- */
-public abstract class Item {
-	private double weightInGrams;
-
-	/**
-	 * Constructs an item with the indicated weight.
-	 * 
-	 * @param weightInGrams
-	 *            The weight of the item.
-	 * @throws SimulationException
-	 *             If the weight is &le;0.
-	 */
-	protected Item(double weightInGrams) {
-		if(weightInGrams <= 0.0)
-			throw new SimulationException(new IllegalArgumentException("The weight has to be positive."));
-
-		this.weightInGrams = weightInGrams;
-	}
-
-	/**
-	 * The weight of the item, in grams.
-	 * 
-	 * @return The weight in grams.
-	 */
-	public double getWeight() {
-		return weightInGrams;
-	}
-}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/MagneticStripeFailureException.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/MagneticStripeFailureException.java
deleted file mode 100644
index ba6fb5e..0000000
--- a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/MagneticStripeFailureException.java	
+++ /dev/null
@@ -1,15 +0,0 @@
-package org.lsmr.selfcheckout;
-
-import java.io.IOException;
-
-/**
- * Represents exceptions arising from failures of the magnetic stripe.
- */
-public class MagneticStripeFailureException extends IOException {
-	private static final long serialVersionUID = -4703845851722394414L;
-
-	/**
-	 * Create an exception.
-	 */
-	public MagneticStripeFailureException() {}
-}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/Numeral.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/Numeral.java
deleted file mode 100644
index 3ba954f..0000000
--- a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/Numeral.java	
+++ /dev/null
@@ -1,59 +0,0 @@
-package org.lsmr.selfcheckout;
-
-/**
- * Represents numerals (i.e., number characters) referred to as "Arabic numbers"
- * in English.
- */
-public enum Numeral {
-	one((byte)1), two((byte)2), three((byte)3), four((byte)4), five((byte)5), six((byte)6), seven((byte)7),
-	eight((byte)8), nine((byte)9), zero((byte)0);
-
-	private byte value;
-
-	private Numeral(byte value) {
-		this.value = value;
-	}
-
-	/**
-	 * Obtains the numeric value of the numeral.
-	 * 
-	 * @return The numeric value of the numeral.
-	 */
-	public byte getValue() {
-		return value;
-	}
-
-	/**
-	 * Converts a number between 0 and 9 into the corresponding numeral.
-	 * 
-	 * @param number
-	 *            The number to convert. It must be between 0 and 9, inclusive.
-	 * @return {@link IllegalDigitException} If the number is less than 0 or greater than 9.
-	 */
-	public static Numeral valueOf(byte number) {
-		switch(number) {
-		case 0:
-			return zero;
-		case 1:
-			return one;
-		case 2:
-			return two;
-		case 3:
-			return three;
-		case 4:
-			return four;
-		case 5:
-			return five;
-		case 6:
-			return six;
-		case 7:
-			return seven;
-		case 8:
-			return eight;
-		case 9:
-			return nine;
-		default:
-			throw new IllegalDigitException("The number " + number + " does not correspond to a numeral.");
-		}
-	}
-}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/PLUCodedItem.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/PLUCodedItem.java
deleted file mode 100644
index a74dbdf..0000000
--- a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/PLUCodedItem.java	
+++ /dev/null
@@ -1,37 +0,0 @@
-package org.lsmr.selfcheckout;
-
-import org.lsmr.selfcheckout.devices.SimulationException;
-import org.lsmr.selfcheckout.products.Product;
-
-/**
- * Represents items for sale, each with a particular barcode and weight.
- */
-public class PLUCodedItem extends Item {
-	private PriceLookupCode pluCode;
-
-	/**
-	 * Basic constructor.
-	 * 
-	 * @param kind
-	 *            The kind of product that this item is.
-	 * @param weightInGrams
-	 *            The actual weight of the item.
-	 */
-	public PLUCodedItem(PriceLookupCode pluCode, double weightInGrams) {
-		super(weightInGrams);
-		
-		if(pluCode == null)
-			throw new SimulationException(new NullPointerException("pluCode is null"));
-		
-		this.pluCode = pluCode;
-	}
-
-	/**
-	 * Gets the PLU code of this item.
-	 * 
-	 * @return The PLU code.
-	 */
-	public PriceLookupCode getPLUCode() {
-		return pluCode;
-	}
-}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/PriceLookupCode.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/PriceLookupCode.java
deleted file mode 100644
index d44590d..0000000
--- a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/PriceLookupCode.java	
+++ /dev/null
@@ -1,114 +0,0 @@
-package org.lsmr.selfcheckout;
-
-import java.util.ArrayList;
-import java.util.Arrays;
-
-import org.lsmr.selfcheckout.devices.SimulationException;
-
-/**
- * Represents a PLU value, a sequence of digits that, in principle, could lie
- * anywhere in the range 0000-99999. Specific subranges are reserved for specific
- * purposes in the real world, but we will not worry about that here.
- */
-public class PriceLookupCode {
-	private Numeral[] numerals;
-
-	/**
-	 * Constructs a PLU code from a string of numerals. There must be at least 4
-	 * digits and at most 5.
-	 * 
-	 * @param code
-	 *            A string of digits.
-	 * @throws SimulationException
-	 *             If any character in the input is not a digit between 0 and 9,
-	 *             inclusive.
-	 * @throws SimulationException
-	 *             If the code contains less than 4 digits or more than 5 digits.
-	 * @throws NullPointerException
-	 *             If code is null.
-	 */
-	public PriceLookupCode(String code) {
-		if(code == null)
-			throw new SimulationException(new NullPointerException("code is null"));
-
-		char[] charArray = code.toCharArray();
-		numerals = new Numeral[charArray.length];
-
-		if(code.length() > 5)
-			throw new SimulationException(
-				new IllegalArgumentException("The code cannot contain more than five digits."));
-
-		if(code.length() < 4)
-			throw new SimulationException(
-				new IllegalArgumentException("The code cannot contain less than four digits."));
-
-		for(int i = 0; i < charArray.length; i++) {
-			try {
-				numerals[i] = Numeral.valueOf((byte)Character.digit(charArray[i], 10));
-			}
-			catch(IllegalDigitException e) {
-				throw new SimulationException(e);
-			}
-		}
-	}
-
-	/**
-	 * Gets the count of numerals in this code.
-	 * 
-	 * @return The count of numerals.
-	 */
-	public int numeralCount() {
-		return numerals.length;
-	}
-
-	/**
-	 * Gets the numeral at the indicated index within the code.
-	 * 
-	 * @param index
-	 *            The index of the numeral, &ge;0 and &lt;count.
-	 * @return The numeral at the indicated index.
-	 * @throws SimulationException
-	 *             If the index is outside the legal range.
-	 */
-	public Numeral getNumeralAt(int i) {
-		try {
-			return numerals[i];
-		}
-		catch(IndexOutOfBoundsException e) {
-			throw new SimulationException(e);
-		}
-	}
-
-	@Override
-	public String toString() {
-		char[] characters = new char[numerals.length];
-
-		for(int i = 0; i < numerals.length; i++)
-			characters[i] = Character.forDigit(numerals[i].getValue(), 10);
-
-		return new String(characters);
-	}
-
-	@Override
-	public boolean equals(Object object) {
-		if(object instanceof PriceLookupCode) {
-			PriceLookupCode other = (PriceLookupCode)object;
-
-			if(other.numerals.length != numerals.length)
-				return false;
-
-			for(int i = 0; i < numerals.length; i++)
-				if(!numerals[i].equals(other.numerals[i]))
-					return false;
-
-			return true;
-		}
-
-		return false;
-	}
-
-	@Override
-	public int hashCode() {
-		return Arrays.hashCode(numerals);
-	}
-}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/TapFailureException.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/TapFailureException.java
deleted file mode 100644
index c1a366c..0000000
--- a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/TapFailureException.java	
+++ /dev/null
@@ -1,15 +0,0 @@
-package org.lsmr.selfcheckout;
-
-import java.io.IOException;
-
-/**
- * Represents exceptions arising from failures of taps.
- */
-public class TapFailureException extends IOException {
-	private static final long serialVersionUID = -8812895797883270979L;
-
-	/**
-	 * Create an exception.
-	 */
-	public TapFailureException() {}
-}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/AbstractDevice.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/AbstractDevice.java
deleted file mode 100644
index 89f4880..0000000
--- a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/AbstractDevice.java	
+++ /dev/null
@@ -1,193 +0,0 @@
-package org.lsmr.selfcheckout.devices;
-
-import java.util.ArrayList;
-
-import org.lsmr.selfcheckout.devices.observers.AbstractDeviceObserver;
-
-/**
- * The abstract base class for all devices involved in the simulator.
- * <p>
- * This class utilizes the Observer design pattern. Subclasses inherit the
- * attach method, but each must define its own notifyXXX methods.
- * </p>
- * <p>
- * Each device must be coupled to an appropriate observer interface, which
- * extends AbstractDeviceObserver; the type parameter T represents this
- * observer.
- * <p>
- * <p>
- * Any individual device can be disabled, which means it will not permit
- * physical movements to be caused by the software. Any method that could cause
- * a physical movement will declare that it throws DisabledException.
- * </p>
- * 
- * @param <T>
- *            The type of observers used for this device. For a device whose
- *            class is X, its corresponding observer interface would typically
- *            be XObserver.
- */
-public abstract class AbstractDevice<T extends AbstractDeviceObserver> {
-	/**
-	 * Used to represent the operation phase of this device.
-	 */
-	protected enum Phase {
-		/**
-		 * The device is being configured.
-		 */
-		CONFIGURATION,
-		/**
-		 * The device is in normal operation.
-		 */
-		NORMAL,
-		/**
-		 * The device has undergone a fatal error requiring physical repair and reset.
-		 */
-		ERROR
-	}
-
-	/**
-	 * The current operation phase of this device.
-	 */
-	protected Phase phase = Phase.CONFIGURATION;
-
-	/**
-	 * Many devices require configuration before their use. Before configuration is
-	 * complete, the device should not operate. Once configuration is complete, any
-	 * further configuration attempts should cause exceptions.
-	 */
-	public void endConfigurationPhase() {
-		phase = Phase.NORMAL;
-	}
-
-	/**
-	 * For testing purposes only. Forces this device into an erroneous state.
-	 */
-	public void forceErrorPhase() {
-		phase = Phase.ERROR;
-	}
-
-	/**
-	 * A list of the registered observers on this device.
-	 */
-	protected ArrayList<T> observers = new ArrayList<>();
-
-	/**
-	 * Locates the indicated observer and removes it such that it will no longer be
-	 * informed of events from this device. If the observer is not currently
-	 * registered with this device, calls to this method will return false, but
-	 * otherwise have no effect.
-	 * <p>
-	 * This operation is permissible during the configuration phase.
-	 * 
-	 * @param observer
-	 *            The observer to remove.
-	 * @return true if the observer was found and removed, false otherwise.
-	 */
-	public final boolean detach(T observer) {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-
-		return observers.remove(observer);
-	}
-
-	/**
-	 * All observers registered with this device are removed. If there are none,
-	 * calls to this method have no effect.
-	 * <p>
-	 * This operation is permissible during the configuration phase.
-	 */
-	public final void detachAll() {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-
-		observers.clear();
-	}
-
-	/**
-	 * Registers the indicated observer to receive event notifications from this
-	 * device.
-	 * <p>
-	 * This operation is permissible during the configuration phase.
-	 * 
-	 * @param observer
-	 *            The observer to be added.
-	 */
-	public final void attach(T observer) {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-
-		if(observer == null)
-			throw new SimulationException(new IllegalArgumentException(
-				"This method may not receive null, as it has no analogue in the real world."));
-
-		observers.add(observer);
-	}
-
-	private boolean disabled = false;
-
-	/**
-	 * Disables this device from receiving input and producing output.
-	 * <p>
-	 * This operation is not permissible during the configuration phase.
-	 */
-	public final void disable() {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-		if(phase == Phase.CONFIGURATION)
-			throw new SimulationException(
-				new IllegalStateException("This method may not be called during the configuration phase."));
-
-		disabled = true;
-		notifyDisabled();
-	}
-
-	private void notifyDisabled() {
-		for(T observer : observers)
-			observer.disabled(this);
-	}
-
-	/**
-	 * Enables this device for receiving input and producing output.
-	 * <p>
-	 * This operation is not permissible during the configuration phase.
-	 */
-	public final void enable() {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-		if(phase == Phase.CONFIGURATION)
-			throw new SimulationException(
-				new IllegalStateException("This method may not be called during the configuration phase."));
-
-		disabled = false;
-		notifyEnabled();
-	}
-
-	private void notifyEnabled() {
-		for(T observer : observers)
-			observer.enabled(this);
-	}
-
-	/**
-	 * Returns whether this device is currently disabled from receiving input and
-	 * producing output.
-	 * <p>
-	 * This operation is illegal during the configuration phase.
-	 * 
-	 * @return true if the device is disabled; false if the device is enabled.
-	 */
-	public final boolean isDisabled() {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-		if(phase == Phase.CONFIGURATION)
-			throw new SimulationException(
-				new IllegalStateException("This method may not be called during the configuration phase."));
-
-		return disabled;
-	}
-}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/Acceptor.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/Acceptor.java
deleted file mode 100644
index 4534b94..0000000
--- a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/Acceptor.java	
+++ /dev/null
@@ -1,37 +0,0 @@
-package org.lsmr.selfcheckout.devices;
-
-import org.lsmr.selfcheckout.Coin;
-
-/**
- * A simple interface for devices that accept things.
- * 
- * @param <T>
- *            The type of the things to accept.
- */
-public interface Acceptor<T> {
-	/**
-	 * Instructs the device to take the thing as input.
-	 * <p>
-	 * This operation may not be called during the configuration phase.
-	 * 
-	 * @param thing
-	 *            The thing to be taken as input.
-	 * @throws OverloadException
-	 *             If the device does not have enough space for the thing.
-	 * @throws DisabledException
-	 *             If the device is disabled.
-	 */
-	public void accept(T thing) throws OverloadException, DisabledException;
-
-	/**
-	 * Checks whether the device has enough space to expect one more thing. If this
-	 * method returns true, an immediate call to accept should not throw
-	 * CapacityExceededException, unless an asynchronous addition has occurred in
-	 * the meantime.
-	 * <p>
-	 * This operation may not be called during the configuration phase.
-	 * 
-	 * @return true If there is space; otherwise, false.
-	 */
-	public boolean hasSpace();
-}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/BanknoteDispenser.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/BanknoteDispenser.java
deleted file mode 100644
index de25f9c..0000000
--- a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/BanknoteDispenser.java	
+++ /dev/null
@@ -1,213 +0,0 @@
-package org.lsmr.selfcheckout.devices;
-
-import java.util.ArrayList;
-import java.util.LinkedList;
-import java.util.List;
-import java.util.Queue;
-
-import org.lsmr.selfcheckout.Banknote;
-import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
-import org.lsmr.selfcheckout.devices.observers.BanknoteDispenserObserver;
-
-/**
- * Represents a device that stores banknotes (as known as bills, paper money,
- * etc.) of a particular denomination to dispense them as change.
- * <p>
- * Banknote dispensers can receive banknotes from other sources. To simplify the
- * simulation, no check is performed on the value of each banknote.
- * </p>
- */
-public final class BanknoteDispenser extends AbstractDevice<BanknoteDispenserObserver>
-	implements FromStorageEmitter<Banknote> {
-	private int maxCapacity;
-	private Queue<Banknote> queue = new LinkedList<Banknote>();
-	private UnidirectionalChannel<Banknote> sink;
-
-	/**
-	 * Creates a banknote dispenser with the indicated maximum capacity.
-	 * 
-	 * @param capacity
-	 *            The maximum number of banknotes that can be stored in the
-	 *            dispenser. Must be positive.
-	 * @throws SimulationException
-	 *             If capacity is not positive.
-	 */
-	public BanknoteDispenser(int capacity) {
-		if(capacity <= 0)
-			throw new SimulationException(new IllegalArgumentException("Capacity must be positive: " + capacity));
-
-		this.maxCapacity = capacity;
-	}
-
-	/**
-	 * Accesses the current number of banknotes in the dispenser.
-	 * <p>
-	 * This operation is illegal during the configuration phase.
-	 * 
-	 * @return The number of banknotes currently in the dispenser.
-	 */
-	public int size() {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-		if(phase == Phase.CONFIGURATION)
-			throw new SimulationException(
-				new IllegalStateException("This method may not be called during the configuration phase."));
-
-		return queue.size();
-	}
-
-	/**
-	 * Allows a set of banknotes to be loaded into the dispenser directly. Existing
-	 * banknotes in the dispenser are not removed.
-	 * <p>
-	 * This operation is permissible during the configuration phase.
-	 * 
-	 * @param banknotes
-	 *            A sequence of banknotes to be added. Each may not be null.
-	 * @throws OverloadException
-	 *             if the number of banknotes to be loaded exceeds the capacity of
-	 *             the dispenser.
-	 * @throws SimulationException
-	 *             If any banknote is null.
-	 */
-	public void load(Banknote... banknotes) throws SimulationException, OverloadException {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-
-		if(maxCapacity < queue.size() + banknotes.length)
-			throw new OverloadException("Capacity of dispenser is exceeded by load");
-
-		for(Banknote banknote : banknotes)
-			if(banknote == null)
-				throw new SimulationException(new NullPointerException("A banknote is null."));
-			else
-				queue.add(banknote);
-
-		notifyBanknotesLoaded(banknotes);
-	}
-
-	/**
-	 * Unloads banknotes from the dispenser directly. Causes a "banknotesUnloaded"
-	 * event to be announced.
-	 * <p>
-	 * This operation is permissible during the configuration phase.
-	 * 
-	 * @return A list of the banknotes unloaded. May be empty. Will never be null.
-	 */
-	public List<Banknote> unload() {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-
-		List<Banknote> result = new ArrayList<>(queue);
-		queue.clear();
-
-		notifyBanknotesUnoaded(result.toArray(new Banknote[result.size()]));
-
-		return result;
-	}
-
-	/**
-	 * Connects an output channel to this banknote dispenser. Any existing output
-	 * channels are disconnected. Causes no events to be announced.
-	 * <p>
-	 * This operation is permissible only during the configuration phase.
-	 * 
-	 * @param sink
-	 *            The new output device to act as output. Can be null, which leaves
-	 *            the channel without an output.
-	 */
-	public void connect(UnidirectionalChannel<Banknote> sink) {
-		if(phase != Phase.CONFIGURATION)
-			throw new SimulationException(
-				new IllegalStateException("This method may only be called during the configuration phase."));
-
-		this.sink = sink;
-	}
-
-	/**
-	 * Returns the maximum capacity of this banknote dispenser.
-	 * <p>
-	 * This operation is permissible during the configuration phase.
-	 * 
-	 * @return The capacity. Will be positive.
-	 */
-	public int getCapacity() {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-
-		return maxCapacity;
-	}
-
-	/**
-	 * Emits a single banknote from this banknote dispenser. If successful, a
-	 * "banknoteRemoved" event is announced to its observers. If a successful
-	 * banknote removal causes the dispenser to become empty, a "banknotesEmpty"
-	 * event is instead announced to its observers.
-	 * <p>
-	 * This operation is illegal during the configuration phase.
-	 * 
-	 * @throws OverloadException
-	 *             if the output channel is unable to accept another banknote.
-	 * @throws EmptyException
-	 *             if no banknotes are present in the dispenser to release.
-	 * @throws DisabledException
-	 *             if the dispenser is currently disabled.
-	 */
-	public void emit() throws EmptyException, DisabledException, OverloadException {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-		if(phase == Phase.CONFIGURATION)
-			throw new SimulationException(
-				new IllegalStateException("This method may not be called during the configuration phase."));
-
-		if(isDisabled())
-			throw new DisabledException();
-
-		if(queue.size() == 0)
-			throw new EmptyException();
-
-		Banknote banknote = queue.remove();
-
-		if(sink.hasSpace())
-			try {
-				sink.deliver(banknote);
-			}
-			catch(OverloadException e) {
-				// Should never happen
-				phase = Phase.ERROR;
-				throw new SimulationException(e);
-			}
-		else
-			throw new OverloadException("The sink is full.");
-
-		if(queue.isEmpty())
-			notifyBanknotesEmpty();
-		else
-			notifyBanknoteRemoved(banknote);
-	}
-
-	private void notifyBanknoteRemoved(Banknote banknote) {
-		for(BanknoteDispenserObserver observer : observers)
-			observer.banknoteRemoved(this, banknote);
-	}
-
-	private void notifyBanknotesEmpty() {
-		for(BanknoteDispenserObserver observer : observers)
-			observer.banknotesEmpty(this);
-	}
-
-	private void notifyBanknotesLoaded(Banknote[] banknotes) {
-		for(BanknoteDispenserObserver observer : observers)
-			observer.banknotesLoaded(this, banknotes);
-	}
-
-	private void notifyBanknotesUnoaded(Banknote[] banknotes) {
-		for(BanknoteDispenserObserver observer : observers)
-			observer.banknotesUnloaded(this, banknotes);
-	}
-}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/BanknoteSlot.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/BanknoteSlot.java
deleted file mode 100644
index 9037e26..0000000
--- a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/BanknoteSlot.java	
+++ /dev/null
@@ -1,191 +0,0 @@
-package org.lsmr.selfcheckout.devices;
-
-import org.lsmr.selfcheckout.Banknote;
-import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
-import org.lsmr.selfcheckout.devices.observers.BanknoteSlotObserver;
-
-/**
- * Represents a simple banknote slot device that can either accept a banknote or
- * eject the most recently inserted banknote, leaving it dangling until the
- * customer removes it, via {@link #removeDanglingBanknote()}.
- */
-public class BanknoteSlot extends AbstractDevice<BanknoteSlotObserver>
-	implements Acceptor<Banknote>, FlowThroughEmitter<Banknote> {
-	private BidirectionalChannel<Banknote> sink;
-	private boolean invert;
-
-	/**
-	 * Creates a banknote slot.
-	 * 
-	 * @param invert
-	 *            If the slot is to be inverted.
-	 */
-	public BanknoteSlot(boolean invert) {
-		this.invert = invert;
-	}
-
-	/**
-	 * Connects an output channel to the banknote slot. Causes no events.
-	 * <p>
-	 * This operation is permissible only during the configuration phase.
-	 * 
-	 * @param sink
-	 *            Where banknotes are passed into the machine.
-	 */
-	public void connect(BidirectionalChannel<Banknote> sink) {
-		if(phase != Phase.CONFIGURATION)
-			throw new SimulationException(
-				new IllegalStateException("This method may only be called during the configuration phase."));
-
-		this.sink = sink;
-	}
-
-	/**
-	 * Tells the banknote slot that the indicated banknote is being inserted. If the
-	 * sink can accept the banknote, the banknote is passed to the sink and a
-	 * "banknoteInserted" event is announced to the slot's observers; otherwise, a
-	 * "banknoteEjected" event is announced to the slot's observers, meaning that
-	 * the banknote is returned to the user.
-	 * <p>
-	 * This operation is not permissible during the configuration phase.
-	 * 
-	 * @param banknote
-	 *            The banknote to be added. Cannot be null.
-	 * @throws DisabledException
-	 *             if the banknote slot is currently disabled.
-	 * @throws SimulationException
-	 *             If the banknote is null.
-	 * @throws OverloadException
-	 *             If a banknote is dangling from the slot.
-	 */
-	public void accept(Banknote banknote) throws DisabledException, OverloadException {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-		if(phase == Phase.CONFIGURATION)
-			throw new SimulationException(
-				new IllegalStateException("This method may not be called during the configuration phase."));
-
-		if(isDisabled())
-			throw new DisabledException();
-
-		if(danglingEjectedBanknote != null)
-			throw new OverloadException("A banknote is dangling from the slot. Remove that before adding another.");
-
-		notifyBanknoteInserted();
-
-		if(!invert && sink.hasSpace()) {
-			try {
-				sink.deliver(banknote);
-			}
-			catch(OverloadException e) {
-				// Should never happen
-				phase = Phase.ERROR;
-				throw new SimulationException(e);
-			}
-		}
-		else {
-			danglingEjectedBanknote = banknote;
-			notifyBanknoteEjected();
-		}
-	}
-
-	private Banknote danglingEjectedBanknote = null;
-
-	/**
-	 * Ejects the indicated banknote, leaving it dangling until the customer grabs
-	 * it.
-	 * <p>
-	 * This operation is not permissible during the configuration phase.
-	 * 
-	 * @param banknote
-	 *            The banknote to be ejected.
-	 * @throws DisabledException
-	 *             If the device is disabled.
-	 * @throws SimulationException
-	 *             If the argument is null.
-	 * @throws SimulationException
-	 *             If a banknote is already dangling from the slot.
-	 */
-	public void emit(Banknote banknote) throws DisabledException, SimulationException {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-		if(phase == Phase.CONFIGURATION)
-			throw new SimulationException(
-				new IllegalStateException("This method may not be called during the configuration phase."));
-
-		if(isDisabled())
-			throw new DisabledException();
-
-		if(banknote == null)
-			throw new SimulationException(new NullPointerException("banknote is null"));
-
-		if(danglingEjectedBanknote != null)
-			throw new SimulationException(
-				"A banknote is already dangling from the slot. Remove that before ejecting another.");
-
-		danglingEjectedBanknote = banknote;
-
-		notifyBanknoteEjected();
-	}
-
-	/**
-	 * Simulates the user removing a banknote that is dangling from the slot.
-	 * <p>
-	 * This operation is not permissible during the configuration phase.
-	 * 
-	 * @return The formerly dangling banknote.
-	 */
-	public Banknote removeDanglingBanknote() {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-		if(phase == Phase.CONFIGURATION)
-			throw new SimulationException(
-				new IllegalStateException("This method may not be called during the configuration phase."));
-
-		if(danglingEjectedBanknote == null)
-			throw new SimulationException("A banknote that does not exist cannot be removed.");
-
-		Banknote b = danglingEjectedBanknote;
-		danglingEjectedBanknote = null;
-		notifyBanknoteRemoved();
-
-		return b;
-	}
-
-	/**
-	 * Tests whether a banknote can be accepted by or ejected from this slot.
-	 * <p>
-	 * This operation is not permissible during the configuration phase.
-	 * 
-	 * @return True if the slot is not occupied by a dangling banknote; otherwise,
-	 *             false.
-	 */
-	public boolean hasSpace() {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-		if(phase == Phase.CONFIGURATION)
-			throw new SimulationException(
-				new IllegalStateException("This method may not be called during the configuration phase."));
-
-		return danglingEjectedBanknote == null;
-	}
-
-	private void notifyBanknoteInserted() {
-		for(BanknoteSlotObserver observer : observers)
-			observer.banknoteInserted(this);
-	}
-
-	private void notifyBanknoteEjected() {
-		for(BanknoteSlotObserver observer : observers)
-			observer.banknoteEjected(this);
-	}
-
-	private void notifyBanknoteRemoved() {
-		for(BanknoteSlotObserver observer : observers)
-			observer.banknoteRemoved(this);
-	}
-}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/BanknoteStorageUnit.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/BanknoteStorageUnit.java
deleted file mode 100644
index 34e6a81..0000000
--- a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/BanknoteStorageUnit.java	
+++ /dev/null
@@ -1,199 +0,0 @@
-package org.lsmr.selfcheckout.devices;
-
-import java.util.Arrays;
-import java.util.List;
-
-import org.lsmr.selfcheckout.Banknote;
-import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
-import org.lsmr.selfcheckout.devices.observers.BanknoteStorageUnitObserver;
-
-/**
- * Represents devices that store banknotes. They only receive banknotes, not
- * dispense them. To access the banknotes inside, a human operator needs to
- * physically remove the banknotes, simulated with the {@link #unload()} method.
- * A {@link #load(Banknote...)} method is provided for symmetry.
- */
-public class BanknoteStorageUnit extends AbstractDevice<BanknoteStorageUnitObserver> implements Acceptor<Banknote> {
-	private Banknote[] storage;
-	private int nextIndex = 0;
-
-	/**
-	 * Creates a banknote storage unit that can hold the indicated number of
-	 * banknotes.
-	 * 
-	 * @param capacity
-	 *            The maximum number of banknotes that the unit can hold.
-	 * @throws SimulationException
-	 *             If the capacity is not positive.
-	 */
-	public BanknoteStorageUnit(int capacity) {
-		if(capacity <= 0)
-			throw new SimulationException(new IllegalArgumentException("The capacity must be positive."));
-
-		storage = new Banknote[capacity];
-	}
-
-	/**
-	 * Gets the maximum number of banknotes that this storage unit can hold.
-	 * <p>
-	 * This operation is permissible during the configuration phase.
-	 * 
-	 * @return The capacity.
-	 */
-	public int getCapacity() {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-
-		return storage.length;
-	}
-
-	/**
-	 * Gets the current count of banknotes contained in this storage unit.
-	 * <p>
-	 * This operation is permissible during the configuration phase.
-	 * 
-	 * @return The current count.
-	 */
-	public int getBanknoteCount() {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-
-		return nextIndex;
-	}
-
-	/**
-	 * Allows a set of banknotes to be loaded into the storage unit directly.
-	 * Existing banknotes in the dispenser are not removed. Causes a
-	 * "banknotesLoaded" event to be announced. Disabling has no effect on
-	 * loading/unloading.
-	 * <p>
-	 * This operation is permissible during the configuration phase.
-	 * 
-	 * @param banknotes
-	 *            A sequence of banknotes to be added. Each cannot be null.
-	 * @throws SimulationException
-	 *             if the number of banknotes to be loaded exceeds the capacity of
-	 *             the unit.
-	 * @throws SimulationException
-	 *             If the banknotes argument is null.
-	 * @throws SimulationException
-	 *             If any banknote is null.
-	 * @throws OverloadException
-	 *             If too many banknotes are stuffed in the unit.
-	 */
-	public void load(Banknote... banknotes) throws SimulationException, OverloadException {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-
-		if(banknotes == null)
-			throw new SimulationException(
-				new NullPointerException("banknotes is null which has no analogue in the real world"));
-
-		if(banknotes.length + nextIndex > storage.length)
-			throw new OverloadException("You tried to stuff too many banknotes in the storage unit.");
-
-		for(Banknote banknote : banknotes)
-			if(banknote == null)
-				throw new SimulationException(
-					new NullPointerException("No banknote may be null, which has no analogue in the real world."));
-
-		System.arraycopy(banknotes, 0, storage, nextIndex, banknotes.length);
-		nextIndex += banknotes.length;
-
-		notifyBanknotesLoaded();
-	}
-
-	/**
-	 * Unloads banknotes from the storage unit directly. Causes a
-	 * "banknotesUnloaded" event to be announced.
-	 * <p>
-	 * This operation is permissible during the configuration phase.
-	 * 
-	 * @return A list of the banknotes unloaded. May be empty. Will never be null.
-	 */
-	public List<Banknote> unload() {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-
-		List<Banknote> banknotes = Arrays.asList(storage);
-
-		storage = new Banknote[storage.length];
-		nextIndex = 0;
-		notifyBanknotesUnloaded();
-
-		return banknotes;
-	}
-
-	/**
-	 * Causes the indicated banknote to be added to the storage unit. If successful,
-	 * a "banknoteAdded" event is announced to its observers. If a successful
-	 * banknote addition causes the unit to become full, a "banknotesFull" event is
-	 * instead announced to its observers.
-	 * <p>
-	 * This operation is not permissible during the configuration phase.
-	 * 
-	 * @param banknote
-	 *            The banknote to add.
-	 * @throws DisabledException
-	 *             If the unit is currently disabled.
-	 * @throws SimulationException
-	 *             If banknote is null.
-	 * @throws OverloadException
-	 *             If the unit is already full.
-	 */
-	public void accept(Banknote banknote) throws DisabledException, OverloadException {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-		if(phase == Phase.CONFIGURATION)
-			throw new SimulationException(
-				new IllegalStateException("This method may not be called during the configuration phase."));
-
-		if(isDisabled())
-			throw new DisabledException();
-
-		if(banknote == null)
-			throw new SimulationException(
-				new NullPointerException("banknote is null, which has no analogue in the real world."));
-
-		if(nextIndex < storage.length) {
-			storage[nextIndex++] = banknote;
-
-			if(nextIndex == storage.length)
-				notifyBanknotesFull();
-			else
-				notifyBanknoteAdded();
-		}
-		else
-			throw new OverloadException();
-	}
-
-	@Override
-	public boolean hasSpace() {
-		return nextIndex < storage.length;
-	}
-
-	private void notifyBanknotesLoaded() {
-		for(BanknoteStorageUnitObserver l : observers)
-			l.banknotesLoaded(this);
-	}
-
-	private void notifyBanknotesUnloaded() {
-		for(BanknoteStorageUnitObserver l : observers)
-			l.banknotesUnloaded(this);
-	}
-
-	private void notifyBanknotesFull() {
-		for(BanknoteStorageUnitObserver l : observers)
-			l.banknotesFull(this);
-	}
-
-	private void notifyBanknoteAdded() {
-		for(BanknoteStorageUnitObserver l : observers)
-			l.banknoteAdded(this);
-	}
-}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/BanknoteValidator.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/BanknoteValidator.java
deleted file mode 100644
index e014ea9..0000000
--- a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/BanknoteValidator.java	
+++ /dev/null
@@ -1,201 +0,0 @@
-package org.lsmr.selfcheckout.devices;
-
-import java.util.Arrays;
-import java.util.Currency;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.Random;
-
-import org.lsmr.selfcheckout.Banknote;
-import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
-import org.lsmr.selfcheckout.devices.observers.BanknoteValidatorObserver;
-
-/**
- * Represents a device for optically and/or magnetically validating banknotes.
- * Banknotes deemed valid are moved to storage; banknotes deemed invalid are
- * ejected.
- */
-public final class BanknoteValidator extends AbstractDevice<BanknoteValidatorObserver>
-	implements Acceptor<Banknote>, Emitter<Banknote> {
-	private final Currency currency;
-	private final int[] denominations;
-	private BidirectionalChannel<Banknote> source;
-	private UnidirectionalChannel<Banknote> sink;
-
-	/**
-	 * Creates a banknote validator that recognizes banknotes of the specified
-	 * denominations (i.e., values) and currency.
-	 * 
-	 * @param currency
-	 *            The kind of currency to accept.
-	 * @param denominations
-	 *            An array of the valid banknote denominations (like $5, $10, etc.)
-	 *            to accept. Each value must be &gt;0 and unique in this array.
-	 * @throws SimulationException
-	 *             If either argument is null.
-	 * @throws SimulationException
-	 *             If the denominations array does not contain at least one value.
-	 * @throws SimulationException
-	 *             If any value in the denominations array is non-positive.
-	 * @throws SimulationException
-	 *             If any value in the denominations array is non-unique.
-	 */
-	public BanknoteValidator(Currency currency, int[] denominations) {
-		if(currency == null)
-			throw new SimulationException(
-				new NullPointerException("currency is null, which has no analogue in the real world."));
-
-		if(denominations == null)
-			throw new SimulationException(
-				new NullPointerException("denominations is null, which has no analogue in the real world."));
-
-		if(denominations.length < 1)
-			throw new SimulationException(new IllegalArgumentException("There must be at least one denomination."));
-
-		this.currency = currency;
-		Arrays.sort(denominations);
-
-		HashSet<Integer> set = new HashSet<>();
-
-		for(int denomination : denominations) {
-			if(denomination <= 0)
-				throw new SimulationException(
-					new IllegalArgumentException("Non-positive denomination detected: " + denomination + "."));
-
-			if(set.contains(denomination))
-				throw new SimulationException(new IllegalArgumentException(
-					"Each denomination must be unique, but " + denomination + " is repeated."));
-
-			set.add(denomination);
-		}
-
-		this.denominations = denominations;
-	}
-
-	/**
-	 * Connects input and output channels to the banknote validator. Causes no events.
-	 * <p>
-	 * This operation is permissible only during the configuration phase.
-	 * 
-	 * @param source
-	 *            The channel from which banknotes normally arrive for validation,
-	 *            and to which invalid banknotes will be ejected.
-	 * @param sink
-	 *            The channel to which all valid banknotes are routed.
-	 */
-	public void connect(BidirectionalChannel<Banknote> source, UnidirectionalChannel<Banknote> sink) {
-		if(phase != Phase.CONFIGURATION)
-			throw new SimulationException(
-				new IllegalStateException("This method may only be called during the configuration phase."));
-
-		this.source = source;
-		this.sink = sink;
-	}
-
-	private final Random pseudoRandomNumberGenerator = new Random();
-	private static final int PROBABILITY_OF_FALSE_REJECTION = 1; /* out of 100 */
-
-	private boolean isValid(Banknote banknote) {
-		if(currency.equals(banknote.getCurrency()))
-			for(int denomination : denominations)
-				if(denomination == banknote.getValue())
-					return pseudoRandomNumberGenerator.nextInt(100) >= PROBABILITY_OF_FALSE_REJECTION;
-
-		return false;
-	}
-
-	/**
-	 * Tells the banknote validator that the indicated banknote is being inserted.
-	 * If the banknote is valid, a "validBanknoteDetected" event is announced to its
-	 * observers; otherwise, an "invalidBanknoteDetected" event is announced to its
-	 * observers.
-	 * <p>
-	 * If there is space in the machine to store a valid banknote, it is passed to
-	 * the sink channel.
-	 * </p>
-	 * <p>
-	 * If there is no space in the machine to store it or the banknote is invalid,
-	 * the banknote is ejected to the source.
-	 * </p>
-	 * <p>
-	 * This operation is not permissible during the configuration phase.
-	 * 
-	 * @param banknote
-	 *            The banknote to be added. Cannot be null.
-	 * @throws DisabledException
-	 *             if the banknote validator is currently disabled.
-	 * @throws SimulationException
-	 *             If the banknote is null.
-	 */
-	@Override
-	public void accept(Banknote banknote) throws DisabledException {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-		if(phase == Phase.CONFIGURATION)
-			throw new SimulationException(
-				new IllegalStateException("This method may not be called during the configuration phase."));
-
-		if(isDisabled())
-			throw new DisabledException();
-
-		if(banknote == null)
-			throw new SimulationException(new NullPointerException("banknote is null"));
-
-		if(isValid(banknote)) {
-			notifyValidBanknoteDetected(banknote);
-
-			if(sink.hasSpace()) {
-				try {
-					sink.deliver(banknote);
-				}
-				catch(OverloadException e) {
-					// Should never happen
-					phase = Phase.ERROR;
-					throw new SimulationException(e);
-				}
-			}
-			else {
-				try {
-					source.eject(banknote);
-				}
-				catch(OverloadException e) {
-					// Should never happen
-					phase = Phase.ERROR;
-					throw new SimulationException(e);
-				}
-			}
-		}
-		else {
-			notifyInvalidBanknoteDetected();
-
-			try {
-				source.eject(banknote);
-			}
-			catch(OverloadException e) {
-				// Should never happen
-				phase = Phase.ERROR;
-				throw new SimulationException("Unable to route banknote: sink is full");
-			}
-		}
-	}
-
-	@Override
-	public boolean hasSpace() {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-
-		return true;
-	}
-
-	private void notifyValidBanknoteDetected(Banknote banknote) {
-		for(BanknoteValidatorObserver observer : observers)
-			observer.validBanknoteDetected(this, banknote.getCurrency(), banknote.getValue());
-	}
-
-	private void notifyInvalidBanknoteDetected() {
-		for(BanknoteValidatorObserver observer : observers)
-			observer.invalidBanknoteDetected(this);
-	}
-}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/BarcodeScanner.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/BarcodeScanner.java
deleted file mode 100644
index 872da0e..0000000
--- a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/BarcodeScanner.java	
+++ /dev/null
@@ -1,60 +0,0 @@
-package org.lsmr.selfcheckout.devices;
-
-import java.util.Random;
-
-import org.lsmr.selfcheckout.BarcodedItem;
-import org.lsmr.selfcheckout.Item;
-import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
-import org.lsmr.selfcheckout.devices.observers.BarcodeScannerObserver;
-
-/**
- * A complex device hidden behind a simple simulation. They can scan and that is
- * about all.
- */
-public class BarcodeScanner extends AbstractDevice<BarcodeScannerObserver> {
-	/**
-	 * Create a barcode scanner.
-	 */
-	public BarcodeScanner() {}
-
-	private Random random = new Random();
-	private static final int PROBABILITY_OF_FAILED_SCAN = 10; /* out of 100 */
-
-	/**
-	 * Simulates the customer's action of scanning an item. The result of the scan
-	 * is only announced to any registered observers.
-	 * <p>
-	 * This operation is not permissible during the configuration phase.
-	 * 
-	 * @param item
-	 *            The item to scan. Of course, it will only work if the item has a
-	 *            barcode, and maybe not even then.
-	 * @throws SimulationException
-	 *             If item is null.
-	 */
-	public void scan(Item item) {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-		if(phase == Phase.CONFIGURATION)
-			throw new SimulationException(
-				new IllegalStateException("This method may not be called during the configuration phase."));
-
-		if(isDisabled())
-			return; // silently ignore it
-
-		if(item == null)
-			throw new SimulationException(
-				new NullPointerException("item is null, which has no analogue in the real world."));
-
-		if(item instanceof BarcodedItem && random.nextInt(100) >= PROBABILITY_OF_FAILED_SCAN)
-			notifyBarcodeScanned((BarcodedItem)item);
-
-		// otherwise, silently ignore it
-	}
-
-	private void notifyBarcodeScanned(BarcodedItem item) {
-		for(BarcodeScannerObserver l : observers)
-			l.barcodeScanned(this, item.getBarcode());
-	}
-}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/BidirectionalChannel.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/BidirectionalChannel.java
deleted file mode 100644
index 4d67894..0000000
--- a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/BidirectionalChannel.java	
+++ /dev/null
@@ -1,69 +0,0 @@
-package org.lsmr.selfcheckout.devices;
-
-import org.lsmr.selfcheckout.Banknote;
-import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
-
-/**
- * Represents a simple device (like, say, a tube or just a physical connection)
- * that moves things between other devices. This channel is bidirectional.
- * 
- * @param <T>
- *            The type of the things to move.
- */
-public final class BidirectionalChannel<T> {
-	private FlowThroughEmitter<T> source;
-	private Acceptor<T> sink;
-
-	/**
-	 * Constructs a new channel whose input is connected to the indicated source and
-	 * whose output is connected to the indicated sink.
-	 * 
-	 * @param source
-	 *            The device at the output end of the channel.
-	 * @param sink
-	 *            The device at the output end of the channel.
-	 */
-	public BidirectionalChannel(FlowThroughEmitter<T> source, Acceptor<T> sink) {
-		this.source = source;
-		this.sink = sink;
-	}
-
-	/**
-	 * Moves the indicated thing to the source. This method should be called by
-	 * the sink device, and not by an external application.
-	 * 
-	 * @param thing
-	 *            The thing to transport via the channel.
-	 * @throws OverloadException
-	 *             if the sink has no space for the banknote.
-	 * @throws DisabledException
-	 *             if the sink is currently disabled.
-	 */
-	public void eject(T thing) throws OverloadException, DisabledException {
-		source.emit(thing);
-	}
-
-	/**
-	 * Moves the indicated banknote to the sink. This method should be called by the
-	 * source device, and not by an external application.
-	 * 
-	 * @param banknote
-	 *            The banknote to transport via the channel.
-	 * @throws OverloadException
-	 *             if the sink has no space for the banknote.
-	 * @throws DisabledException
-	 *             if the sink is currently disabled.
-	 */
-	public void deliver(T banknote) throws OverloadException, DisabledException {
-		sink.accept(banknote);
-	}
-
-	/**
-	 * Returns whether the sink has space for at least one more banknote.
-	 * 
-	 * @return true if the sink can accept a banknote; false otherwise.
-	 */
-	public boolean hasSpace() {
-		return sink.hasSpace();
-	}
-}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/CardReader.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/CardReader.java
deleted file mode 100644
index de592f1..0000000
--- a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/CardReader.java	
+++ /dev/null
@@ -1,185 +0,0 @@
-package org.lsmr.selfcheckout.devices;
-
-import java.awt.image.BufferedImage;
-import java.io.IOException;
-import java.util.concurrent.ThreadLocalRandom;
-
-import org.lsmr.selfcheckout.Card;
-import org.lsmr.selfcheckout.Card.CardData;
-import org.lsmr.selfcheckout.ChipFailureException;
-import org.lsmr.selfcheckout.MagneticStripeFailureException;
-import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
-import org.lsmr.selfcheckout.devices.observers.CardReaderObserver;
-
-/**
- * Represents the card reader, capable of tap, chip insert, and swipe. Either
- * the reader or the card may fail, or the data read in can be corrupted, with
- * varying probabilities.
- */
-public class CardReader extends AbstractDevice<CardReaderObserver> {
-	private boolean cardIsInserted = false;
-
-	/**
-	 * Create a card reader.
-	 */
-	public CardReader() {}
-
-	private final static ThreadLocalRandom random = ThreadLocalRandom.current();
-	private final static double PROBABILITY_OF_TAP_FAILURE = 0.01;
-	private final static double PROBABILITY_OF_INSERT_FAILURE = 0.01;
-	private final static double PROBABILITY_OF_SWIPE_FAILURE = 0.1;
-
-	/**
-	 * Tap the card.
-	 * <p>
-	 * This operation is not permissible during the configuration phase.
-	 * 
-	 * @param card
-	 *            The card to tap.
-	 * @return The card's (possibly corrupted) data, or null if the card is not tap
-	 *             enabled.
-	 * @throws IOException
-	 *             If the tap failed (lack of failure does not mean that the data is
-	 *             not corrupted).
-	 */
-	public CardData tap(Card card) throws IOException {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-		if(phase == Phase.CONFIGURATION)
-			throw new SimulationException(
-				new IllegalStateException("This method may not be called during the configuration phase."));
-
-		if(card.isTapEnabled) {
-			notifyCardTapped();
-
-			if(random.nextDouble(0.0, 1.0) > PROBABILITY_OF_TAP_FAILURE) {
-				CardData data = card.tap();
-
-				notifyCardDataRead(data);
-
-				return data;
-			}
-			else
-				throw new ChipFailureException();
-		}
-
-		// else ignore
-		return null;
-	}
-
-	/**
-	 * Swipe the card.
-	 * <p>
-	 * This operation is not permissible during the configuration phase.
-	 * 
-	 * @param card
-	 *            The card to swipe.
-	 * @return The card data.
-	 * @throws IOException
-	 *             If the swipe failed.
-	 */
-	public CardData swipe(Card card) throws IOException {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-		if(phase == Phase.CONFIGURATION)
-			throw new SimulationException(
-				new IllegalStateException("This method may not be called during the configuration phase."));
-
-		notifyCardSwiped();
-
-		if(random.nextDouble(0.0, 1.0) > PROBABILITY_OF_SWIPE_FAILURE) {
-			CardData data = card.swipe();
-
-			notifyCardDataRead(data);
-
-			return data;
-		}
-
-		throw new MagneticStripeFailureException();
-	}
-
-	/**
-	 * Insert the card.
-	 * <p>
-	 * This operation is not permissible during the configuration phase.
-	 * 
-	 * @param card
-	 *            The card to insert.
-	 * @param pin
-	 *            The customer's PIN.
-	 * @return The card data.
-	 * @throws SimulationException
-	 *             If there is already a card in the slot.
-	 * @throws IOException
-	 *             The insertion failed.
-	 */
-	public CardData insert(Card card, String pin) throws IOException {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-		if(phase == Phase.CONFIGURATION)
-			throw new SimulationException(
-				new IllegalStateException("This method may not be called during the configuration phase."));
-
-		if(cardIsInserted)
-			throw new IllegalStateException("There is already a card in the slot");
-
-		cardIsInserted = true;
-
-		notifyCardInserted();
-
-		if(card.hasChip && random.nextDouble(0.0, 1.0) > PROBABILITY_OF_INSERT_FAILURE) {
-			CardData data = card.insert(pin);
-
-			notifyCardDataRead(data);
-
-			return data;
-		}
-
-		throw new ChipFailureException();
-	}
-
-	/**
-	 * Remove the card from the slot.
-	 * <p>
-	 * This operation is not permissible during the configuration phase.
-	 */
-	public void remove() {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-		if(phase == Phase.CONFIGURATION)
-			throw new SimulationException(
-				new IllegalStateException("This method may not be called during the configuration phase."));
-
-		cardIsInserted = false;
-		notifyCardRemoved();
-	}
-
-	private void notifyCardTapped() {
-		for(CardReaderObserver l : observers)
-			l.cardTapped(this);
-	}
-
-	private void notifyCardInserted() {
-		for(CardReaderObserver l : observers)
-			l.cardInserted(this);
-	}
-
-	private void notifyCardSwiped() {
-		for(CardReaderObserver l : observers)
-			l.cardSwiped(this);
-	}
-
-	private void notifyCardDataRead(CardData data) {
-		for(CardReaderObserver l : observers)
-			l.cardDataRead(this, data);
-	}
-
-	private void notifyCardRemoved() {
-		for(CardReaderObserver l : observers)
-			l.cardRemoved(this);
-	}
-}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/CoinDispenser.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/CoinDispenser.java
deleted file mode 100644
index e6cdc73..0000000
--- a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/CoinDispenser.java	
+++ /dev/null
@@ -1,262 +0,0 @@
-package org.lsmr.selfcheckout.devices;
-
-import java.util.ArrayList;
-import java.util.LinkedList;
-import java.util.List;
-import java.util.Queue;
-
-import org.lsmr.selfcheckout.Coin;
-import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
-import org.lsmr.selfcheckout.devices.observers.CoinDispenserObserver;
-
-/**
- * Represents a device that stores coins of a particular denomination to
- * dispense them as change.
- * <p>
- * Coin dispensers can receive coins from other sources. To simplify the
- * simulation, no check is performed on the value of each coin, meaning it is an
- * external responsibility to ensure the correct routing of coins.
- * </p>
- */
-public final class CoinDispenser extends AbstractDevice<CoinDispenserObserver>
-	implements Acceptor<Coin>, FromStorageEmitter<Coin> {
-	private int maxCapacity;
-	private Queue<Coin> queue = new LinkedList<Coin>();
-	private UnidirectionalChannel<Coin> sink;
-
-	/**
-	 * Creates a coin dispenser with the indicated maximum capacity.
-	 * 
-	 * @param capacity
-	 *            The maximum number of coins that can be stored in the dispenser.
-	 *            Must be positive.
-	 * @throws SimulationException
-	 *             if capacity is not positive.
-	 */
-	public CoinDispenser(int capacity) {
-		if(capacity <= 0)
-			throw new SimulationException(new IllegalArgumentException("Capacity must be positive: " + capacity));
-
-		this.maxCapacity = capacity;
-	}
-
-	/**
-	 * Accesses the current number of coins in the dispenser.
-	 * <p>
-	 * This operation is permissible during the configuration phase.
-	 * 
-	 * @return The number of coins currently in the dispenser.
-	 */
-	public int size() {
-		return queue.size();
-	}
-
-	/**
-	 * Allows a set of coins to be loaded into the dispenser directly. Existing
-	 * coins in the dispenser are not removed. Causes a "coinsLoaded" event to be
-	 * announced.
-	 * <p>
-	 * This operation is permissible during the configuration phase.
-	 * 
-	 * @param coins
-	 *            A sequence of coins to be added. Each cannot be null.
-	 * @throws OverloadException
-	 *             if the number of coins to be loaded exceeds the capacity of the
-	 *             dispenser.
-	 * @throws SimulationException
-	 *             If any coin is null.
-	 */
-	public void load(Coin... coins) throws SimulationException, OverloadException {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-
-		if(maxCapacity < queue.size() + coins.length)
-			throw new OverloadException("Capacity of dispenser is exceeded by load");
-
-		for(Coin coin : coins)
-			if(coin == null)
-				throw new SimulationException(new NullPointerException("A coin is null"));
-			else
-				queue.add(coin);
-
-		notifyLoad(coins);
-	}
-
-	private void notifyLoad(Coin[] coins) {
-		for(CoinDispenserObserver observer : observers)
-			observer.coinsLoaded(this, coins);
-	}
-
-	/**
-	 * Unloads coins from the dispenser directly. Causes a "coinsUnloaded" event to
-	 * be announced.
-	 * <p>
-	 * This operation is permissible during the configuration phase.
-	 * 
-	 * @return A list of the coins unloaded. May be empty. Will never be null.
-	 */
-	public List<Coin> unload() {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-
-		List<Coin> result = new ArrayList<>(queue);
-		queue.clear();
-
-		notifyUnload(result.toArray(new Coin[result.size()]));
-
-		return result;
-	}
-
-	private void notifyUnload(Coin[] coins) {
-		for(CoinDispenserObserver observer : observers)
-			observer.coinsUnloaded(this, coins);
-	}
-
-	/**
-	 * Connects an output channel to this coin dispenser. Any existing output
-	 * channels are disconnected. Causes no events to be announced.
-	 * <p>
-	 * This operation is only permissible during the configuration phase.
-	 * 
-	 * @param sink
-	 *            The new output device to act as output. Can be null, which leaves
-	 *            the channel without an output.
-	 */
-	public void connect(UnidirectionalChannel<Coin> sink) {
-		if(phase != Phase.CONFIGURATION)
-			throw new SimulationException(
-				new IllegalStateException("This method may only be called during the configuration phase."));
-
-		this.sink = sink;
-	}
-
-	/**
-	 * Returns the maximum capacity of this coin dispenser.
-	 * <p>
-	 * This operation is permissible during the configuration phase.
-	 * 
-	 * @return The capacity. Will be positive.
-	 */
-	public int getCapacity() {
-		return maxCapacity;
-	}
-
-	/**
-	 * Causes the indicated coin to be added into the dispenser. If successful, a
-	 * "coinAdded" event is announced to its observers. If a successful coin
-	 * addition causes the dispenser to become full, a "coinsFull" event is
-	 * announced to its observers.
-	 * <p>
-	 * This operation is not permissible during the configuration phase.
-	 * 
-	 * @throws DisabledException
-	 *             If the coin dispenser is currently disabled.
-	 * @throws SimulationException
-	 *             If coin is null.
-	 * @throws OverloadException
-	 *             If the coin dispenser is already full.
-	 */
-	@Override
-	public void accept(Coin coin) throws OverloadException, DisabledException {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-		if(phase == Phase.CONFIGURATION)
-			throw new SimulationException(
-				new IllegalStateException("This method may not be called during the configuration phase."));
-
-		if(isDisabled())
-			throw new DisabledException();
-
-		if(coin == null)
-			throw new SimulationException(
-				new NullPointerException("coin is null, which has no analogue in the real world."));
-
-		if(queue.size() >= maxCapacity)
-			throw new OverloadException();
-
-		queue.add(coin);
-		notifyCoinAdded(coin);
-
-		if(queue.size() >= maxCapacity)
-			notifyCoinsFull();
-	}
-
-	/**
-	 * Releases a single coin from this coin dispenser. If successful, a
-	 * "coinRemoved" event is announced to its observers. If a successful coin
-	 * removal causes the dispenser to become empty, a "coinsEmpty" event is
-	 * announced to its observers.
-	 * <p>
-	 * This operation is not permissible during the configuration phase.
-	 * 
-	 * @throws OverloadException
-	 *             If the output channel is unable to accept another coin.
-	 * @throws EmptyException
-	 *             If no coins are present in the dispenser to release.
-	 * @throws DisabledException
-	 *             If the dispenser is currently disabled.
-	 */
-	public void emit() throws OverloadException, EmptyException, DisabledException {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-		if(phase == Phase.CONFIGURATION)
-			throw new SimulationException(
-				new IllegalStateException("This method may not be called during the configuration phase."));
-
-		if(isDisabled())
-			throw new DisabledException();
-
-		if(queue.size() == 0)
-			throw new EmptyException();
-
-		Coin coin = queue.remove();
-
-		notifyCoinRemoved(coin);
-		sink.deliver(coin);
-
-		if(queue.isEmpty())
-			notifyCoinsEmpty();
-	}
-
-	/**
-	 * Returns whether this coin dispenser has enough space to accept at least one
-	 * more coin. Announces no events.
-	 * <p>
-	 * This operation is not permissible during the configuration phase.
-	 */
-	@Override
-	public boolean hasSpace() {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-		if(phase == Phase.CONFIGURATION)
-			throw new SimulationException(
-				new IllegalStateException("This method may not be called during the configuration phase."));
-
-		return queue.size() < maxCapacity;
-	}
-
-	private void notifyCoinAdded(Coin coin) {
-		for(CoinDispenserObserver observer : observers)
-			observer.coinAdded(this, coin);
-	}
-
-	private void notifyCoinRemoved(Coin coin) {
-		for(CoinDispenserObserver observer : observers)
-			observer.coinRemoved(this, coin);
-	}
-
-	private void notifyCoinsFull() {
-		for(CoinDispenserObserver observer : observers)
-			observer.coinsFull(this);
-	}
-
-	private void notifyCoinsEmpty() {
-		for(CoinDispenserObserver observer : observers)
-			observer.coinsEmpty(this);
-	}
-}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/CoinSlot.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/CoinSlot.java
deleted file mode 100644
index 514af14..0000000
--- a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/CoinSlot.java	
+++ /dev/null
@@ -1,97 +0,0 @@
-package org.lsmr.selfcheckout.devices;
-
-import org.lsmr.selfcheckout.Coin;
-import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
-import org.lsmr.selfcheckout.devices.observers.CoinSlotObserver;
-
-/**
- * Represents a simple coin slot device that has one output channel. The slot is
- * stupid: it has no functionality other than being enabled/disabled, and cannot
- * determine the value and currency of the coin.
- */
-public final class CoinSlot extends AbstractDevice<CoinSlotObserver> implements Acceptor<Coin> {
-	private UnidirectionalChannel<Coin> sink;
-
-	/**
-	 * Creates a coin slot.
-	 */
-	public CoinSlot() {}
-
-	/**
-	 * Connects channels to the coin slot. Causes no events.
-	 * <p>
-	 * This operation is permissible only during the configuration phase.
-	 * 
-	 * @param sink
-	 *            Where coins will always be passed.
-	 */
-	public void connect(UnidirectionalChannel<Coin> sink) {
-		if(phase != Phase.CONFIGURATION)
-			throw new SimulationException(
-				new IllegalStateException("This method may only be called during the configuration phase."));
-
-		this.sink = sink;
-	}
-
-	/**
-	 * Tells the coin slot that the indicated coin is being inserted. If the slot is
-	 * enabled, this causes a "coinInserted" event to be announced to its observers.
-	 * <p>
-	 * This operation is not permissible during the configuration phase.
-	 * 
-	 * @param coin
-	 *            The coin to be added. Cannot be null.
-	 * @throws DisabledException
-	 *             If the coin slot is currently disabled.
-	 * @throws SimulationException
-	 *             If coin is null.
-	 * @throws NullPointerException
-	 *             If the coin is null.
-	 */
-	public void accept(Coin coin) throws DisabledException {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-		if(phase == Phase.CONFIGURATION)
-			throw new SimulationException(
-				new IllegalStateException("This method may not be called during the configuration phase."));
-
-		if(isDisabled())
-			throw new DisabledException();
-
-		if(coin == null)
-			throw new SimulationException(new NullPointerException("coin is null"));
-
-		notifyCoinInserted();
-
-		if(sink.hasSpace()) {
-			try {
-				sink.deliver(coin);
-			}
-			catch(OverloadException e) {
-				// Should never happen
-				phase = Phase.ERROR;
-				throw new SimulationException(e);
-			}
-		}
-		else
-			throw new SimulationException("Unable to route coin: Output channel is full");
-	}
-
-	@Override
-	public boolean hasSpace() {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-		if(phase == Phase.CONFIGURATION)
-			throw new SimulationException(
-				new IllegalStateException("This method may not be called during the configuration phase."));
-
-		return sink.hasSpace();
-	}
-
-	private void notifyCoinInserted() {
-		for(CoinSlotObserver observer : observers)
-			observer.coinInserted(this);
-	}
-}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/CoinStorageUnit.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/CoinStorageUnit.java
deleted file mode 100644
index 6fc0059..0000000
--- a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/CoinStorageUnit.java	
+++ /dev/null
@@ -1,186 +0,0 @@
-package org.lsmr.selfcheckout.devices;
-
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.List;
-
-import org.lsmr.selfcheckout.Coin;
-import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
-import org.lsmr.selfcheckout.devices.observers.CoinStorageUnitObserver;
-
-/**
- * Represents devices that store coins. They only receive coins, not dispense
- * them. To access the coins inside, a human operator needs to physically remove
- * the coins, simulated with the {@link #unload()} method. A
- * {@link #load(Coin...)} method is provided for symmetry.
- */
-public class CoinStorageUnit extends AbstractDevice<CoinStorageUnitObserver> implements Acceptor<Coin> {
-	private Coin[] storage;
-	private int nextIndex = 0;
-
-	/**
-	 * Creates a coin storage unit that can hold the indicated number of coins.
-	 * 
-	 * @param capacity
-	 *            The maximum number of coins that the unit can hold.
-	 * @throws SimulationException
-	 *             If the capacity is not positive.
-	 */
-	public CoinStorageUnit(int capacity) {
-		if(capacity <= 0)
-			throw new SimulationException(new IllegalArgumentException("The capacity must be positive."));
-
-		storage = new Coin[capacity];
-	}
-
-	/**
-	 * Gets the maximum number of coins that this storage unit can hold.
-	 * <p>
-	 * This operation is permissible during the configuration phase.
-	 * 
-	 * @return The capacity.
-	 */
-	public int getCapacity() {
-		return storage.length;
-	}
-
-	/**
-	 * Gets the current count of coins contained in this storage unit.
-	 * <p>
-	 * This operation is permissible during the configuration phase.
-	 * 
-	 * @return The current count.
-	 */
-	public int getCoinCount() {
-		return nextIndex;
-	}
-
-	/**
-	 * Allows a set of coins to be loaded into the storage unit directly. Existing
-	 * coins in the dispenser are not removed. Causes a "coinsLoaded" event to be
-	 * announced. Disabling has no effect on loading/unloading.
-	 * <p>
-	 * This operation is not permissible during the configuration phase.
-	 * 
-	 * @param coins
-	 *            A sequence of coins to be added. Each cannot be null.
-	 * @throws SimulationException
-	 *             if the number of coins to be loaded exceeds the capacity of the
-	 *             unit.
-	 * @throws SimulationException
-	 *             If coins is null.
-	 * @throws SimulationException
-	 *             If any coin is null.
-	 * @throws OverloadException
-	 *             If too many coins are loaded.
-	 */
-	public void load(Coin... coins) throws SimulationException, OverloadException {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-
-		if(coins == null)
-			throw new SimulationException(
-				new NullPointerException("coins is null, which has no analogue in the real world."));
-
-		if(coins.length + nextIndex > storage.length)
-			throw new OverloadException("You tried to stuff too many coins in the storage unit.");
-
-		for(Coin coin : coins)
-			if(coin == null)
-				throw new SimulationException(new NullPointerException("No coin may be null"));
-
-		System.arraycopy(coins, 0, storage, nextIndex, coins.length);
-		nextIndex += coins.length;
-
-		notifyCoinsLoaded();
-	}
-
-	/**
-	 * Unloads coins from the storage unit directly. Causes a "coinsUnloaded" event
-	 * to be announced.
-	 * <p>
-	 * This operation is permissible during the configuration phase.
-	 * 
-	 * @return A list of the coins unloaded. May be empty. Will never be null.
-	 */
-	public List<Coin> unload() {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-
-		List<Coin> coins = Arrays.asList(storage);
-
-		storage = new Coin[storage.length];
-		nextIndex = 0;
-		notifyCoinsUnloaded();
-
-		return coins;
-	}
-
-	/**
-	 * Causes the indicated coin to be added to the storage unit. If successful, a
-	 * "coinAdded" event is announced to its observers. If a successful coin
-	 * addition instead causes the unit to become full, a "coinsFull" event is
-	 * announced to its observers.
-	 * <p>
-	 * This operation is not permissible during the configuration phase.
-	 * 
-	 * @throws DisabledException
-	 *             If the unit is currently disabled.
-	 * @throws SimulationException
-	 *             If coin is null.
-	 * @throws OverloadException
-	 *             If the unit is already full.
-	 */
-	public void accept(Coin coin) throws DisabledException, OverloadException {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-		if(phase == Phase.CONFIGURATION)
-			throw new SimulationException(
-				new IllegalStateException("This method may not be called during the configuration phase."));
-
-		if(isDisabled())
-			throw new DisabledException();
-
-		if(coin == null)
-			throw new SimulationException(new NullPointerException("coin is null"));
-
-		if(nextIndex < storage.length) {
-			storage[nextIndex++] = coin;
-
-			if(nextIndex == storage.length)
-				notifyCoinsFull();
-			else
-				notifyCoinAdded();
-		}
-		else
-			throw new OverloadException();
-	}
-
-	@Override
-	public boolean hasSpace() {
-		return nextIndex < storage.length;
-	}
-
-	private void notifyCoinsLoaded() {
-		for(CoinStorageUnitObserver l : observers)
-			l.coinsLoaded(this);
-	}
-
-	private void notifyCoinsUnloaded() {
-		for(CoinStorageUnitObserver l : observers)
-			l.coinsUnloaded(this);
-	}
-
-	private void notifyCoinsFull() {
-		for(CoinStorageUnitObserver l : observers)
-			l.coinsFull(this);
-	}
-
-	private void notifyCoinAdded() {
-		for(CoinStorageUnitObserver l : observers)
-			l.coinAdded(this);
-	}
-}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/CoinTray.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/CoinTray.java
deleted file mode 100644
index dabc9c3..0000000
--- a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/CoinTray.java	
+++ /dev/null
@@ -1,102 +0,0 @@
-package org.lsmr.selfcheckout.devices;
-
-import java.util.Arrays;
-import java.util.List;
-
-import org.lsmr.selfcheckout.Coin;
-import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
-import org.lsmr.selfcheckout.devices.observers.CoinTrayObserver;
-
-/**
- * Simulates the tray where dispensed coins go for the user to collect them.
- */
-public class CoinTray extends AbstractDevice<CoinTrayObserver> implements Acceptor<Coin> {
-	private Coin[] coins;
-	private int nextIndex = 0;
-
-	/**
-	 * Creates a coin tray.
-	 * 
-	 * @param capacity
-	 *            The maximum number of coins that this tray can hold without
-	 *            overflowing.
-	 * @throws SimulationException
-	 *             If the capacity is &le;0.
-	 */
-	public CoinTray(int capacity) {
-		if(capacity <= 0)
-			throw new SimulationException(new IllegalArgumentException("capacity must be positive."));
-
-		coins = new Coin[capacity];
-	}
-
-	/**
-	 * Causes the indicated coin to be added to the tray. A "coinAdded" event is
-	 * announced to observers.
-	 * <p>
-	 * This operation is not permissible during the configuration phase.
-	 * 
-	 * @param coin
-	 *            The coin to add.
-	 * @throws SimulationException
-	 *             If coin is null.
-	 * @throws OverloadException
-	 *             If the tray overflows.
-	 */
-	public void accept(Coin coin) throws OverloadException, DisabledException {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-		if(phase == Phase.CONFIGURATION)
-			throw new SimulationException(
-				new IllegalStateException("This method may not be called during the configuration phase."));
-
-		if(coin == null)
-			throw new SimulationException(
-				new NullPointerException("coin is null, which has no analogue in the real world."));
-
-		if(nextIndex < coins.length) {
-			coins[nextIndex++] = coin;
-			notifyCoinAdded();
-		}
-		else
-			throw new OverloadException("The tray has overflowed.");
-	}
-
-	/**
-	 * Simulates the act of physically removing coins from the try by a user.
-	 * <p>
-	 * This operation is not permissible during the configuration phase.
-	 * 
-	 * @return The list of coins collected. May not be null. May be empty.
-	 */
-	public List<Coin> collectCoins() {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-		if(phase == Phase.CONFIGURATION)
-			throw new SimulationException(
-				new IllegalStateException("This method may not be called during the configuration phase."));
-
-		List<Coin> result = Arrays.asList(coins);
-
-		coins = new Coin[coins.length];
-		nextIndex = 0;
-
-		return result;
-	}
-
-	/**
-	 * Returns whether this coin receptacle has enough space to accept at least one
-	 * more coin: always true. Causes no events.
-	 */
-	@Override
-	public boolean hasSpace() {
-		return nextIndex < coins.length;
-	}
-
-	private void notifyCoinAdded() {
-		for(CoinTrayObserver l : observers)
-			l.coinAdded(this);
-	}
-}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/CoinValidator.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/CoinValidator.java
deleted file mode 100644
index faf47e3..0000000
--- a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/CoinValidator.java	
+++ /dev/null
@@ -1,268 +0,0 @@
-package org.lsmr.selfcheckout.devices;
-
-import java.math.BigDecimal;
-import java.util.Collections;
-import java.util.Currency;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Map;
-import java.util.Random;
-
-import org.lsmr.selfcheckout.Coin;
-import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
-import org.lsmr.selfcheckout.devices.observers.CoinValidatorObserver;
-
-/**
- * Represents a device for optically and/or physically validating coins. Coins
- * deemed valid are moved to storage; coins deemed invalid are ejected.
- */
-public final class CoinValidator extends AbstractDevice<CoinValidatorObserver> implements Acceptor<Coin> {
-	public final Currency currency;
-	private List<BigDecimal> denominations;
-	private UnidirectionalChannel<Coin> rejectionSink, overflowSink;
-	private Map<BigDecimal, UnidirectionalChannel<Coin>> standardSinks = null;
-
-	/**
-	 * Creates a coin validator that recognizes coins of the specified denominations
-	 * (i.e., values) and currency.
-	 * 
-	 * @param currency
-	 *            The kind of currency to accept.
-	 * @param denominations
-	 *            An array of the valid coin denominations (like $0.05, $0.10, etc.)
-	 *            to accept. Each value must be &gt;0 and unique in this array.
-	 * @throws SimulationException
-	 *             If either argument is null.
-	 * @throws SimulationException
-	 *             If the denominations array does not contain at least one value.
-	 * @throws SimulationException
-	 *             If any value in the denominations array is non-positive.
-	 * @throws SimulationException
-	 *             If any value in the denominations array is non-unique.
-	 */
-	public CoinValidator(Currency currency, List<BigDecimal> denominations) {
-		if(currency == null)
-			throw new SimulationException(
-				new NullPointerException("currency is null, which has no analogue in the real world."));
-
-		if(denominations == null)
-			throw new SimulationException(
-				new NullPointerException("denominations is null, which has no analogue in the real world."));
-
-		if(denominations.size() < 1)
-			throw new SimulationException(new IllegalArgumentException("There must be at least one denomination."));
-
-		this.currency = currency;
-		Collections.sort(denominations);
-
-		standardSinks = new HashMap<>();
-
-		for(BigDecimal denomination : denominations) {
-			if(denomination == null)
-				throw new SimulationException(new NullPointerException("A denomination is null"));
-
-			if(denomination.compareTo(BigDecimal.ZERO) <= 0)
-				throw new SimulationException(
-					new IllegalArgumentException("Non-positive denomination detected: " + denomination + "."));
-
-			if(standardSinks.containsKey(denomination))
-				throw new SimulationException(new IllegalArgumentException(
-					"Each denomination must be unique, but " + denomination + " is repeated."));
-
-			standardSinks.put(denomination, null);
-		}
-
-		this.denominations = denominations;
-	}
-
-	/**
-	 * Connects input and output channels to the coin slot. Causes no events.
-	 * <p>
-	 * This operation is permissible only during the configuration phase.
-	 * 
-	 * @param rejectionSink
-	 *            The channel to which rejected coins are routed.
-	 * @param overflowSink
-	 *            The channel to which valid coins are routed when the normal sink
-	 *            is full.
-	 * @param standardSinks
-	 *            The channels to which valid coins are normally routed. There must
-	 *            be one sink to correspond to each valid currency denomination, and
-	 *            they must be in the same order as the valid denominations.
-	 * @throws SimulationException
-	 *             If any argument is null.
-	 * @throws SimulationException
-	 *             If any standard sink is null.
-	 * @throws SimulationException
-	 *             If the number of standard sinks differs from the number of
-	 *             denominations.
-	 * @throws SimulationException
-	 *             If any sink is used in more than one position.
-	 */
-	public void connect(UnidirectionalChannel<Coin> rejectionSink,
-		Map<BigDecimal, UnidirectionalChannel<Coin>> standardSinks, UnidirectionalChannel<Coin> overflowSink) {
-		if(phase != Phase.CONFIGURATION)
-			throw new SimulationException(
-				new IllegalStateException("This method may only be called during the configuration phase."));
-
-		if(rejectionSink == null)
-			throw new SimulationException(
-				new NullPointerException("rejectionSink is null, which has no analogue in the real world."));
-
-		if(overflowSink == null)
-			throw new SimulationException(
-				new NullPointerException("overflowSink is null, which has no analogue in the real world."));
-
-		if(standardSinks == null)
-			throw new SimulationException(
-				new NullPointerException("standardSinks is null, which has no analogue in the real world."));
-
-		if(standardSinks.keySet().size() != denominations.size())
-			throw new SimulationException(
-				new IllegalArgumentException("The number of standard sinks must equal the number of denominations."));
-
-		this.rejectionSink = rejectionSink;
-		this.overflowSink = overflowSink;
-
-		HashSet<UnidirectionalChannel<Coin>> set = new HashSet<>();
-
-		for(BigDecimal denomination : standardSinks.keySet()) {
-			UnidirectionalChannel<Coin> sink = standardSinks.get(denomination);
-			if(sink == null)
-				throw new SimulationException(
-					new NullPointerException("The sink for denomination " + denomination + " is null."));
-			else {
-				if(set.contains(sink))
-					throw new SimulationException(new IllegalArgumentException("Each channel must be unique."));
-
-				set.add(sink);
-			}
-		}
-
-		this.standardSinks = standardSinks;
-
-		if(set.contains(rejectionSink))
-			throw new SimulationException(new IllegalArgumentException("Each channel must be unique."));
-		else
-			set.add(rejectionSink);
-
-		if(set.contains(overflowSink))
-			throw new SimulationException(new IllegalArgumentException("Each channel must be unique."));
-
-		this.overflowSink = overflowSink;
-	}
-
-	private final Random pseudoRandomNumberGenerator = new Random();
-	private static final int PROBABILITY_OF_FALSE_REJECTION = 1; /* out of 100 */
-
-	private boolean isValid(Coin coin) {
-		if(currency.equals(coin.getCurrency()))
-			for(BigDecimal denomination : denominations)
-				if(denomination.equals(coin.getValue()))
-					return pseudoRandomNumberGenerator.nextInt(100) >= PROBABILITY_OF_FALSE_REJECTION;
-
-		return false;
-	}
-
-	/**
-	 * Tells the coin validator that the indicated coin is being inserted. If the
-	 * coin is valid, a "validCoinDetected" event is announced to its observers;
-	 * otherwise, an "invalidCoinDetected" event is announced to its observers.
-	 * <p>
-	 * If there is space in the machine to store a valid coin, it is passed to the
-	 * sink channel corresponding to the denomination of the coin.
-	 * </p>
-	 * <p>
-	 * If there is no space in the machine to store it or the coin is invalid, the
-	 * coin is ejected to the source.
-	 * </p>
-	 * <p>
-	 * This operation is not permissible during the configuration phase.
-	 * 
-	 * @param coin
-	 *            The coin to be added. Cannot be null.
-	 * @throws DisabledException
-	 *             if the coin validator is currently disabled.
-	 * @throws SimulationException
-	 *             If the coin is null.
-	 * @throws SimulationException
-	 *             If the coin cannot be delivered.
-	 */
-	public void accept(Coin coin) throws DisabledException {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-		if(phase == Phase.CONFIGURATION)
-			throw new SimulationException(
-				new IllegalStateException("This method may not be called during the configuration phase."));
-
-		if(isDisabled())
-			throw new DisabledException();
-
-		if(coin == null)
-			throw new SimulationException(
-				new NullPointerException("coin is null, which has no analogue in the real world."));
-
-		if(isValid(coin)) {
-			notifyValidCoinDetected(coin);
-
-			UnidirectionalChannel<Coin> sink = standardSinks.get(coin.getValue());
-
-			if(sink.hasSpace()) {
-				try {
-					sink.deliver(coin);
-				}
-				catch(OverloadException e) {
-					// Should never happen
-					phase = Phase.ERROR;
-					throw new SimulationException(e);
-				}
-			}
-			else {
-				try {
-					rejectionSink.deliver(coin);
-				}
-				catch(OverloadException e) {
-					// Should never happen
-					phase = Phase.ERROR;
-					throw new SimulationException(e);
-				}
-			}
-		}
-		else {
-			notifyInvalidCoinDetected(coin);
-
-			try {
-				rejectionSink.deliver(coin);
-			}
-			catch(OverloadException e) {
-				// Should never happen
-				phase = Phase.ERROR;
-				throw new SimulationException(e);
-			}
-		}
-	}
-
-	@Override
-	public boolean hasSpace() {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-		if(phase == Phase.CONFIGURATION)
-			throw new SimulationException(
-				new IllegalStateException("This method may not be called during the configuration phase."));
-
-		return true; // Since we cannot know yet where a coin will route, assume that it is OK.
-	}
-
-	private void notifyValidCoinDetected(Coin coin) {
-		for(CoinValidatorObserver observer : observers)
-			observer.validCoinDetected(this, coin.getValue());
-	}
-
-	private void notifyInvalidCoinDetected(Coin coin) {
-		for(CoinValidatorObserver observer : observers)
-			observer.invalidCoinDetected(this);
-	}
-}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/DisabledException.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/DisabledException.java
deleted file mode 100644
index 6f1690f..0000000
--- a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/DisabledException.java	
+++ /dev/null
@@ -1,8 +0,0 @@
-package org.lsmr.selfcheckout.devices;
-
-/**
- * Issued when a device cannot perform its usual functions because it has been
- * disabled.
- */
-@SuppressWarnings("serial")
-public class DisabledException extends Exception {}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/ElectronicScale.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/ElectronicScale.java
deleted file mode 100644
index ffdc112..0000000
--- a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/ElectronicScale.java	
+++ /dev/null
@@ -1,171 +0,0 @@
-package org.lsmr.selfcheckout.devices;
-
-import java.util.ArrayList;
-
-import org.lsmr.selfcheckout.Item;
-import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
-import org.lsmr.selfcheckout.devices.observers.ElectronicScaleObserver;
-
-public class ElectronicScale extends AbstractDevice<ElectronicScaleObserver> {
-	private ArrayList<Item> items = new ArrayList<>();
-
-	private double weightLimitInGrams;
-	private double currentWeightInGrams = 0;
-	private double weightAtLastEvent = 0;
-	private double sensitivity;
-
-	/**
-	 * Constructs an electronic scale with the indicated maximum weight that it can
-	 * handle before going into overload.
-	 * 
-	 * @param weightLimitInGrams
-	 *            The weight threshold beyond which the scale will overload.
-	 * @param sensitivity
-	 *            The number of grams that can be added or removed since the last
-	 *            change event, without causing a new change event.
-	 * @throws SimulationException
-	 *             If either argument is &le;0.
-	 */
-	public ElectronicScale(int weightLimitInGrams, int sensitivity) {
-		if(weightLimitInGrams <= 0)
-			throw new SimulationException(new IllegalArgumentException("The maximum weight cannot be zero or less."));
-
-		if(sensitivity <= 0)
-			throw new SimulationException(new IllegalArgumentException("The sensitivity cannot be zero or less."));
-
-		this.weightLimitInGrams = weightLimitInGrams;
-		this.sensitivity = sensitivity;
-	}
-
-	/**
-	 * Gets the weight limit for the scale.
-	 * <p>
-	 * This operation is permissible during the configuration phase.
-	 * 
-	 * @return The weight limit.
-	 */
-	public double getWeightLimit() {
-		return weightLimitInGrams;
-	}
-
-	/**
-	 * Gets the current weight on the scale.
-	 * <p>
-	 * This operation is not permissible during the configuration phase.
-	 * 
-	 * @return The current weight.
-	 * @throws OverloadException
-	 *             If the weight has overloaded the scale.
-	 */
-	public double getCurrentWeight() throws OverloadException {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-		if(phase == Phase.CONFIGURATION)
-			throw new SimulationException(
-				new IllegalStateException("This method may not be called during the configuration phase."));
-
-		if(currentWeightInGrams <= weightLimitInGrams)
-			return currentWeightInGrams;
-
-		throw new OverloadException();
-	}
-
-	/**
-	 * Gets the sensitivity of the scale. Changes smaller than this limit are not
-	 * noticed or announced.
-	 * <p>
-	 * This operation is permissible during the configuration phase.
-	 * 
-	 * @return The sensitivity.
-	 */
-	public double getSensitivity() {
-		return sensitivity;
-	}
-
-	/**
-	 * Adds an item to the scale.
-	 * <p>
-	 * This operation is not permissible during the configuration phase.
-	 * 
-	 * @param item
-	 *            The item to add.
-	 * @throws SimulationException
-	 *             If the same item is added more than once.
-	 */
-	public void add(Item item) {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-		if(phase == Phase.CONFIGURATION)
-			throw new SimulationException(
-				new IllegalStateException("This method may not be called during the configuration phase."));
-
-		if(items.contains(item))
-			throw new SimulationException("The same item cannot be added more than once to the scale.");
-
-		currentWeightInGrams += item.getWeight();
-
-		items.add(item);
-
-		if(currentWeightInGrams > weightLimitInGrams)
-			notifyOverload();
-		else if(currentWeightInGrams - weightAtLastEvent > sensitivity)
-			notifyWeightChanged();
-	}
-
-	/**
-	 * Removes an item from the scale.
-	 * <p>
-	 * This operation is not permissible during the configuration phase.
-	 * 
-	 * @param item
-	 *            The item to remove.
-	 * @throws SimulationException
-	 *             If the item is not on the scale.
-	 */
-	public void remove(Item item) {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-		if(phase == Phase.CONFIGURATION)
-			throw new SimulationException(
-				new IllegalStateException("This method may not be called during the configuration phase."));
-
-		if(!items.remove(item))
-			throw new SimulationException("The item was not found amongst those on the scale.");
-
-		// To avoid drift in the sum due to round-off error, recalculate the weight.
-		double newWeightInGrams = 0.0;
-		for(Item itemOnScale : items)
-			newWeightInGrams += itemOnScale.getWeight();
-
-		double original = currentWeightInGrams;
-		currentWeightInGrams = newWeightInGrams;
-
-		if(original > weightLimitInGrams && newWeightInGrams <= weightLimitInGrams)
-			notifyOutOfOverload();
-
-		if(currentWeightInGrams <= weightLimitInGrams && weightAtLastEvent - currentWeightInGrams >= sensitivity)
-			notifyWeightChanged();
-	}
-
-	private void notifyOverload() {
-		for(ElectronicScaleObserver l : observers)
-			l.overload(this);
-	}
-
-	private void notifyOutOfOverload() {
-		weightAtLastEvent = currentWeightInGrams;
-
-		for(ElectronicScaleObserver l : observers)
-			l.outOfOverload(this);
-	}
-
-	private void notifyWeightChanged() {
-		weightAtLastEvent = currentWeightInGrams;
-
-		for(ElectronicScaleObserver l : observers)
-			l.weightChanged(this, currentWeightInGrams);
-	}
-}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/Emitter.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/Emitter.java
deleted file mode 100644
index a8ab600..0000000
--- a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/Emitter.java	
+++ /dev/null
@@ -1,12 +0,0 @@
-package org.lsmr.selfcheckout.devices;
-
-import org.lsmr.selfcheckout.Coin;
-
-/**
- * A simple base interface for devices that emit things.
- * 
- * @param <T>
- *            The type of the things to emit.
- */
-public interface Emitter<T> {
-}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/EmptyException.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/EmptyException.java
deleted file mode 100644
index b726903..0000000
--- a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/EmptyException.java	
+++ /dev/null
@@ -1,9 +0,0 @@
-package org.lsmr.selfcheckout.devices;
-
-/**
- * Represents the situation when a device is emptied but an attempt is made to
- * remove something from it.
- */
-public class EmptyException extends Exception {
-	private static final long serialVersionUID = 3566954386000387724L;
-}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/FlowThroughEmitter.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/FlowThroughEmitter.java
deleted file mode 100644
index ff60458..0000000
--- a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/FlowThroughEmitter.java	
+++ /dev/null
@@ -1,26 +0,0 @@
-package org.lsmr.selfcheckout.devices;
-
-import org.lsmr.selfcheckout.Coin;
-
-/**
- * A simple interface for devices that emit things.
- * 
- * @param <T>
- *            The type of the things to emit.
- */
-public interface FlowThroughEmitter<T> {
-	/**
-	 * Instructs the device to emit a specific thing, meaning that the device is
-	 * being handed this thing to pass onwards.
-	 * <p>
-	 * This operation is not permissible during the configuration phase.
-	 * 
-	 * @param thing
-	 *            The thing to emit.
-	 * @throws DisabledException
-	 *             If the device is disabled.
-	 * @throws OverloadException
-	 *             If the receiving device is already full.
-	 */
-	public void emit(T thing) throws DisabledException, OverloadException;
-}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/FromStorageEmitter.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/FromStorageEmitter.java
deleted file mode 100644
index ddb964a..0000000
--- a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/FromStorageEmitter.java	
+++ /dev/null
@@ -1,26 +0,0 @@
-package org.lsmr.selfcheckout.devices;
-
-import org.lsmr.selfcheckout.Coin;
-
-/**
- * A simple interface for devices that emit things.
- * 
- * @param <T>
- *            The type of the things to emit.
- */
-public interface FromStorageEmitter<T> {
-	/**
-	 * Instructs the device to emit one thing, meaning that the device stores a set
-	 * of things and one of them is to be emitted.
-	 * <p>
-	 * This operation is not permissible during the configuration phase.
-	 * 
-	 * @throws DisabledException
-	 *             If the device is disabled.
-	 * @throws EmptyException
-	 *             If the device is empty and cannot emit.
-	 * @throws OverloadException
-	 *             If the receiving device is already full.
-	 */
-	public void emit() throws DisabledException, EmptyException, OverloadException;
-}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/OverloadException.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/OverloadException.java
deleted file mode 100644
index ee5e927..0000000
--- a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/OverloadException.java	
+++ /dev/null
@@ -1,24 +0,0 @@
-package org.lsmr.selfcheckout.devices;
-
-/**
- * Represents situations where a device has been overloaded, in terms of weight,
- * quantity of items, etc.
- */
-public class OverloadException extends Exception {
-	private static final long serialVersionUID = 7813659161520664284L;
-
-	/**
-	 * Create an exception without an error message.
-	 */
-	public OverloadException() {}
-
-	/**
-	 * Create an exception with an error message.
-	 * 
-	 * @param message
-	 *            The error message to use.
-	 */
-	public OverloadException(String message) {
-		super(message);
-	}
-}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/ReceiptPrinter.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/ReceiptPrinter.java
deleted file mode 100644
index 9f2abe6..0000000
--- a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/ReceiptPrinter.java	
+++ /dev/null
@@ -1,204 +0,0 @@
-package org.lsmr.selfcheckout.devices;
-
-import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
-import org.lsmr.selfcheckout.devices.observers.ReceiptPrinterObserver;
-
-/**
- * Represents printers used for printing receipts. A printer has a finite amount
- * of paper (measured in lines that can be printed) and ink (measured in
- * characters that can be printed).
- * <p>
- * Since this is a simulation, each character is assumed to require the same
- * amount of ink (except blanks and newlines) and the font size is fixed.
- * </p>
- */
-public class ReceiptPrinter extends AbstractDevice<ReceiptPrinterObserver> {
-	public static final int MAXIMUM_INK = 1 << 20;
-	public static final int MAXIMUM_PAPER = 1 << 10;
-	private int charactersOfInkRemaining = 0;
-	private int linesOfPaperRemaining = 0;
-	private StringBuilder sb = new StringBuilder();
-	private int charactersOnCurrentLine = 0;
-
-	/**
-	 * Represents the maximum number of characters that can fit on one line of the
-	 * receipt. This is a simulation, so the font is assumed monospaced and of fixed
-	 * size.
-	 */
-	public final static int CHARACTERS_PER_LINE = 60;
-
-	/**
-	 * Creates a receipt printer.
-	 */
-	public ReceiptPrinter() {}
-
-	/**
-	 * Prints a single character to the receipt. Whitespace characters are ignored,
-	 * with the exception of ' ' (blank) and '\n', which signals to move to the
-	 * start of the next line.
-	 * <p>
-	 * This operation is not permissible during the configuration phase.
-	 * 
-	 * @param c
-	 *            The character to print.
-	 * @throws SimulationException
-	 *             If there is no ink or no paper in the printer.
-	 * @throws SimulationException
-	 *             If the extra character would spill off the end of the line.
-	 */
-	public void print(char c) {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-		if(phase == Phase.CONFIGURATION)
-			throw new SimulationException(
-				new IllegalStateException("This method may not be called during the configuration phase."));
-
-		if(c == '\n') {
-			--linesOfPaperRemaining;
-			charactersOnCurrentLine = 0;
-		}
-		else if(c != ' ' && Character.isWhitespace(c))
-			return;
-		else if(charactersOnCurrentLine == CHARACTERS_PER_LINE)
-			throw new SimulationException("The line is too long. Add a newline");
-		else if(linesOfPaperRemaining == 0)
-			throw new SimulationException("There is no paper in the printer.");
-		else
-			charactersOnCurrentLine++;
-
-		if(!Character.isWhitespace(c)) {
-			if(charactersOfInkRemaining == 0)
-				throw new SimulationException("There is no ink in the printer");
-
-			charactersOfInkRemaining--;
-		}
-
-		sb.append(c);
-
-		if(charactersOfInkRemaining == 0)
-			notifyOutOfInk();
-
-		if(linesOfPaperRemaining == 0)
-			notifyOutOfPaper();
-	}
-
-	/**
-	 * The receipt is finished printing, so cut it so that the customer can easily
-	 * remove it. Failure to cut the paper means that the receipt will not be
-	 * retrievable by the customer.
-	 * <p>
-	 * This operation is not permissible during the configuration phase.
-	 */
-	public void cutPaper() {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-		if(phase == Phase.CONFIGURATION)
-			throw new SimulationException(
-				new IllegalStateException("This method may not be called during the configuration phase."));
-
-		lastReceipt = sb.toString();
-	}
-
-	private String lastReceipt = null;
-
-	/**
-	 * Simulates the customer removing the receipt. Failure to cut the receipt
-	 * first, or to always remove the receipt means that the customer will end up
-	 * with other customers' receipts too!
-	 * 
-	 * @return The receipt if it has been cut; otherwise, null.
-	 */
-	public String removeReceipt() {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-		if(phase == Phase.CONFIGURATION)
-			throw new SimulationException(
-				new IllegalStateException("This method may not be called during the configuration phase."));
-
-		String receipt = lastReceipt;
-
-		if(lastReceipt != null) {
-			lastReceipt = null;
-			sb = new StringBuilder();
-		}
-		else
-			throw new SimulationException("A non-existent receipt cannot be removed.");
-
-		return receipt;
-	}
-
-	/**
-	 * Adds ink to the printer. Simulates a human doing the adding.
-	 * <p>
-	 * This operation is permissible during the configuration phase.
-	 * 
-	 * @param quantity
-	 *            The quantity of characters-worth of ink to add.
-	 * @throws SimulationException
-	 *             If the quantity is negative.
-	 * @throws SimulationException
-	 *             If the total of the existing ink plus the added quantity is
-	 *             greater than the printer's capacity.
-	 */
-	public void addInk(int quantity) {
-		if(quantity < 0)
-			throw new SimulationException("Are you trying to remove ink?");
-
-		if(charactersOfInkRemaining + quantity > MAXIMUM_INK)
-			throw new SimulationException("You spilled a bunch of ink!");
-
-		if(quantity > 0) {
-			charactersOfInkRemaining += quantity;
-			notifyInkAdded();
-		}
-	}
-
-	/**
-	 * Adds paper to the printer. Simulates a human doing the adding.
-	 * <p>
-	 * This operation is permissible during the configuration phase.
-	 * 
-	 * @param quantity
-	 *            The quantity of lines-worth of paper to add.
-	 * @throws SimulationException
-	 *             If the quantity is negative.
-	 * @throws SimulationException
-	 *             If the total of the existing paper plus the added quantity is
-	 *             greater than the printer's capacity.
-	 */
-	public void addPaper(int units) {
-		if(units < 0)
-			throw new SimulationException("Are you trying to remove paper?");
-
-		if(linesOfPaperRemaining + units > MAXIMUM_PAPER)
-			throw new SimulationException("You may have broken the printer, jamming so much in there!");
-
-		if(units > 0) {
-			linesOfPaperRemaining += units;
-			notifyPaperAdded();
-		}
-	}
-
-	private void notifyOutOfInk() {
-		for(ReceiptPrinterObserver l : observers)
-			l.outOfInk(this);
-	}
-
-	private void notifyInkAdded() {
-		for(ReceiptPrinterObserver l : observers)
-			l.inkAdded(this);
-	}
-
-	private void notifyOutOfPaper() {
-		for(ReceiptPrinterObserver l : observers)
-			l.outOfPaper(this);
-	}
-
-	private void notifyPaperAdded() {
-		for(ReceiptPrinterObserver l : observers)
-			l.paperAdded(this);
-	}
-}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/SelfCheckoutStation.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/SelfCheckoutStation.java
deleted file mode 100644
index edb9a0c..0000000
--- a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/SelfCheckoutStation.java	
+++ /dev/null
@@ -1,257 +0,0 @@
-package org.lsmr.selfcheckout.devices;
-
-import java.math.BigDecimal;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Currency;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-
-import javax.sound.sampled.AudioSystem;
-
-import org.lsmr.selfcheckout.Banknote;
-import org.lsmr.selfcheckout.Coin;
-
-/**
- * Simulates the overall self-checkout station.
- * <p>
- * A self-checkout possesses the following units of hardware that the customer
- * can see and interact with:
- * <ul>
- * <li>one electronic scale, with a configurable maximum weight before it
- * overloads;</li>
- * <li>one receipt printer;</li>
- * <li>one card reader;</li>
- * <li>one scanner;</li>
- * <li>one input slot for banknotes;</li>
- * <li>one output slot for banknotes;</li>
- * <li>one input slot for coins;</li>
- * <li>one output tray for coins; and,</li>
- * <li>one speaker for audio output (note: you should directly use the
- * {@link AudioSystem} class, if you want to produce sounds).</li>
- * </ul>
- * </p>
- * <p>
- * In addition, these units of hardware are accessible to personnel with a key
- * to unlock the front of the station:
- * <li>one banknote storage unit, with configurable capacity;</li>
- * <li>one or more banknote dispensers, one for each supported denomination of
- * banknote, as configured;</li>
- * <li>one coin storage unit, with configurable capacity; and,</li>
- * <li>one or more coin dispensers, one for each supported denomination of coin,
- * as configured.</li>
- * </ul>
- * </p>
- * <p>
- * And finally, there are certain, additional units of hardware that would only
- * be accessible to someone with the appropriate tools (like a screwdriver,
- * crowbar, or sledge hammer):
- * <ul>
- * <li>one banknote validator; and</li>
- * <li>one coin validator.</li>
- * </ul>
- * </p>
- * <p>
- * Many of these devices are interconnected, to permit coins or banknotes to
- * pass between them. Specifically:
- * <ul>
- * <li>the coin slot is connected to the coin validator (this is a
- * one-directional chain of devices);</li>
- * <li>the coin validator is connected to each of the coin dispensers (i.e., the
- * coin dispensers can be replenished with coins entered by customers), to the
- * coin storage unit (for any overflow coins that do not fit in the dispensers),
- * and to the coin tray for any rejected coins either because the coins are
- * invalid or because even the overflow storage unit is full (this is a
- * one-directional chain of devices);
- * <li>each coin dispenser is connected to the coin tray, to provide change
- * (this is a one-directional chain of devices);</li>
- * <li>the banknote input slot is connected to the banknote validator (this is a
- * <b>two</b>-directional chain of devices as an entered banknotes that are
- * rejected by the validator can be returned to the customer);</li>
- * <li>the banknote validator is connected to the banknote storage unit (this is
- * a one-directional chain of devices); and,</li>
- * <li>each banknote dispenser is connected to the output banknote slot; these
- * dispensers cannot be replenished by banknotes provided by customers (this is
- * a one-directional chain of devices).</li>
- * </ul>
- * </p>
- * <p>
- * All other functionality of the system must be performed in software,
- * installed on the self-checkout station through custom observer classes
- * implementing the various observer interfaces provided.
- * </p>
- * <p>
- * Note that banknote denominations are required to be positive integers, while
- * coin denominations are positive decimal values ({@link BigDecimal} is used
- * for the latter to avoid roundoff problems arising from floating-point
- * operations).
- */
-public class SelfCheckoutStation {
-	public final ElectronicScale scale;
-	public final ReceiptPrinter printer;
-	public final CardReader cardReader;
-	public final BarcodeScanner scanner;
-
-	public final BanknoteSlot banknoteInput, banknoteOutput;
-	public final BanknoteValidator banknoteValidator;
-	public final BanknoteStorageUnit banknoteStorage;
-	public final static int BANKNOTE_STORAGE_CAPACITY = 1000;
-	public final int[] banknoteDenominations;
-	public final Map<Integer, BanknoteDispenser> banknoteDispensers;
-	public final static int BANKNOTE_DISPENSER_CAPACITY = 100;
-
-	public final CoinSlot coinSlot;
-	public final CoinValidator coinValidator;
-	public final CoinStorageUnit coinStorage;
-	public static final int COIN_STORAGE_CAPACITY = 1000;
-	public final List<BigDecimal> coinDenominations;
-	public final Map<BigDecimal, CoinDispenser> coinDispensers;
-	public static final int COIN_DISPENSER_CAPACITY = 200;
-	public final CoinTray coinTray;
-	public static final int COIN_TRAY_CAPACITY = 20;
-
-	/**
-	 * Creates a self-checkout station.
-	 * 
-	 * @param currency
-	 *            The kind of currency permitted.
-	 * @param banknoteDenominations
-	 *            The set of denominations (i.e., $5, $10, etc.) to accept.
-	 * @param coinDenominations
-	 *            The set of denominations (i.e., $0.05, $0.10, etc.) to accept.
-	 * @param scaleMaximumWeight
-	 *            The most weight that can be placed on the scale before it
-	 *            overloads.
-	 * @param scaleSensitivity
-	 *            Any weight changes smaller than this will not be detected or
-	 *            announced.
-	 * @throws SimulationException
-	 *             If any argument is null or negative.
-	 * @throws SimulationException
-	 *             If the number of banknote or coin denominations is &lt;1.
-	 */
-	public SelfCheckoutStation(Currency currency, int[] banknoteDenominations, BigDecimal[] coinDenominations,
-		int scaleMaximumWeight, int scaleSensitivity) {
-		if(currency == null || banknoteDenominations == null || coinDenominations == null)
-			throw new SimulationException(new NullPointerException("No argument may be null."));
-
-		if(scaleMaximumWeight <= 0)
-			throw new SimulationException(new IllegalArgumentException("The scale's maximum weight must be positive."));
-
-		if(scaleSensitivity <= 0)
-			throw new SimulationException(new IllegalArgumentException("The scale's sensitivity must be positive."));
-
-		if(banknoteDenominations.length == 0)
-			throw new SimulationException(
-				new IllegalArgumentException("There must be at least one allowable banknote denomination defined."));
-
-		if(coinDenominations.length == 0)
-			throw new SimulationException(
-				new IllegalArgumentException("There must be at least one allowable coin denomination defined."));
-
-		// Create the devices.
-		scale = new ElectronicScale(scaleMaximumWeight, scaleSensitivity);
-		printer = new ReceiptPrinter();
-		cardReader = new CardReader();
-		scanner = new BarcodeScanner();
-
-		this.banknoteDenominations = banknoteDenominations;
-		banknoteInput = new BanknoteSlot(false);
-		banknoteValidator = new BanknoteValidator(currency, banknoteDenominations);
-		banknoteStorage = new BanknoteStorageUnit(BANKNOTE_STORAGE_CAPACITY);
-		banknoteOutput = new BanknoteSlot(true);
-
-		banknoteDispensers = new HashMap<>();
-
-		for(int i = 0; i < banknoteDenominations.length; i++)
-			banknoteDispensers.put(banknoteDenominations[i], new BanknoteDispenser(BANKNOTE_DISPENSER_CAPACITY));
-
-		this.coinDenominations = Arrays.asList(coinDenominations);
-		coinSlot = new CoinSlot();
-		coinValidator = new CoinValidator(currency, this.coinDenominations);
-		coinStorage = new CoinStorageUnit(COIN_STORAGE_CAPACITY);
-		coinTray = new CoinTray(COIN_TRAY_CAPACITY);
-
-		coinDispensers = new HashMap<>();
-
-		for(int i = 0; i < coinDenominations.length; i++)
-			coinDispensers.put(coinDenominations[i], new CoinDispenser(COIN_DISPENSER_CAPACITY));
-
-		// Hook up everything.
-		interconnect(banknoteInput, banknoteValidator);
-		interconnect(banknoteValidator, banknoteStorage);
-
-		for(BanknoteDispenser dispenser : banknoteDispensers.values())
-			interconnect(dispenser, banknoteOutput);
-
-		interconnect(coinSlot, coinValidator);
-		interconnect(coinValidator, coinTray, coinDispensers, coinStorage);
-
-		for(CoinDispenser coinDispenser : coinDispensers.values())
-			interconnect(coinDispenser, coinTray);
-
-		scale.endConfigurationPhase();
-		printer.endConfigurationPhase();
-		cardReader.endConfigurationPhase();
-		scanner.endConfigurationPhase();
-
-		banknoteInput.endConfigurationPhase();
-		banknoteValidator.endConfigurationPhase();
-		banknoteStorage.endConfigurationPhase();
-		banknoteOutput.endConfigurationPhase();
-
-		for(BanknoteDispenser bd : banknoteDispensers.values())
-			bd.endConfigurationPhase();
-
-		coinSlot.endConfigurationPhase();
-		coinValidator.endConfigurationPhase();
-		coinStorage.endConfigurationPhase();
-		coinTray.endConfigurationPhase();
-
-		for(CoinDispenser cd : coinDispensers.values())
-			cd.endConfigurationPhase();
-	}
-
-	private BidirectionalChannel<Banknote> validatorSource;
-
-	private void interconnect(BanknoteSlot slot, BanknoteValidator validator) {
-		validatorSource = new BidirectionalChannel<Banknote>(slot, validator);
-		slot.connect(validatorSource);
-	}
-
-	private void interconnect(BanknoteValidator validator, BanknoteStorageUnit storage) {
-		UnidirectionalChannel<Banknote> bc = new UnidirectionalChannel<Banknote>(storage);
-		validator.connect(validatorSource, bc);
-	}
-
-	private void interconnect(BanknoteDispenser dispenser, BanknoteSlot slot) {
-		UnidirectionalChannel<Banknote> bc = new UnidirectionalChannel<Banknote>(slot);
-		dispenser.connect(bc);
-	}
-
-	private void interconnect(CoinSlot slot, CoinValidator validator) {
-		UnidirectionalChannel<Coin> cc = new UnidirectionalChannel<Coin>(validator);
-		slot.connect(cc);
-	}
-
-	private void interconnect(CoinValidator validator, CoinTray tray, Map<BigDecimal, CoinDispenser> dispensers,
-		CoinStorageUnit storage) {
-		UnidirectionalChannel<Coin> rejectChannel = new UnidirectionalChannel<Coin>(tray);
-		Map<BigDecimal, UnidirectionalChannel<Coin>> dispenserChannels = new HashMap<BigDecimal, UnidirectionalChannel<Coin>>();
-
-		for(BigDecimal denomination : dispensers.keySet()) {
-			CoinDispenser dispenser = dispensers.get(denomination);
-			dispenserChannels.put(denomination, new UnidirectionalChannel<Coin>(dispenser));
-		}
-
-		UnidirectionalChannel<Coin> overflowChannel = new UnidirectionalChannel<Coin>(storage);
-
-		validator.connect(rejectChannel, dispenserChannels, overflowChannel);
-	}
-
-	private void interconnect(CoinDispenser dispenser, CoinTray tray) {
-		UnidirectionalChannel<Coin> cc = new UnidirectionalChannel<Coin>(tray);
-		dispenser.connect(cc);
-	}
-}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/SimulationException.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/SimulationException.java
deleted file mode 100644
index 5ef08ac..0000000
--- a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/SimulationException.java	
+++ /dev/null
@@ -1,32 +0,0 @@
-package org.lsmr.selfcheckout.devices;
-
-/**
- * An exception that can be raised when the behaviour within the simulator makes
- * no sense, typically when it has not been configured correctly. This is
- * different from an exception being raised because the preconditions of a
- * component are violated, but that would make sense in the real world.
- */
-@SuppressWarnings("serial")
-public class SimulationException extends RuntimeException {
-	private String nested;
-
-	/**
-	 * Constructor used to nest other exceptions.
-	 * 
-	 * @param nested
-	 *            An underlying exception that is to be wrapped.
-	 */
-	public SimulationException(Exception nested) {
-		this.nested = nested.toString();
-	}
-
-	/**
-	 * Basic constructor.
-	 * 
-	 * @param message
-	 *            An explanatory message of the problem.
-	 */
-	public SimulationException(String message) {
-		nested = message;
-	}
-}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/UnidirectionalChannel.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/UnidirectionalChannel.java
deleted file mode 100644
index 0174032..0000000
--- a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/UnidirectionalChannel.java	
+++ /dev/null
@@ -1,49 +0,0 @@
-package org.lsmr.selfcheckout.devices;
-
-import org.lsmr.selfcheckout.Coin;
-
-/**
- * Represents a simple device (like, say, a tube) that allows things to move in
- * one direction between other devices.
- * 
- * @param <T>
- *            The type of the things to be transported.
- */
-public class UnidirectionalChannel<T> {
-	private Acceptor<T> sink;
-
-	/**
-	 * Constructs a new coin channel whose output is connected to the indicated
-	 * sink.
-	 * 
-	 * @param sink
-	 *            The device at the output end of the channel.
-	 */
-	public UnidirectionalChannel(Acceptor<T> sink) {
-		this.sink = sink;
-	}
-
-	/**
-	 * Moves the indicated thing to the sink. This method should be called by the
-	 * source device, and not by an external application.
-	 * 
-	 * @param thing
-	 *            The thing to transport via the channel.
-	 * @throws OverloadException
-	 *             If the sink has no space for the thing.
-	 * @throws DisabledException
-	 *             If the sink is currently disabled.
-	 */
-	public void deliver(T thing) throws OverloadException, DisabledException {
-		sink.accept(thing);
-	}
-
-	/**
-	 * Returns whether the sink has space for at least one more thing.
-	 * 
-	 * @return true if the channel can accept a thing; false otherwise.
-	 */
-	public boolean hasSpace() {
-		return sink.hasSpace();
-	}
-}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/AbstractDeviceObserver.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/AbstractDeviceObserver.java
deleted file mode 100644
index ced7820..0000000
--- a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/AbstractDeviceObserver.java	
+++ /dev/null
@@ -1,26 +0,0 @@
-package org.lsmr.selfcheckout.devices.observers;
-
-import org.lsmr.selfcheckout.devices.AbstractDevice;
-
-/**
- * This class represents the abstract interface for all device observers. All
- * subclasses should add their own event notification methods, the first
- * parameter of which should always be the device affected.
- */
-public interface AbstractDeviceObserver {
-	/**
-	 * Announces that the indicated device has been enabled.
-	 * 
-	 * @param device
-	 *                 The device that has been enabled.
-	 */
-	public void enabled(AbstractDevice<? extends AbstractDeviceObserver> device);
-
-	/**
-	 * Announces that the indicated device has been disabled.
-	 * 
-	 * @param device
-	 *                 The device that has been enabled.
-	 */
-	public void disabled(AbstractDevice<? extends AbstractDeviceObserver> device);
-}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/BanknoteDispenserObserver.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/BanknoteDispenserObserver.java
deleted file mode 100644
index d4363bf..0000000
--- a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/BanknoteDispenserObserver.java	
+++ /dev/null
@@ -1,71 +0,0 @@
-package org.lsmr.selfcheckout.devices.observers;
-
-import org.lsmr.selfcheckout.Banknote;
-import org.lsmr.selfcheckout.devices.BanknoteDispenser;
-
-/**
- * Observes events emanating from a banknote dispenser.
- */
-public interface BanknoteDispenserObserver extends AbstractDeviceObserver {
-	/**
-	 * Announces that the indicated banknote dispenser is full of banknotes.
-	 * 
-	 * @param dispenser
-	 *            The dispenser where the event occurred.
-	 */
-	void moneyFull(BanknoteDispenser dispenser);
-
-	/**
-	 * Announces that the indicated banknote dispenser is empty of banknotes.
-	 * 
-	 * @param dispenser
-	 *            The dispenser where the event occurred.
-	 */
-	void banknotesEmpty(BanknoteDispenser dispenser);
-
-	/**
-	 * Announces that the indicated banknote has been added to the indicated
-	 * banknote dispenser.
-	 * 
-	 * @param dispenser
-	 *            The dispenser where the event occurred.
-	 * @param banknote
-	 *            The banknote that was added.
-	 */
-	void billAdded(BanknoteDispenser dispenser, Banknote banknote);
-
-	/**
-	 * Announces that the indicated banknote has been added to the indicated
-	 * banknote dispenser.
-	 * 
-	 * @param dispenser
-	 *            The dispenser where the event occurred.
-	 * @param banknote
-	 *            The banknote that was removed.
-	 */
-	void banknoteRemoved(BanknoteDispenser dispenser, Banknote banknote);
-
-	/**
-	 * Announces that the indicated sequence of banknotes has been added to the
-	 * indicated banknote dispenser. Used to simulate direct, physical loading of
-	 * the dispenser.
-	 * 
-	 * @param dispenser
-	 *            The dispenser where the event occurred.
-	 * @param banknotes
-	 *            The banknotes that were loaded.
-	 */
-	void banknotesLoaded(BanknoteDispenser dispenser, Banknote... banknotes);
-
-	/**
-	 * Announces that the indicated sequence of banknotes has been removed to the
-	 * indicated banknote dispenser. Used to simulate direct, physical unloading of
-	 * the dispenser.
-	 * 
-	 * @param dispenser
-	 *            The dispenser where the event occurred.
-	 * @param banknotes
-	 *            The banknotes that were unloaded.
-	 */
-	void banknotesUnloaded(BanknoteDispenser dispenser, Banknote... banknotes);
-}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/BanknoteSlotObserver.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/BanknoteSlotObserver.java
deleted file mode 100644
index 20ced82..0000000
--- a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/BanknoteSlotObserver.java	
+++ /dev/null
@@ -1,34 +0,0 @@
-package org.lsmr.selfcheckout.devices.observers;
-
-import org.lsmr.selfcheckout.Banknote;
-import org.lsmr.selfcheckout.devices.BanknoteSlot;
-
-/**
- * Observes events emanating from a banknote slot.
- */
-public interface BanknoteSlotObserver extends AbstractDeviceObserver {
-	/**
-	 * An event announcing that a banknote has been inserted.
-	 * 
-	 * @param slot
-	 *            The device on which the event occurred.
-	 */
-	void banknoteInserted(BanknoteSlot slot);
-
-	/**
-	 * An event announcing that a banknote has been returned to the user, dangling
-	 * from the slot.
-	 * 
-	 * @param slot
-	 *            The device on which the event occurred.
-	 */
-	void banknoteEjected(BanknoteSlot slot);
-
-	/**
-	 * An event announcing that a dangling banknote has been removed by the user.
-	 * 
-	 * @param slot
-	 *            The device on which the event occurred.
-	 */
-	void banknoteRemoved(BanknoteSlot slot);
-}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/BanknoteStorageUnitObserver.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/BanknoteStorageUnitObserver.java
deleted file mode 100644
index 9f17942..0000000
--- a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/BanknoteStorageUnitObserver.java	
+++ /dev/null
@@ -1,43 +0,0 @@
-package org.lsmr.selfcheckout.devices.observers;
-
-import org.lsmr.selfcheckout.Banknote;
-import org.lsmr.selfcheckout.devices.BanknoteStorageUnit;
-
-/**
- * Observes events emanating from a banknote storage unit.
- */
-public interface BanknoteStorageUnitObserver extends AbstractDeviceObserver {
-	/**
-	 * Announces that the indicated banknote storage unit is full of banknotes.
-	 * 
-	 * @param unit
-	 *            The storage unit where the event occurred.
-	 */
-	void banknotesFull(BanknoteStorageUnit unit);
-
-	/**
-	 * Announces that a banknote has been added to the indicated storage unit.
-	 * 
-	 * @param unit
-	 *            The storage unit where the event occurred.
-	 */
-	void banknoteAdded(BanknoteStorageUnit unit);
-
-	/**
-	 * Announces that the indicated storage unit has been loaded with banknotes.
-	 * Used to simulate direct, physical loading of the unit.
-	 * 
-	 * @param unit
-	 *            The storage unit where the event occurred.
-	 */
-	void banknotesLoaded(BanknoteStorageUnit unit);
-
-	/**
-	 * Announces that the storage unit has been emptied of banknotes. Used to
-	 * simulate direct, physical unloading of the unit.
-	 * 
-	 * @param unit
-	 *            The storage unit where the event occurred.
-	 */
-	void banknotesUnloaded(BanknoteStorageUnit unit);
-}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/BanknoteValidatorObserver.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/BanknoteValidatorObserver.java
deleted file mode 100644
index 583fa9d..0000000
--- a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/BanknoteValidatorObserver.java	
+++ /dev/null
@@ -1,33 +0,0 @@
-package org.lsmr.selfcheckout.devices.observers;
-
-import java.util.Currency;
-
-import org.lsmr.selfcheckout.Banknote;
-import org.lsmr.selfcheckout.devices.BanknoteValidator;
-
-/**
- * Observes events emanating from a banknote validator.
- */
-public interface BanknoteValidatorObserver extends AbstractDeviceObserver {
-	/**
-	 * An event announcing that the indicated banknote has been detected and
-	 * determined to be valid.
-	 * 
-	 * @param validator
-	 *            The device on which the event occurred.
-	 * @param currency
-	 *            The kind of currency of the inserted banknote.
-	 * @param value
-	 *            The value of the inserted banknote.
-	 */
-	void validBanknoteDetected(BanknoteValidator validator, Currency currency, int value);
-
-	/**
-	 * An event announcing that the indicated banknote has been detected and
-	 * determined to be invalid.
-	 * 
-	 * @param validator
-	 *            The device on which the event occurred.
-	 */
-	void invalidBanknoteDetected(BanknoteValidator validator);
-}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/BarcodeScannerObserver.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/BarcodeScannerObserver.java
deleted file mode 100644
index 5a73307..0000000
--- a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/BarcodeScannerObserver.java	
+++ /dev/null
@@ -1,20 +0,0 @@
-package org.lsmr.selfcheckout.devices.observers;
-
-import org.lsmr.selfcheckout.Barcode;
-import org.lsmr.selfcheckout.devices.BarcodeScanner;
-
-/**
- * Observes events emanating from a barcode scanner.
- */
-public interface BarcodeScannerObserver extends AbstractDeviceObserver {
-	/**
-	 * An event announcing that the indicated barcode has been successfully scanned.
-	 * 
-	 * @param barcodeScanner
-	 *            The device on which the event occurred.
-	 * @param barcode
-	 *            The barcode that was read by the scanner.
-	 */
-	void barcodeScanned(BarcodeScanner barcodeScanner, Barcode barcode);
-
-}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/CardReaderObserver.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/CardReaderObserver.java
deleted file mode 100644
index 9256e3a..0000000
--- a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/CardReaderObserver.java	
+++ /dev/null
@@ -1,52 +0,0 @@
-package org.lsmr.selfcheckout.devices.observers;
-
-import org.lsmr.selfcheckout.Card.CardData;
-import org.lsmr.selfcheckout.devices.CardReader;
-
-/**
- * Observes events emanating from a coin dispenser.
- */
-public interface CardReaderObserver extends AbstractDeviceObserver {
-	/**
-	 * Announces that a card has been inserted in the indicated card reader.
-	 * 
-	 * @param reader
-	 *            The reader where the event occurred.
-	 */
-	void cardInserted(CardReader reader);
-
-	/**
-	 * Announces that a card has been removed from the indicated card reader.
-	 * 
-	 * @param reader
-	 *            The reader where the event occurred.
-	 */
-	void cardRemoved(CardReader reader);
-
-	/**
-	 * Announces that a (tap-enabled) card has been tapped on the indicated card
-	 * reader.
-	 * 
-	 * @param reader
-	 *            The reader where the event occurred.
-	 */
-	void cardTapped(CardReader reader);
-
-	/**
-	 * Announces that a card has swiped on the indicated card reader.
-	 * 
-	 * @param reader
-	 *            The reader where the event occurred.
-	 */
-	void cardSwiped(CardReader reader);
-
-	/**
-	 * Announces that the data has been read from a card.
-	 * 
-	 * @param reader
-	 *            The reader where the event occurred.
-	 * @param data
-	 *            The data that was read. Note that this data may be corrupted.
-	 */
-	void cardDataRead(CardReader reader, CardData data);
-}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/CoinDispenserObserver.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/CoinDispenserObserver.java
deleted file mode 100644
index d388e06..0000000
--- a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/CoinDispenserObserver.java	
+++ /dev/null
@@ -1,67 +0,0 @@
-package org.lsmr.selfcheckout.devices.observers;
-
-import org.lsmr.selfcheckout.Coin;
-import org.lsmr.selfcheckout.devices.CoinDispenser;
-
-/**
- * Observes events emanating from a coin dispenser.
- */
-public interface CoinDispenserObserver extends AbstractDeviceObserver {
-	/**
-	 * Announces that the indicated coin dispenser is full of coins.
-	 * 
-	 * @param dispenser
-	 *             The dispenser where the event occurred.
-	 */
-	void coinsFull(CoinDispenser dispenser);
-
-	/**
-	 * Announces that the indicated coin dispenser is empty of coins.
-	 * 
-	 * @param dispenser
-	 *             The dispenser where the event occurred.
-	 */
-	void coinsEmpty(CoinDispenser dispenser);
-
-	/**
-	 * Announces that the indicated coin has been added to the indicated coin dispenser.
-	 * 
-	 * @param dispenser
-	 *             The dispenser where the event occurred.
-	 * @param coin
-	 *             The coin that was added.
-	 */
-	void coinAdded(CoinDispenser dispenser, Coin coin);
-
-	/**
-	 * Announces that the indicated coin has been added to the indicated coin dispenser.
-	 * 
-	 * @param dispenser
-	 *             The dispenser where the event occurred.
-	 * @param coin
-	 *             The coin that was removed.
-	 */
-	void coinRemoved(CoinDispenser dispenser, Coin coin);
-
-	/**
-	 * Announces that the indicated sequence of coins has been added to the
-	 * indicated coin dispenser. Used to simulate direct, physical loading of the dispenser.
-	 * 
-	 * @param dispenser
-	 *              The dispenser where the event occurred.
-	 * @param coins
-	 *              The coins that were loaded.
-	 */
-	void coinsLoaded(CoinDispenser dispenser, Coin... coins);
-
-	/**
-	 * Announces that the indicated sequence of coins has been removed to the
-	 * indicated coin dispenser. Used to simulate direct, physical unloading of the dispenser.
-	 * 
-	 * @param dispenser
-	 *              The dispenser where the event occurred.
-	 * @param coins
-	 *              The coins that were unloaded.
-	 */
-	void coinsUnloaded(CoinDispenser dispenser, Coin... coins);
-}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/CoinSlotObserver.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/CoinSlotObserver.java
deleted file mode 100644
index a091cb2..0000000
--- a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/CoinSlotObserver.java	
+++ /dev/null
@@ -1,17 +0,0 @@
-package org.lsmr.selfcheckout.devices.observers;
-
-import org.lsmr.selfcheckout.Coin;
-import org.lsmr.selfcheckout.devices.CoinSlot;
-
-/**
- * Observes events emanating from a coin slot.
- */
-public interface CoinSlotObserver extends AbstractDeviceObserver {
-	/**
-	 * An event announcing that a coin has been inserted.
-	 * 
-	 * @param slot
-	 *             The device on which the event occurred.
-	 */
-	void coinInserted(CoinSlot slot);
-}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/CoinStorageUnitObserver.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/CoinStorageUnitObserver.java
deleted file mode 100644
index 6049c36..0000000
--- a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/CoinStorageUnitObserver.java	
+++ /dev/null
@@ -1,43 +0,0 @@
-package org.lsmr.selfcheckout.devices.observers;
-
-import org.lsmr.selfcheckout.Coin;
-import org.lsmr.selfcheckout.devices.CoinStorageUnit;
-
-/**
- * Observes events emanating from a coin storage unit.
- */
-public interface CoinStorageUnitObserver extends AbstractDeviceObserver {
-	/**
-	 * Announces that the indicated coin storage unit is full of coins.
-	 * 
-	 * @param unit
-	 *            The storage unit where the event occurred.
-	 */
-	void coinsFull(CoinStorageUnit unit);
-
-	/**
-	 * Announces that a coin has been added to the indicated storage unit.
-	 * 
-	 * @param unit
-	 *            The storage unit where the event occurred.
-	 */
-	void coinAdded(CoinStorageUnit unit);
-
-	/**
-	 * Announces that the indicated storage unit has been loaded with coins.
-	 * Used to simulate direct, physical loading of the unit.
-	 * 
-	 * @param unit
-	 *            The storage unit where the event occurred.
-	 */
-	void coinsLoaded(CoinStorageUnit unit);
-
-	/**
-	 * Announces that the storage unit has been emptied of coins. Used to
-	 * simulate direct, physical unloading of the unit.
-	 * 
-	 * @param unit
-	 *            The storage unit where the event occurred.
-	 */
-	void coinsUnloaded(CoinStorageUnit unit);
-}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/CoinTrayObserver.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/CoinTrayObserver.java
deleted file mode 100644
index f5be6ea..0000000
--- a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/CoinTrayObserver.java	
+++ /dev/null
@@ -1,18 +0,0 @@
-package org.lsmr.selfcheckout.devices.observers;
-
-import org.lsmr.selfcheckout.Coin;
-import org.lsmr.selfcheckout.devices.CoinTray;
-
-/**
- * Observes events emanating from a coin tray. Coin trays are dumb devices so
- * very few kinds of events can be announced by them.
- */
-public interface CoinTrayObserver extends AbstractDeviceObserver {
-	/**
-	 * Announces that a coin has been added to the indicated tray.
-	 * 
-	 * @param tray
-	 *            The tray where the event occurred.
-	 */
-	void coinAdded(CoinTray tray);
-}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/CoinValidatorObserver.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/CoinValidatorObserver.java
deleted file mode 100644
index f0660b0..0000000
--- a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/CoinValidatorObserver.java	
+++ /dev/null
@@ -1,32 +0,0 @@
-package org.lsmr.selfcheckout.devices.observers;
-
-import java.math.BigDecimal;
-
-import org.lsmr.selfcheckout.Banknote;
-import org.lsmr.selfcheckout.Coin;
-import org.lsmr.selfcheckout.devices.CoinValidator;
-
-/**
- * Observes events emanating from a coin validator.
- */
-public interface CoinValidatorObserver extends AbstractDeviceObserver {
-	/**
-	 * An event announcing that the indicated coin has been detected and determined
-	 * to be valid.
-	 * 
-	 * @param validator
-	 *            The device on which the event occurred.
-	 * @param value
-	 *            The value of the coin.
-	 */
-	void validCoinDetected(CoinValidator validator, BigDecimal value);
-
-	/**
-	 * An event announcing that a coin has been detected and determined to be
-	 * invalid.
-	 * 
-	 * @param validator
-	 *            The device on which the event occurred.
-	 */
-	void invalidCoinDetected(CoinValidator validator);
-}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/ElectronicScaleObserver.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/ElectronicScaleObserver.java
deleted file mode 100644
index 1d20b50..0000000
--- a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/ElectronicScaleObserver.java	
+++ /dev/null
@@ -1,36 +0,0 @@
-package org.lsmr.selfcheckout.devices.observers;
-
-import org.lsmr.selfcheckout.Coin;
-import org.lsmr.selfcheckout.devices.ElectronicScale;
-
-/**
- * Observes events emanating from an electronic scale.
- */
-public interface ElectronicScaleObserver extends AbstractDeviceObserver {
-	/**
-	 * Announces that the weight on the indicated scale has changed.
-	 * 
-	 * @param scale
-	 *            The scale where the event occurred.
-	 * @param weightInGrams
-	 *            The new weight.
-	 */
-	void weightChanged(ElectronicScale scale, double weightInGrams);
-
-	/**
-	 * Announces that excessive weight has been placed on the indicated scale.
-	 * 
-	 * @param scale
-	 *            The scale where the event occurred.
-	 */
-	void overload(ElectronicScale scale);
-
-	/**
-	 * Announces that the former excessive weight has been removed from the
-	 * indicated scale, and it is again able to measure weight.
-	 * 
-	 * @param scale
-	 *            The scale where the event occurred.
-	 */
-	void outOfOverload(ElectronicScale scale);
-}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/ReceiptPrinterObserver.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/ReceiptPrinterObserver.java
deleted file mode 100644
index dc31b99..0000000
--- a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/ReceiptPrinterObserver.java	
+++ /dev/null
@@ -1,40 +0,0 @@
-package org.lsmr.selfcheckout.devices.observers;
-
-import org.lsmr.selfcheckout.devices.ReceiptPrinter;
-
-/**
- * Observes events emanating from a receipt printer.
- */
-public interface ReceiptPrinterObserver extends AbstractDeviceObserver {
-	/**
-	 * Announces that the indicated printer is out of paper.
-	 * 
-	 * @param printer
-	 *            The device from which the event emanated.
-	 */
-	void outOfPaper(ReceiptPrinter printer);
-
-	/**
-	 * Announces that the indicated printer is out of ink.
-	 * 
-	 * @param printer
-	 *            The device from which the event emanated.
-	 */
-	void outOfInk(ReceiptPrinter printer);
-
-	/**
-	 * Announces that paper has been added to the indicated printer.
-	 * 
-	 * @param printer
-	 *            The device from which the event emanated.
-	 */
-	void paperAdded(ReceiptPrinter printer);
-
-	/**
-	 * Announces that ink has been added to the indicated printer.
-	 * 
-	 * @param printer
-	 *            The device from which the event emanated.
-	 */
-	void inkAdded(ReceiptPrinter printer);
-}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/TouchScreenObserver.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/TouchScreenObserver.java
deleted file mode 100644
index e6ea7ad..0000000
--- a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/TouchScreenObserver.java	
+++ /dev/null
@@ -1,9 +0,0 @@
-package org.lsmr.selfcheckout.devices.observers;
-
-import org.lsmr.selfcheckout.devices.AbstractDevice;
-
-/**
- * Represents observers that respond only to enable/disable events on touch screens.
- */
-public interface TouchScreenObserver extends AbstractDeviceObserver {
-}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/products/BarcodedProduct.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/products/BarcodedProduct.java
deleted file mode 100644
index 4559cba..0000000
--- a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/products/BarcodedProduct.java	
+++ /dev/null
@@ -1,59 +0,0 @@
-package org.lsmr.selfcheckout.products;
-
-import java.math.BigDecimal;
-
-import org.lsmr.selfcheckout.Barcode;
-import org.lsmr.selfcheckout.devices.SimulationException;
-
-/**
- * Represents products with barcodes. Such products always have prices per-unit.
- */
-public class BarcodedProduct extends Product {
-	private final Barcode barcode;
-	private final String description;
-
-	/**
-	 * Create a product.
-	 * 
-	 * @param barcode
-	 *            The barcode of the product.
-	 * @param description
-	 *            The description of the product.
-	 * @param price
-	 *            The price per-unit of the product.
-	 * @throws SimulationException
-	 *             If any argument is null.
-	 * @throws SimulationException
-	 *             If the price is &le;0.
-	 */
-	public BarcodedProduct(Barcode barcode, String description, BigDecimal price) {
-		super(price, true);
-
-		if(barcode == null)
-			throw new SimulationException(new NullPointerException("barcode is null"));
-
-		if(description == null)
-			throw new SimulationException(new NullPointerException("description is null"));
-
-		this.barcode = barcode;
-		this.description = description;
-	}
-
-	/**
-	 * Get the barcode.
-	 * 
-	 * @return The barcode. Cannot be null.
-	 */
-	public Barcode getBarcode() {
-		return barcode;
-	}
-
-	/**
-	 * Get the description.
-	 * 
-	 * @return The description. Cannot be null.
-	 */
-	public String getDescription() {
-		return description;
-	}
-}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/products/PLUCodedProduct.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/products/PLUCodedProduct.java
deleted file mode 100644
index c3bab30..0000000
--- a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/products/PLUCodedProduct.java	
+++ /dev/null
@@ -1,57 +0,0 @@
-package org.lsmr.selfcheckout.products;
-
-import java.math.BigDecimal;
-
-import org.lsmr.selfcheckout.Barcode;
-import org.lsmr.selfcheckout.PriceLookupCode;
-import org.lsmr.selfcheckout.devices.SimulationException;
-
-/**
- * Represents products with price-lookup (PLU) codes. Such products always have
- * prices per-kilogram.
- */
-public class PLUCodedProduct extends Product {
-	private final PriceLookupCode pluCode;
-	private final String description;
-
-	/**
-	 * Create a product.
-	 * 
-	 * @param pluCode
-	 *            The PLU code of the product.
-	 * @param description
-	 *            The description of the product.
-	 * @param price
-	 *            The price per-kilogram of the product.
-	 */
-	public PLUCodedProduct(PriceLookupCode pluCode, String description, BigDecimal price) {
-		super(price, false);
-
-		if(pluCode == null)
-			throw new SimulationException(new NullPointerException("barcode is null"));
-
-		if(description == null)
-			throw new SimulationException(new NullPointerException("description is null"));
-
-		this.pluCode = pluCode;
-		this.description = description;
-	}
-
-	/**
-	 * Get the PLU code.
-	 * 
-	 * @return The PLU code. Cannot be null.
-	 */
-	public PriceLookupCode getPLUCode() {
-		return pluCode;
-	}
-
-	/**
-	 * Get the description.
-	 * 
-	 * @return The description. Cannot be null.
-	 */
-	public String getDescription() {
-		return description;
-	}
-}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/products/Product.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/products/Product.java
deleted file mode 100644
index d47e70e..0000000
--- a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/products/Product.java	
+++ /dev/null
@@ -1,55 +0,0 @@
-package org.lsmr.selfcheckout.products;
-
-import java.math.BigDecimal;
-
-import org.lsmr.selfcheckout.devices.SimulationException;
-
-/**
- * Abstract base class for products. Note that a "product" is the <b>kind</> of
- * item (e.g., 2 litre container of Dairyland brand 2% milk) and not an
- * individual item, which would be the specific physical object (e.g.,
- * <b>that</b> bottle of milk and not <b>this</b> one).
- */
-public abstract class Product {
-	private final BigDecimal price;
-	private final boolean isPerUnit;
-
-	/**
-	 * Create a product instance.
-	 * 
-	 * @param price
-	 *            The price per unit or per kilogram.
-	 * @param isPerUnit
-	 *            True if the price is per unit; false if it is per kilogram.
-	 * @throws SimulationException
-	 *             If the price is null or &le;0.
-	 */
-	protected Product(BigDecimal price, boolean isPerUnit) {
-		if(price == null)
-			throw new SimulationException(new NullPointerException("price is null"));
-
-		if(price.compareTo(BigDecimal.ZERO) <= 0)
-			throw new SimulationException(new IllegalArgumentException("A product's price can only be positive."));
-
-		this.price = price;
-		this.isPerUnit = isPerUnit;
-	}
-
-	/**
-	 * Gets the price of the product.
-	 * 
-	 * @return The price. Cannot be null. Must be &gt;0.
-	 */
-	public BigDecimal getPrice() {
-		return price;
-	}
-
-	/**
-	 * Tests whether the price is per-unit, as opposed to per-kilogram.
-	 * 
-	 * @return true if the price is per-unit; otherwise, false.
-	 */
-	public boolean isPerUnit() {
-		return isPerUnit;
-	}
-}
diff --git a/bin/.gitignore b/bin/.gitignore
deleted file mode 100644
index def592d..0000000
--- a/bin/.gitignore
+++ /dev/null
@@ -1,2 +0,0 @@
-/selfcheckout_test/
-/selfcheckout_software/
diff --git a/bin/.project b/bin/.project
deleted file mode 100644
index 0f6f6a7..0000000
--- a/bin/.project
+++ /dev/null
@@ -1,17 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<projectDescription>
-	<name>src</name>
-	<comment></comment>
-	<projects>
-	</projects>
-	<buildSpec>
-		<buildCommand>
-			<name>org.eclipse.jdt.core.javabuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-	</buildSpec>
-	<natures>
-		<nature>org.eclipse.jdt.core.javanature</nature>
-	</natures>
-</projectDescription>
diff --git a/bin/org/lsmr/selfcheckout/Banknote.class b/bin/org/lsmr/selfcheckout/Banknote.class
deleted file mode 100644
index 3b81981..0000000
Binary files a/bin/org/lsmr/selfcheckout/Banknote.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/Barcode.class b/bin/org/lsmr/selfcheckout/Barcode.class
deleted file mode 100644
index 2a9a140..0000000
Binary files a/bin/org/lsmr/selfcheckout/Barcode.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/BarcodedItem.class b/bin/org/lsmr/selfcheckout/BarcodedItem.class
deleted file mode 100644
index 904e34b..0000000
Binary files a/bin/org/lsmr/selfcheckout/BarcodedItem.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/BlockedCardException.class b/bin/org/lsmr/selfcheckout/BlockedCardException.class
deleted file mode 100644
index 98d47e2..0000000
Binary files a/bin/org/lsmr/selfcheckout/BlockedCardException.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/Card$CardData.class b/bin/org/lsmr/selfcheckout/Card$CardData.class
deleted file mode 100644
index 21aecb0..0000000
Binary files a/bin/org/lsmr/selfcheckout/Card$CardData.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/Card$CardInsertData.class b/bin/org/lsmr/selfcheckout/Card$CardInsertData.class
deleted file mode 100644
index b8fe14c..0000000
Binary files a/bin/org/lsmr/selfcheckout/Card$CardInsertData.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/Card$CardSwipeData.class b/bin/org/lsmr/selfcheckout/Card$CardSwipeData.class
deleted file mode 100644
index 9ab14eb..0000000
Binary files a/bin/org/lsmr/selfcheckout/Card$CardSwipeData.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/Card$CardTapData.class b/bin/org/lsmr/selfcheckout/Card$CardTapData.class
deleted file mode 100644
index cf9b332..0000000
Binary files a/bin/org/lsmr/selfcheckout/Card$CardTapData.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/Card.class b/bin/org/lsmr/selfcheckout/Card.class
deleted file mode 100644
index dd0466e..0000000
Binary files a/bin/org/lsmr/selfcheckout/Card.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/ChipFailureException.class b/bin/org/lsmr/selfcheckout/ChipFailureException.class
deleted file mode 100644
index b846f50..0000000
Binary files a/bin/org/lsmr/selfcheckout/ChipFailureException.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/Coin.class b/bin/org/lsmr/selfcheckout/Coin.class
deleted file mode 100644
index a518210..0000000
Binary files a/bin/org/lsmr/selfcheckout/Coin.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/IllegalDigitException.class b/bin/org/lsmr/selfcheckout/IllegalDigitException.class
deleted file mode 100644
index ba0d46d..0000000
Binary files a/bin/org/lsmr/selfcheckout/IllegalDigitException.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/InvalidPINException.class b/bin/org/lsmr/selfcheckout/InvalidPINException.class
deleted file mode 100644
index e1db508..0000000
Binary files a/bin/org/lsmr/selfcheckout/InvalidPINException.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/Item.class b/bin/org/lsmr/selfcheckout/Item.class
deleted file mode 100644
index b93ecba..0000000
Binary files a/bin/org/lsmr/selfcheckout/Item.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/MagneticStripeFailureException.class b/bin/org/lsmr/selfcheckout/MagneticStripeFailureException.class
deleted file mode 100644
index 59dd493..0000000
Binary files a/bin/org/lsmr/selfcheckout/MagneticStripeFailureException.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/Numeral.class b/bin/org/lsmr/selfcheckout/Numeral.class
deleted file mode 100644
index 7bf788b..0000000
Binary files a/bin/org/lsmr/selfcheckout/Numeral.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/PLUCodedItem.class b/bin/org/lsmr/selfcheckout/PLUCodedItem.class
deleted file mode 100644
index fad72b2..0000000
Binary files a/bin/org/lsmr/selfcheckout/PLUCodedItem.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/PriceLookupCode.class b/bin/org/lsmr/selfcheckout/PriceLookupCode.class
deleted file mode 100644
index babd198..0000000
Binary files a/bin/org/lsmr/selfcheckout/PriceLookupCode.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/TapFailureException.class b/bin/org/lsmr/selfcheckout/TapFailureException.class
deleted file mode 100644
index 8bddf8b..0000000
Binary files a/bin/org/lsmr/selfcheckout/TapFailureException.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/devices/AbstractDevice$Phase.class b/bin/org/lsmr/selfcheckout/devices/AbstractDevice$Phase.class
deleted file mode 100644
index f4b5c50..0000000
Binary files a/bin/org/lsmr/selfcheckout/devices/AbstractDevice$Phase.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/devices/AbstractDevice.class b/bin/org/lsmr/selfcheckout/devices/AbstractDevice.class
deleted file mode 100644
index 3ce33b9..0000000
Binary files a/bin/org/lsmr/selfcheckout/devices/AbstractDevice.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/devices/Acceptor.class b/bin/org/lsmr/selfcheckout/devices/Acceptor.class
deleted file mode 100644
index 9113c51..0000000
Binary files a/bin/org/lsmr/selfcheckout/devices/Acceptor.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/devices/BanknoteDispenser.class b/bin/org/lsmr/selfcheckout/devices/BanknoteDispenser.class
deleted file mode 100644
index aa24008..0000000
Binary files a/bin/org/lsmr/selfcheckout/devices/BanknoteDispenser.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/devices/BanknoteSlot.class b/bin/org/lsmr/selfcheckout/devices/BanknoteSlot.class
deleted file mode 100644
index f729648..0000000
Binary files a/bin/org/lsmr/selfcheckout/devices/BanknoteSlot.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/devices/BanknoteStorageUnit.class b/bin/org/lsmr/selfcheckout/devices/BanknoteStorageUnit.class
deleted file mode 100644
index ea63e8f..0000000
Binary files a/bin/org/lsmr/selfcheckout/devices/BanknoteStorageUnit.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/devices/BanknoteValidator.class b/bin/org/lsmr/selfcheckout/devices/BanknoteValidator.class
deleted file mode 100644
index f308fb9..0000000
Binary files a/bin/org/lsmr/selfcheckout/devices/BanknoteValidator.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/devices/BarcodeScanner.class b/bin/org/lsmr/selfcheckout/devices/BarcodeScanner.class
deleted file mode 100644
index b46b109..0000000
Binary files a/bin/org/lsmr/selfcheckout/devices/BarcodeScanner.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/devices/BidirectionalChannel.class b/bin/org/lsmr/selfcheckout/devices/BidirectionalChannel.class
deleted file mode 100644
index c7344b7..0000000
Binary files a/bin/org/lsmr/selfcheckout/devices/BidirectionalChannel.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/devices/CardReader.class b/bin/org/lsmr/selfcheckout/devices/CardReader.class
deleted file mode 100644
index 109a005..0000000
Binary files a/bin/org/lsmr/selfcheckout/devices/CardReader.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/devices/CoinDispenser.class b/bin/org/lsmr/selfcheckout/devices/CoinDispenser.class
deleted file mode 100644
index 2066e9b..0000000
Binary files a/bin/org/lsmr/selfcheckout/devices/CoinDispenser.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/devices/CoinSlot.class b/bin/org/lsmr/selfcheckout/devices/CoinSlot.class
deleted file mode 100644
index 781b206..0000000
Binary files a/bin/org/lsmr/selfcheckout/devices/CoinSlot.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/devices/CoinStorageUnit.class b/bin/org/lsmr/selfcheckout/devices/CoinStorageUnit.class
deleted file mode 100644
index e755e04..0000000
Binary files a/bin/org/lsmr/selfcheckout/devices/CoinStorageUnit.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/devices/CoinTray.class b/bin/org/lsmr/selfcheckout/devices/CoinTray.class
deleted file mode 100644
index 6e55b32..0000000
Binary files a/bin/org/lsmr/selfcheckout/devices/CoinTray.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/devices/CoinValidator.class b/bin/org/lsmr/selfcheckout/devices/CoinValidator.class
deleted file mode 100644
index fe0c4c9..0000000
Binary files a/bin/org/lsmr/selfcheckout/devices/CoinValidator.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/devices/DisabledException.class b/bin/org/lsmr/selfcheckout/devices/DisabledException.class
deleted file mode 100644
index f4bf3c3..0000000
Binary files a/bin/org/lsmr/selfcheckout/devices/DisabledException.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/devices/ElectronicScale.class b/bin/org/lsmr/selfcheckout/devices/ElectronicScale.class
deleted file mode 100644
index 8b9ef5d..0000000
Binary files a/bin/org/lsmr/selfcheckout/devices/ElectronicScale.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/devices/Emitter.class b/bin/org/lsmr/selfcheckout/devices/Emitter.class
deleted file mode 100644
index d2bb395..0000000
Binary files a/bin/org/lsmr/selfcheckout/devices/Emitter.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/devices/EmptyException.class b/bin/org/lsmr/selfcheckout/devices/EmptyException.class
deleted file mode 100644
index 1aa1d89..0000000
Binary files a/bin/org/lsmr/selfcheckout/devices/EmptyException.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/devices/FlowThroughEmitter.class b/bin/org/lsmr/selfcheckout/devices/FlowThroughEmitter.class
deleted file mode 100644
index 0577624..0000000
Binary files a/bin/org/lsmr/selfcheckout/devices/FlowThroughEmitter.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/devices/FromStorageEmitter.class b/bin/org/lsmr/selfcheckout/devices/FromStorageEmitter.class
deleted file mode 100644
index 1e1ffbd..0000000
Binary files a/bin/org/lsmr/selfcheckout/devices/FromStorageEmitter.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/devices/OverloadException.class b/bin/org/lsmr/selfcheckout/devices/OverloadException.class
deleted file mode 100644
index 6ab58bc..0000000
Binary files a/bin/org/lsmr/selfcheckout/devices/OverloadException.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/devices/ReceiptPrinter.class b/bin/org/lsmr/selfcheckout/devices/ReceiptPrinter.class
deleted file mode 100644
index a7104d5..0000000
Binary files a/bin/org/lsmr/selfcheckout/devices/ReceiptPrinter.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/devices/SelfCheckoutStation.class b/bin/org/lsmr/selfcheckout/devices/SelfCheckoutStation.class
deleted file mode 100644
index 56e7dfc..0000000
Binary files a/bin/org/lsmr/selfcheckout/devices/SelfCheckoutStation.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/devices/SimulationException.class b/bin/org/lsmr/selfcheckout/devices/SimulationException.class
deleted file mode 100644
index 2b4c563..0000000
Binary files a/bin/org/lsmr/selfcheckout/devices/SimulationException.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/devices/UnidirectionalChannel.class b/bin/org/lsmr/selfcheckout/devices/UnidirectionalChannel.class
deleted file mode 100644
index a24b91e..0000000
Binary files a/bin/org/lsmr/selfcheckout/devices/UnidirectionalChannel.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/AbstractDeviceObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/AbstractDeviceObserver.class
deleted file mode 100644
index 247e22d..0000000
Binary files a/bin/org/lsmr/selfcheckout/devices/observers/AbstractDeviceObserver.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/BanknoteDispenserObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/BanknoteDispenserObserver.class
deleted file mode 100644
index 2d6cddc..0000000
Binary files a/bin/org/lsmr/selfcheckout/devices/observers/BanknoteDispenserObserver.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/BanknoteSlotObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/BanknoteSlotObserver.class
deleted file mode 100644
index 221e426..0000000
Binary files a/bin/org/lsmr/selfcheckout/devices/observers/BanknoteSlotObserver.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/BanknoteStorageUnitObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/BanknoteStorageUnitObserver.class
deleted file mode 100644
index 043983d..0000000
Binary files a/bin/org/lsmr/selfcheckout/devices/observers/BanknoteStorageUnitObserver.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/BanknoteValidatorObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/BanknoteValidatorObserver.class
deleted file mode 100644
index 8838fb1..0000000
Binary files a/bin/org/lsmr/selfcheckout/devices/observers/BanknoteValidatorObserver.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/BarcodeScannerObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/BarcodeScannerObserver.class
deleted file mode 100644
index 56fc44a..0000000
Binary files a/bin/org/lsmr/selfcheckout/devices/observers/BarcodeScannerObserver.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/CardReaderObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/CardReaderObserver.class
deleted file mode 100644
index 26fe866..0000000
Binary files a/bin/org/lsmr/selfcheckout/devices/observers/CardReaderObserver.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/CoinDispenserObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/CoinDispenserObserver.class
deleted file mode 100644
index 057849f..0000000
Binary files a/bin/org/lsmr/selfcheckout/devices/observers/CoinDispenserObserver.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/CoinSlotObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/CoinSlotObserver.class
deleted file mode 100644
index af69753..0000000
Binary files a/bin/org/lsmr/selfcheckout/devices/observers/CoinSlotObserver.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/CoinStorageUnitObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/CoinStorageUnitObserver.class
deleted file mode 100644
index f6b4b05..0000000
Binary files a/bin/org/lsmr/selfcheckout/devices/observers/CoinStorageUnitObserver.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/CoinTrayObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/CoinTrayObserver.class
deleted file mode 100644
index 6bd2a6e..0000000
Binary files a/bin/org/lsmr/selfcheckout/devices/observers/CoinTrayObserver.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/CoinValidatorObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/CoinValidatorObserver.class
deleted file mode 100644
index a1b2c79..0000000
Binary files a/bin/org/lsmr/selfcheckout/devices/observers/CoinValidatorObserver.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/ElectronicScaleObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/ElectronicScaleObserver.class
deleted file mode 100644
index af886a7..0000000
Binary files a/bin/org/lsmr/selfcheckout/devices/observers/ElectronicScaleObserver.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/ReceiptPrinterObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/ReceiptPrinterObserver.class
deleted file mode 100644
index d93a2ee..0000000
Binary files a/bin/org/lsmr/selfcheckout/devices/observers/ReceiptPrinterObserver.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/TouchScreenObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/TouchScreenObserver.class
deleted file mode 100644
index ea9378e..0000000
Binary files a/bin/org/lsmr/selfcheckout/devices/observers/TouchScreenObserver.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/products/BarcodedProduct.class b/bin/org/lsmr/selfcheckout/products/BarcodedProduct.class
deleted file mode 100644
index bd46533..0000000
Binary files a/bin/org/lsmr/selfcheckout/products/BarcodedProduct.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/products/PLUCodedProduct.class b/bin/org/lsmr/selfcheckout/products/PLUCodedProduct.class
deleted file mode 100644
index 95698b3..0000000
Binary files a/bin/org/lsmr/selfcheckout/products/PLUCodedProduct.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/products/Product.class b/bin/org/lsmr/selfcheckout/products/Product.class
deleted file mode 100644
index c7ee9be..0000000
Binary files a/bin/org/lsmr/selfcheckout/products/Product.class and /dev/null differ
diff --git a/src/.project b/src/.project
deleted file mode 100644
index 0f6f6a7..0000000
--- a/src/.project
+++ /dev/null
@@ -1,17 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<projectDescription>
-	<name>src</name>
-	<comment></comment>
-	<projects>
-	</projects>
-	<buildSpec>
-		<buildCommand>
-			<name>org.eclipse.jdt.core.javabuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-	</buildSpec>
-	<natures>
-		<nature>org.eclipse.jdt.core.javanature</nature>
-	</natures>
-</projectDescription>
diff --git a/src/selfcheckout_software/BanknoteController.java b/src/selfcheckout_software/BanknoteController.java
deleted file mode 100644
index 276cac9..0000000
--- a/src/selfcheckout_software/BanknoteController.java
+++ /dev/null
@@ -1,69 +0,0 @@
-package selfcheckout_software;
-import java.math.BigDecimal;
-import java.util.Currency;
-
-import org.lsmr.selfcheckout.devices.AbstractDevice;
-import org.lsmr.selfcheckout.devices.BanknoteStorageUnit;
-import org.lsmr.selfcheckout.devices.BanknoteValidator;
-import org.lsmr.selfcheckout.devices.SelfCheckoutStation;
-import org.lsmr.selfcheckout.devices.observers.AbstractDeviceObserver;
-import org.lsmr.selfcheckout.devices.observers.BanknoteStorageUnitObserver;
-import org.lsmr.selfcheckout.devices.observers.BanknoteValidatorObserver;
-
-public class BanknoteController implements BanknoteValidatorObserver, BanknoteStorageUnitObserver{
-
-	private int availableFunds;
-	private int validBanknotes = 0;
-	private boolean isFull = false;
-	
-	public BanknoteController(SelfCheckoutStation s) {
-		s.banknoteValidator.attach(this);
-		availableFunds = 0;
-	}
-
-	@Override
-	public void enabled(AbstractDevice<? extends AbstractDeviceObserver> device) {}
-
-	@Override
-	public void disabled(AbstractDevice<? extends AbstractDeviceObserver> device) {}
-
-	@Override
-	public void validBanknoteDetected(BanknoteValidator validator, Currency currency, int value) {
-		if(!isFull) {
-			availableFunds+=value;
-		}
-		
-	}
-
-	@Override
-	public void invalidBanknoteDetected(BanknoteValidator validator) {
-		
-	}
-
-	@Override
-	public void banknotesFull(BanknoteStorageUnit unit) {
-		isFull = true;
-		
-	}
-
-	@Override
-	public void banknoteAdded(BanknoteStorageUnit unit) {}
-
-	@Override
-	public void banknotesLoaded(BanknoteStorageUnit unit) {}
-
-	@Override
-	public void banknotesUnloaded(BanknoteStorageUnit unit) {
-		isFull = false;
-	}
-	
-	public boolean hasSufficientFunds(float price) {
-		return availableFunds>price;
-	}
-	
-	public int getCurrentFunds() {
-		return availableFunds;
-	}
-	
-	
-}
diff --git a/src/selfcheckout_software/SCSLogic.java b/src/selfcheckout_software/SCSLogic.java
deleted file mode 100644
index d466e31..0000000
--- a/src/selfcheckout_software/SCSLogic.java
+++ /dev/null
@@ -1,83 +0,0 @@
-package selfcheckout_software;
-
-import org.lsmr.selfcheckout.devices.AbstractDevice;
-import org.lsmr.selfcheckout.devices.Acceptor;
-import org.lsmr.selfcheckout.devices.DisabledException;
-import org.lsmr.selfcheckout.devices.ElectronicScale;
-import org.lsmr.selfcheckout.devices.OverloadException;
-import org.lsmr.selfcheckout.devices.SimulationException;
-import org.lsmr.selfcheckout.devices.observers.AbstractDeviceObserver;
-
-public class SCSLogic extends AbstractDevice<AbstractDeviceObserver> implements Acceptor<AbstractDeviceObserver>{
-	
-	private ElectronicScale electronic;
-	
-	
-	
-	
-	public SCSLogic(ElectronicScale e) {
-		this.electronic = e;
-	}
-	
-	
-	
-	
-	public void wish_checkout(AbstractDeviceObserver payment_method) throws OverloadException, DisabledException  {
-		
-		try {
-			this.attach(payment_method);
-			while(true) {
-				if (!electronic.isDisabled()) {  // keep checking the weight of bagging area, check if the weight has changed
-					
-					this.accept(payment_method);
-					
-					if (this.isDisabled()) {
-						break;
-					}
-					else { //this should never been run
-						throw new SimulationException("can't receive payment method");
-					}
-					
-				}
-				else {
-					throw new SimulationException("the weight has changed");
-				}
-				
-			}
-			//....might need to call the matched payment method
-			
-		} catch (OverloadException e) {
-			throw e;
-		}catch (DisabledException e) {
-		    throw e;
-		}
-		
-		
-		
-		
-		
-	}
-
-
-
-
-
-
-
-
-
-
-	@Override
-	public void accept(AbstractDeviceObserver thing) throws OverloadException, DisabledException {
-			thing.enabled(this);
-	}
-
-
-
-	@Override
-	public boolean hasSpace() { //not used yet
-		// TODO Auto-generated method stub
-		return false;
-	}
-	
-}
diff --git a/src/selfcheckout_test/AbstractDeviceObserverStub.java b/src/selfcheckout_test/AbstractDeviceObserverStub.java
deleted file mode 100644
index 5d7fe00..0000000
--- a/src/selfcheckout_test/AbstractDeviceObserverStub.java
+++ /dev/null
@@ -1,19 +0,0 @@
-package selfcheckout_test;
-
-import org.lsmr.selfcheckout.devices.AbstractDevice;
-import org.lsmr.selfcheckout.devices.observers.AbstractDeviceObserver;
-
-public class AbstractDeviceObserverStub implements AbstractDeviceObserver {
-
-	@Override
-	public void enabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
-		device.disable();	
-	}
-
-	@Override
-	public void disabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
-		// TODO Auto-generated method stub
-		
-	}
-
-}
diff --git a/src/selfcheckout_test/ElectronicScaleObserverStub.java b/src/selfcheckout_test/ElectronicScaleObserverStub.java
deleted file mode 100644
index 4f713f4..0000000
--- a/src/selfcheckout_test/ElectronicScaleObserverStub.java
+++ /dev/null
@@ -1,40 +0,0 @@
-package selfcheckout_test;
-
-import org.lsmr.selfcheckout.devices.AbstractDevice;
-import org.lsmr.selfcheckout.devices.ElectronicScale;
-import org.lsmr.selfcheckout.devices.observers.AbstractDeviceObserver;
-import org.lsmr.selfcheckout.devices.observers.ElectronicScaleObserver;
-
-public class ElectronicScaleObserverStub implements ElectronicScaleObserver {
-
-	@Override
-	public void enabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
-		// TODO Auto-generated method stub
-		
-	}
-
-	@Override
-	public void disabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
-		// TODO Auto-generated method stub
-		
-	}
-
-	@Override
-	public void weightChanged(ElectronicScale scale, double weightInGrams) {
-		scale.disable();
-		
-	}
-
-	@Override
-	public void overload(ElectronicScale scale) {
-		// TODO Auto-generated method stub
-		
-	}
-
-	@Override
-	public void outOfOverload(ElectronicScale scale) {
-		// TODO Auto-generated method stub
-		
-	}
-
-}
diff --git a/src/selfcheckout_test/test_wish_to_checkout.java b/src/selfcheckout_test/test_wish_to_checkout.java
deleted file mode 100644
index b4347f4..0000000
--- a/src/selfcheckout_test/test_wish_to_checkout.java
+++ /dev/null
@@ -1,69 +0,0 @@
-package selfcheckout_test;
-
-import selfcheckout_software.*;
-import static org.junit.Assert.*;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.lsmr.selfcheckout.Item;
-import org.lsmr.selfcheckout.devices.AbstractDevice;
-import org.lsmr.selfcheckout.devices.DisabledException;
-import org.lsmr.selfcheckout.devices.ElectronicScale;
-import org.lsmr.selfcheckout.devices.OverloadException;
-import org.lsmr.selfcheckout.devices.SimulationException;
-import org.lsmr.selfcheckout.devices.observers.AbstractDeviceObserver;
-
-import junit.extensions.TestSetup;
-import junit.framework.Assert;
-
-public class test_wish_to_checkout {
-
-	private SCSLogic test_object;
-	private AbstractDeviceObserverStub payment;
-	private ElectronicScaleObserverStub w_observer;
-	private ElectronicScale E;
-	
-	@Before
-	public void TestSetup() {
-		this.E = new ElectronicScale(100, 1);
-		this.test_object = new SCSLogic(E);
-		this.payment = new AbstractDeviceObserverStub();
-		this.w_observer = new ElectronicScaleObserverStub();
-		
-	}
-	
-	@Test(expected = SimulationException.class)
-	public void test_attachment() throws OverloadException, DisabledException {
-		test_object.wish_checkout(payment);
-		test_object.detach(payment);
-		test_object.detach(payment);
-	}
-	
-	@Test(expected = SimulationException.class)
-	public void test_weight_changed() throws OverloadException, DisabledException {
-		E.attach(w_observer);
-		Item test_item1 = new Item(20) {};
-		Item test_item2 = new Item(40) {};
-		E.add(test_item1);
-		E.enable();
-		
-		E.add(test_item2);
-		
-		test_object.wish_checkout(payment);
-		
-	}
-	
-	@Test
-	public void test_normal_wish() throws OverloadException, DisabledException {
-		test_object.endConfigurationPhase();
-		E.attach(w_observer);
-		E.endConfigurationPhase();
-		E.enable();
-		test_object.wish_checkout(payment);
-		assertTrue("this should be true",test_object.isDisabled());
-		
-		
-	}
-	
-
-}

commit acdee0a10e0578d597f0a58f7c747f475482ed9f
Author: lexahoa <sparr@LAPTOP-V521ED67>
Date:   Fri Mar 18 21:51:51 2022 -0400

    some updates,package changed

diff --git a/.classpath b/.classpath
index 8cf4aa1..46a3f0e 100644
--- a/.classpath
+++ b/.classpath
@@ -1,10 +1,11 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <classpath>
-	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/JavaSE-17">
+	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/jre">
 		<attributes>
 			<attribute name="module" value="true"/>
 		</attributes>
 	</classpathentry>
+	<classpathentry kind="con" path="org.eclipse.jdt.junit.JUNIT_CONTAINER/4"/>
 	<classpathentry kind="src" path="src"/>
 	<classpathentry kind="src" path="SCS - Hardware - v1.0/src"/>
 	<classpathentry kind="output" path="bin"/>
diff --git a/.settings/org.eclipse.jdt.core.prefs b/.settings/org.eclipse.jdt.core.prefs
index 8c9943d..59fe89d 100644
--- a/.settings/org.eclipse.jdt.core.prefs
+++ b/.settings/org.eclipse.jdt.core.prefs
@@ -1,5 +1,6 @@
 eclipse.preferences.version=1
 org.eclipse.jdt.core.compiler.codegen.inlineJsrBytecode=enabled
+org.eclipse.jdt.core.compiler.codegen.methodParameters=do not generate
 org.eclipse.jdt.core.compiler.codegen.targetPlatform=17
 org.eclipse.jdt.core.compiler.codegen.unusedLocal=preserve
 org.eclipse.jdt.core.compiler.compliance=17
@@ -10,5 +11,5 @@ org.eclipse.jdt.core.compiler.problem.assertIdentifier=error
 org.eclipse.jdt.core.compiler.problem.enablePreviewFeatures=disabled
 org.eclipse.jdt.core.compiler.problem.enumIdentifier=error
 org.eclipse.jdt.core.compiler.problem.reportPreviewFeatures=warning
-org.eclipse.jdt.core.compiler.release=enabled
+org.eclipse.jdt.core.compiler.release=disabled
 org.eclipse.jdt.core.compiler.source=17
diff --git a/bin/.gitignore b/bin/.gitignore
new file mode 100644
index 0000000..def592d
--- /dev/null
+++ b/bin/.gitignore
@@ -0,0 +1,2 @@
+/selfcheckout_test/
+/selfcheckout_software/
diff --git a/bin/.project b/bin/.project
new file mode 100644
index 0000000..0f6f6a7
--- /dev/null
+++ b/bin/.project
@@ -0,0 +1,17 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>src</name>
+	<comment></comment>
+	<projects>
+	</projects>
+	<buildSpec>
+		<buildCommand>
+			<name>org.eclipse.jdt.core.javabuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+	</buildSpec>
+	<natures>
+		<nature>org.eclipse.jdt.core.javanature</nature>
+	</natures>
+</projectDescription>
diff --git a/bin/BanknoteController.class b/bin/BanknoteController.class
deleted file mode 100644
index 7ff8015..0000000
Binary files a/bin/BanknoteController.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/Banknote.class b/bin/org/lsmr/selfcheckout/Banknote.class
index 0416eb6..3b81981 100644
Binary files a/bin/org/lsmr/selfcheckout/Banknote.class and b/bin/org/lsmr/selfcheckout/Banknote.class differ
diff --git a/bin/org/lsmr/selfcheckout/Barcode.class b/bin/org/lsmr/selfcheckout/Barcode.class
index 464a475..2a9a140 100644
Binary files a/bin/org/lsmr/selfcheckout/Barcode.class and b/bin/org/lsmr/selfcheckout/Barcode.class differ
diff --git a/bin/org/lsmr/selfcheckout/BarcodedItem.class b/bin/org/lsmr/selfcheckout/BarcodedItem.class
index de7368f..904e34b 100644
Binary files a/bin/org/lsmr/selfcheckout/BarcodedItem.class and b/bin/org/lsmr/selfcheckout/BarcodedItem.class differ
diff --git a/bin/org/lsmr/selfcheckout/BlockedCardException.class b/bin/org/lsmr/selfcheckout/BlockedCardException.class
index 0342831..98d47e2 100644
Binary files a/bin/org/lsmr/selfcheckout/BlockedCardException.class and b/bin/org/lsmr/selfcheckout/BlockedCardException.class differ
diff --git a/bin/org/lsmr/selfcheckout/Card$CardData.class b/bin/org/lsmr/selfcheckout/Card$CardData.class
index 3a5a24b..21aecb0 100644
Binary files a/bin/org/lsmr/selfcheckout/Card$CardData.class and b/bin/org/lsmr/selfcheckout/Card$CardData.class differ
diff --git a/bin/org/lsmr/selfcheckout/Card$CardInsertData.class b/bin/org/lsmr/selfcheckout/Card$CardInsertData.class
index b1844b6..b8fe14c 100644
Binary files a/bin/org/lsmr/selfcheckout/Card$CardInsertData.class and b/bin/org/lsmr/selfcheckout/Card$CardInsertData.class differ
diff --git a/bin/org/lsmr/selfcheckout/Card$CardSwipeData.class b/bin/org/lsmr/selfcheckout/Card$CardSwipeData.class
index 38d5704..9ab14eb 100644
Binary files a/bin/org/lsmr/selfcheckout/Card$CardSwipeData.class and b/bin/org/lsmr/selfcheckout/Card$CardSwipeData.class differ
diff --git a/bin/org/lsmr/selfcheckout/Card$CardTapData.class b/bin/org/lsmr/selfcheckout/Card$CardTapData.class
index c51bac1..cf9b332 100644
Binary files a/bin/org/lsmr/selfcheckout/Card$CardTapData.class and b/bin/org/lsmr/selfcheckout/Card$CardTapData.class differ
diff --git a/bin/org/lsmr/selfcheckout/Card.class b/bin/org/lsmr/selfcheckout/Card.class
index 7ca0563..dd0466e 100644
Binary files a/bin/org/lsmr/selfcheckout/Card.class and b/bin/org/lsmr/selfcheckout/Card.class differ
diff --git a/bin/org/lsmr/selfcheckout/ChipFailureException.class b/bin/org/lsmr/selfcheckout/ChipFailureException.class
index f4aaf48..b846f50 100644
Binary files a/bin/org/lsmr/selfcheckout/ChipFailureException.class and b/bin/org/lsmr/selfcheckout/ChipFailureException.class differ
diff --git a/bin/org/lsmr/selfcheckout/Coin.class b/bin/org/lsmr/selfcheckout/Coin.class
index 55e3cde..a518210 100644
Binary files a/bin/org/lsmr/selfcheckout/Coin.class and b/bin/org/lsmr/selfcheckout/Coin.class differ
diff --git a/bin/org/lsmr/selfcheckout/IllegalDigitException.class b/bin/org/lsmr/selfcheckout/IllegalDigitException.class
index ecf0201..ba0d46d 100644
Binary files a/bin/org/lsmr/selfcheckout/IllegalDigitException.class and b/bin/org/lsmr/selfcheckout/IllegalDigitException.class differ
diff --git a/bin/org/lsmr/selfcheckout/InvalidPINException.class b/bin/org/lsmr/selfcheckout/InvalidPINException.class
index 9a7fdaa..e1db508 100644
Binary files a/bin/org/lsmr/selfcheckout/InvalidPINException.class and b/bin/org/lsmr/selfcheckout/InvalidPINException.class differ
diff --git a/bin/org/lsmr/selfcheckout/Item.class b/bin/org/lsmr/selfcheckout/Item.class
index a3468c5..b93ecba 100644
Binary files a/bin/org/lsmr/selfcheckout/Item.class and b/bin/org/lsmr/selfcheckout/Item.class differ
diff --git a/bin/org/lsmr/selfcheckout/MagneticStripeFailureException.class b/bin/org/lsmr/selfcheckout/MagneticStripeFailureException.class
index f3ef20e..59dd493 100644
Binary files a/bin/org/lsmr/selfcheckout/MagneticStripeFailureException.class and b/bin/org/lsmr/selfcheckout/MagneticStripeFailureException.class differ
diff --git a/bin/org/lsmr/selfcheckout/Numeral.class b/bin/org/lsmr/selfcheckout/Numeral.class
index fa00a27..7bf788b 100644
Binary files a/bin/org/lsmr/selfcheckout/Numeral.class and b/bin/org/lsmr/selfcheckout/Numeral.class differ
diff --git a/bin/org/lsmr/selfcheckout/PLUCodedItem.class b/bin/org/lsmr/selfcheckout/PLUCodedItem.class
index eec7e69..fad72b2 100644
Binary files a/bin/org/lsmr/selfcheckout/PLUCodedItem.class and b/bin/org/lsmr/selfcheckout/PLUCodedItem.class differ
diff --git a/bin/org/lsmr/selfcheckout/PriceLookupCode.class b/bin/org/lsmr/selfcheckout/PriceLookupCode.class
index 22ee588..babd198 100644
Binary files a/bin/org/lsmr/selfcheckout/PriceLookupCode.class and b/bin/org/lsmr/selfcheckout/PriceLookupCode.class differ
diff --git a/bin/org/lsmr/selfcheckout/TapFailureException.class b/bin/org/lsmr/selfcheckout/TapFailureException.class
index b22f856..8bddf8b 100644
Binary files a/bin/org/lsmr/selfcheckout/TapFailureException.class and b/bin/org/lsmr/selfcheckout/TapFailureException.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/AbstractDevice$Phase.class b/bin/org/lsmr/selfcheckout/devices/AbstractDevice$Phase.class
index f66cc1a..f4b5c50 100644
Binary files a/bin/org/lsmr/selfcheckout/devices/AbstractDevice$Phase.class and b/bin/org/lsmr/selfcheckout/devices/AbstractDevice$Phase.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/AbstractDevice.class b/bin/org/lsmr/selfcheckout/devices/AbstractDevice.class
index 7135fa4..3ce33b9 100644
Binary files a/bin/org/lsmr/selfcheckout/devices/AbstractDevice.class and b/bin/org/lsmr/selfcheckout/devices/AbstractDevice.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/Acceptor.class b/bin/org/lsmr/selfcheckout/devices/Acceptor.class
index 45c016e..9113c51 100644
Binary files a/bin/org/lsmr/selfcheckout/devices/Acceptor.class and b/bin/org/lsmr/selfcheckout/devices/Acceptor.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/BanknoteDispenser.class b/bin/org/lsmr/selfcheckout/devices/BanknoteDispenser.class
index 34485ac..aa24008 100644
Binary files a/bin/org/lsmr/selfcheckout/devices/BanknoteDispenser.class and b/bin/org/lsmr/selfcheckout/devices/BanknoteDispenser.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/BanknoteSlot.class b/bin/org/lsmr/selfcheckout/devices/BanknoteSlot.class
index 79a1500..f729648 100644
Binary files a/bin/org/lsmr/selfcheckout/devices/BanknoteSlot.class and b/bin/org/lsmr/selfcheckout/devices/BanknoteSlot.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/BanknoteStorageUnit.class b/bin/org/lsmr/selfcheckout/devices/BanknoteStorageUnit.class
index 9af0ff3..ea63e8f 100644
Binary files a/bin/org/lsmr/selfcheckout/devices/BanknoteStorageUnit.class and b/bin/org/lsmr/selfcheckout/devices/BanknoteStorageUnit.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/BanknoteValidator.class b/bin/org/lsmr/selfcheckout/devices/BanknoteValidator.class
index c008572..f308fb9 100644
Binary files a/bin/org/lsmr/selfcheckout/devices/BanknoteValidator.class and b/bin/org/lsmr/selfcheckout/devices/BanknoteValidator.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/BarcodeScanner.class b/bin/org/lsmr/selfcheckout/devices/BarcodeScanner.class
index 1b0049f..b46b109 100644
Binary files a/bin/org/lsmr/selfcheckout/devices/BarcodeScanner.class and b/bin/org/lsmr/selfcheckout/devices/BarcodeScanner.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/BidirectionalChannel.class b/bin/org/lsmr/selfcheckout/devices/BidirectionalChannel.class
index adfe35a..c7344b7 100644
Binary files a/bin/org/lsmr/selfcheckout/devices/BidirectionalChannel.class and b/bin/org/lsmr/selfcheckout/devices/BidirectionalChannel.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/CardReader.class b/bin/org/lsmr/selfcheckout/devices/CardReader.class
index bc75481..109a005 100644
Binary files a/bin/org/lsmr/selfcheckout/devices/CardReader.class and b/bin/org/lsmr/selfcheckout/devices/CardReader.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/CoinDispenser.class b/bin/org/lsmr/selfcheckout/devices/CoinDispenser.class
index e949320..2066e9b 100644
Binary files a/bin/org/lsmr/selfcheckout/devices/CoinDispenser.class and b/bin/org/lsmr/selfcheckout/devices/CoinDispenser.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/CoinSlot.class b/bin/org/lsmr/selfcheckout/devices/CoinSlot.class
index b06c85d..781b206 100644
Binary files a/bin/org/lsmr/selfcheckout/devices/CoinSlot.class and b/bin/org/lsmr/selfcheckout/devices/CoinSlot.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/CoinStorageUnit.class b/bin/org/lsmr/selfcheckout/devices/CoinStorageUnit.class
index 4fa1b4f..e755e04 100644
Binary files a/bin/org/lsmr/selfcheckout/devices/CoinStorageUnit.class and b/bin/org/lsmr/selfcheckout/devices/CoinStorageUnit.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/CoinTray.class b/bin/org/lsmr/selfcheckout/devices/CoinTray.class
index 91f3706..6e55b32 100644
Binary files a/bin/org/lsmr/selfcheckout/devices/CoinTray.class and b/bin/org/lsmr/selfcheckout/devices/CoinTray.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/CoinValidator.class b/bin/org/lsmr/selfcheckout/devices/CoinValidator.class
index f87b5f2..fe0c4c9 100644
Binary files a/bin/org/lsmr/selfcheckout/devices/CoinValidator.class and b/bin/org/lsmr/selfcheckout/devices/CoinValidator.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/DisabledException.class b/bin/org/lsmr/selfcheckout/devices/DisabledException.class
index 160c02e..f4bf3c3 100644
Binary files a/bin/org/lsmr/selfcheckout/devices/DisabledException.class and b/bin/org/lsmr/selfcheckout/devices/DisabledException.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/ElectronicScale.class b/bin/org/lsmr/selfcheckout/devices/ElectronicScale.class
index 23e2f9c..8b9ef5d 100644
Binary files a/bin/org/lsmr/selfcheckout/devices/ElectronicScale.class and b/bin/org/lsmr/selfcheckout/devices/ElectronicScale.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/Emitter.class b/bin/org/lsmr/selfcheckout/devices/Emitter.class
index 7a295ba..d2bb395 100644
Binary files a/bin/org/lsmr/selfcheckout/devices/Emitter.class and b/bin/org/lsmr/selfcheckout/devices/Emitter.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/EmptyException.class b/bin/org/lsmr/selfcheckout/devices/EmptyException.class
index 877ad17..1aa1d89 100644
Binary files a/bin/org/lsmr/selfcheckout/devices/EmptyException.class and b/bin/org/lsmr/selfcheckout/devices/EmptyException.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/FlowThroughEmitter.class b/bin/org/lsmr/selfcheckout/devices/FlowThroughEmitter.class
index c8cb670..0577624 100644
Binary files a/bin/org/lsmr/selfcheckout/devices/FlowThroughEmitter.class and b/bin/org/lsmr/selfcheckout/devices/FlowThroughEmitter.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/FromStorageEmitter.class b/bin/org/lsmr/selfcheckout/devices/FromStorageEmitter.class
index 962fb88..1e1ffbd 100644
Binary files a/bin/org/lsmr/selfcheckout/devices/FromStorageEmitter.class and b/bin/org/lsmr/selfcheckout/devices/FromStorageEmitter.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/OverloadException.class b/bin/org/lsmr/selfcheckout/devices/OverloadException.class
index 026d948..6ab58bc 100644
Binary files a/bin/org/lsmr/selfcheckout/devices/OverloadException.class and b/bin/org/lsmr/selfcheckout/devices/OverloadException.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/ReceiptPrinter.class b/bin/org/lsmr/selfcheckout/devices/ReceiptPrinter.class
index a3cbbad..a7104d5 100644
Binary files a/bin/org/lsmr/selfcheckout/devices/ReceiptPrinter.class and b/bin/org/lsmr/selfcheckout/devices/ReceiptPrinter.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/SelfCheckoutStation.class b/bin/org/lsmr/selfcheckout/devices/SelfCheckoutStation.class
index d8362c2..56e7dfc 100644
Binary files a/bin/org/lsmr/selfcheckout/devices/SelfCheckoutStation.class and b/bin/org/lsmr/selfcheckout/devices/SelfCheckoutStation.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/SimulationException.class b/bin/org/lsmr/selfcheckout/devices/SimulationException.class
index 4f0bdb9..2b4c563 100644
Binary files a/bin/org/lsmr/selfcheckout/devices/SimulationException.class and b/bin/org/lsmr/selfcheckout/devices/SimulationException.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/UnidirectionalChannel.class b/bin/org/lsmr/selfcheckout/devices/UnidirectionalChannel.class
index 4dc61ad..a24b91e 100644
Binary files a/bin/org/lsmr/selfcheckout/devices/UnidirectionalChannel.class and b/bin/org/lsmr/selfcheckout/devices/UnidirectionalChannel.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/AbstractDeviceObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/AbstractDeviceObserver.class
index 185b861..247e22d 100644
Binary files a/bin/org/lsmr/selfcheckout/devices/observers/AbstractDeviceObserver.class and b/bin/org/lsmr/selfcheckout/devices/observers/AbstractDeviceObserver.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/BanknoteDispenserObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/BanknoteDispenserObserver.class
index dcb2f02..2d6cddc 100644
Binary files a/bin/org/lsmr/selfcheckout/devices/observers/BanknoteDispenserObserver.class and b/bin/org/lsmr/selfcheckout/devices/observers/BanknoteDispenserObserver.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/BanknoteSlotObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/BanknoteSlotObserver.class
index a89eead..221e426 100644
Binary files a/bin/org/lsmr/selfcheckout/devices/observers/BanknoteSlotObserver.class and b/bin/org/lsmr/selfcheckout/devices/observers/BanknoteSlotObserver.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/BanknoteStorageUnitObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/BanknoteStorageUnitObserver.class
index 2671b9f..043983d 100644
Binary files a/bin/org/lsmr/selfcheckout/devices/observers/BanknoteStorageUnitObserver.class and b/bin/org/lsmr/selfcheckout/devices/observers/BanknoteStorageUnitObserver.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/BanknoteValidatorObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/BanknoteValidatorObserver.class
index 2f6bb87..8838fb1 100644
Binary files a/bin/org/lsmr/selfcheckout/devices/observers/BanknoteValidatorObserver.class and b/bin/org/lsmr/selfcheckout/devices/observers/BanknoteValidatorObserver.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/BarcodeScannerObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/BarcodeScannerObserver.class
index 7c4bb1e..56fc44a 100644
Binary files a/bin/org/lsmr/selfcheckout/devices/observers/BarcodeScannerObserver.class and b/bin/org/lsmr/selfcheckout/devices/observers/BarcodeScannerObserver.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/CardReaderObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/CardReaderObserver.class
index 1718764..26fe866 100644
Binary files a/bin/org/lsmr/selfcheckout/devices/observers/CardReaderObserver.class and b/bin/org/lsmr/selfcheckout/devices/observers/CardReaderObserver.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/CoinDispenserObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/CoinDispenserObserver.class
index 9283409..057849f 100644
Binary files a/bin/org/lsmr/selfcheckout/devices/observers/CoinDispenserObserver.class and b/bin/org/lsmr/selfcheckout/devices/observers/CoinDispenserObserver.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/CoinSlotObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/CoinSlotObserver.class
index 3b00362..af69753 100644
Binary files a/bin/org/lsmr/selfcheckout/devices/observers/CoinSlotObserver.class and b/bin/org/lsmr/selfcheckout/devices/observers/CoinSlotObserver.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/CoinStorageUnitObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/CoinStorageUnitObserver.class
index da91d12..f6b4b05 100644
Binary files a/bin/org/lsmr/selfcheckout/devices/observers/CoinStorageUnitObserver.class and b/bin/org/lsmr/selfcheckout/devices/observers/CoinStorageUnitObserver.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/CoinTrayObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/CoinTrayObserver.class
index bf26991..6bd2a6e 100644
Binary files a/bin/org/lsmr/selfcheckout/devices/observers/CoinTrayObserver.class and b/bin/org/lsmr/selfcheckout/devices/observers/CoinTrayObserver.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/CoinValidatorObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/CoinValidatorObserver.class
index 817e5dc..a1b2c79 100644
Binary files a/bin/org/lsmr/selfcheckout/devices/observers/CoinValidatorObserver.class and b/bin/org/lsmr/selfcheckout/devices/observers/CoinValidatorObserver.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/ElectronicScaleObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/ElectronicScaleObserver.class
index cfcc4eb..af886a7 100644
Binary files a/bin/org/lsmr/selfcheckout/devices/observers/ElectronicScaleObserver.class and b/bin/org/lsmr/selfcheckout/devices/observers/ElectronicScaleObserver.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/ReceiptPrinterObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/ReceiptPrinterObserver.class
index f4d748e..d93a2ee 100644
Binary files a/bin/org/lsmr/selfcheckout/devices/observers/ReceiptPrinterObserver.class and b/bin/org/lsmr/selfcheckout/devices/observers/ReceiptPrinterObserver.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/TouchScreenObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/TouchScreenObserver.class
index 9e96845..ea9378e 100644
Binary files a/bin/org/lsmr/selfcheckout/devices/observers/TouchScreenObserver.class and b/bin/org/lsmr/selfcheckout/devices/observers/TouchScreenObserver.class differ
diff --git a/bin/org/lsmr/selfcheckout/products/BarcodedProduct.class b/bin/org/lsmr/selfcheckout/products/BarcodedProduct.class
index 5d971c7..bd46533 100644
Binary files a/bin/org/lsmr/selfcheckout/products/BarcodedProduct.class and b/bin/org/lsmr/selfcheckout/products/BarcodedProduct.class differ
diff --git a/bin/org/lsmr/selfcheckout/products/PLUCodedProduct.class b/bin/org/lsmr/selfcheckout/products/PLUCodedProduct.class
index 2c232ee..95698b3 100644
Binary files a/bin/org/lsmr/selfcheckout/products/PLUCodedProduct.class and b/bin/org/lsmr/selfcheckout/products/PLUCodedProduct.class differ
diff --git a/bin/org/lsmr/selfcheckout/products/Product.class b/bin/org/lsmr/selfcheckout/products/Product.class
index e0f34c2..c7ee9be 100644
Binary files a/bin/org/lsmr/selfcheckout/products/Product.class and b/bin/org/lsmr/selfcheckout/products/Product.class differ
diff --git a/src/.project b/src/.project
new file mode 100644
index 0000000..0f6f6a7
--- /dev/null
+++ b/src/.project
@@ -0,0 +1,17 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>src</name>
+	<comment></comment>
+	<projects>
+	</projects>
+	<buildSpec>
+		<buildCommand>
+			<name>org.eclipse.jdt.core.javabuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+	</buildSpec>
+	<natures>
+		<nature>org.eclipse.jdt.core.javanature</nature>
+	</natures>
+</projectDescription>
diff --git a/src/BanknoteController.java b/src/selfcheckout_software/BanknoteController.java
similarity index 98%
rename from src/BanknoteController.java
rename to src/selfcheckout_software/BanknoteController.java
index 7c00f37..276cac9 100644
--- a/src/BanknoteController.java
+++ b/src/selfcheckout_software/BanknoteController.java
@@ -1,3 +1,4 @@
+package selfcheckout_software;
 import java.math.BigDecimal;
 import java.util.Currency;
 
diff --git a/src/selfcheckout_software/SCSLogic.java b/src/selfcheckout_software/SCSLogic.java
new file mode 100644
index 0000000..d466e31
--- /dev/null
+++ b/src/selfcheckout_software/SCSLogic.java
@@ -0,0 +1,83 @@
+package selfcheckout_software;
+
+import org.lsmr.selfcheckout.devices.AbstractDevice;
+import org.lsmr.selfcheckout.devices.Acceptor;
+import org.lsmr.selfcheckout.devices.DisabledException;
+import org.lsmr.selfcheckout.devices.ElectronicScale;
+import org.lsmr.selfcheckout.devices.OverloadException;
+import org.lsmr.selfcheckout.devices.SimulationException;
+import org.lsmr.selfcheckout.devices.observers.AbstractDeviceObserver;
+
+public class SCSLogic extends AbstractDevice<AbstractDeviceObserver> implements Acceptor<AbstractDeviceObserver>{
+	
+	private ElectronicScale electronic;
+	
+	
+	
+	
+	public SCSLogic(ElectronicScale e) {
+		this.electronic = e;
+	}
+	
+	
+	
+	
+	public void wish_checkout(AbstractDeviceObserver payment_method) throws OverloadException, DisabledException  {
+		
+		try {
+			this.attach(payment_method);
+			while(true) {
+				if (!electronic.isDisabled()) {  // keep checking the weight of bagging area, check if the weight has changed
+					
+					this.accept(payment_method);
+					
+					if (this.isDisabled()) {
+						break;
+					}
+					else { //this should never been run
+						throw new SimulationException("can't receive payment method");
+					}
+					
+				}
+				else {
+					throw new SimulationException("the weight has changed");
+				}
+				
+			}
+			//....might need to call the matched payment method
+			
+		} catch (OverloadException e) {
+			throw e;
+		}catch (DisabledException e) {
+		    throw e;
+		}
+		
+		
+		
+		
+		
+	}
+
+
+
+
+
+
+
+
+
+
+	@Override
+	public void accept(AbstractDeviceObserver thing) throws OverloadException, DisabledException {
+			thing.enabled(this);
+	}
+
+
+
+	@Override
+	public boolean hasSpace() { //not used yet
+		// TODO Auto-generated method stub
+		return false;
+	}
+	
+}
diff --git a/src/selfcheckout_test/AbstractDeviceObserverStub.java b/src/selfcheckout_test/AbstractDeviceObserverStub.java
new file mode 100644
index 0000000..5d7fe00
--- /dev/null
+++ b/src/selfcheckout_test/AbstractDeviceObserverStub.java
@@ -0,0 +1,19 @@
+package selfcheckout_test;
+
+import org.lsmr.selfcheckout.devices.AbstractDevice;
+import org.lsmr.selfcheckout.devices.observers.AbstractDeviceObserver;
+
+public class AbstractDeviceObserverStub implements AbstractDeviceObserver {
+
+	@Override
+	public void enabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
+		device.disable();	
+	}
+
+	@Override
+	public void disabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
+		// TODO Auto-generated method stub
+		
+	}
+
+}
diff --git a/src/selfcheckout_test/ElectronicScaleObserverStub.java b/src/selfcheckout_test/ElectronicScaleObserverStub.java
new file mode 100644
index 0000000..4f713f4
--- /dev/null
+++ b/src/selfcheckout_test/ElectronicScaleObserverStub.java
@@ -0,0 +1,40 @@
+package selfcheckout_test;
+
+import org.lsmr.selfcheckout.devices.AbstractDevice;
+import org.lsmr.selfcheckout.devices.ElectronicScale;
+import org.lsmr.selfcheckout.devices.observers.AbstractDeviceObserver;
+import org.lsmr.selfcheckout.devices.observers.ElectronicScaleObserver;
+
+public class ElectronicScaleObserverStub implements ElectronicScaleObserver {
+
+	@Override
+	public void enabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
+		// TODO Auto-generated method stub
+		
+	}
+
+	@Override
+	public void disabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
+		// TODO Auto-generated method stub
+		
+	}
+
+	@Override
+	public void weightChanged(ElectronicScale scale, double weightInGrams) {
+		scale.disable();
+		
+	}
+
+	@Override
+	public void overload(ElectronicScale scale) {
+		// TODO Auto-generated method stub
+		
+	}
+
+	@Override
+	public void outOfOverload(ElectronicScale scale) {
+		// TODO Auto-generated method stub
+		
+	}
+
+}
diff --git a/src/selfcheckout_test/test_wish_to_checkout.java b/src/selfcheckout_test/test_wish_to_checkout.java
new file mode 100644
index 0000000..b4347f4
--- /dev/null
+++ b/src/selfcheckout_test/test_wish_to_checkout.java
@@ -0,0 +1,69 @@
+package selfcheckout_test;
+
+import selfcheckout_software.*;
+import static org.junit.Assert.*;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.lsmr.selfcheckout.Item;
+import org.lsmr.selfcheckout.devices.AbstractDevice;
+import org.lsmr.selfcheckout.devices.DisabledException;
+import org.lsmr.selfcheckout.devices.ElectronicScale;
+import org.lsmr.selfcheckout.devices.OverloadException;
+import org.lsmr.selfcheckout.devices.SimulationException;
+import org.lsmr.selfcheckout.devices.observers.AbstractDeviceObserver;
+
+import junit.extensions.TestSetup;
+import junit.framework.Assert;
+
+public class test_wish_to_checkout {
+
+	private SCSLogic test_object;
+	private AbstractDeviceObserverStub payment;
+	private ElectronicScaleObserverStub w_observer;
+	private ElectronicScale E;
+	
+	@Before
+	public void TestSetup() {
+		this.E = new ElectronicScale(100, 1);
+		this.test_object = new SCSLogic(E);
+		this.payment = new AbstractDeviceObserverStub();
+		this.w_observer = new ElectronicScaleObserverStub();
+		
+	}
+	
+	@Test(expected = SimulationException.class)
+	public void test_attachment() throws OverloadException, DisabledException {
+		test_object.wish_checkout(payment);
+		test_object.detach(payment);
+		test_object.detach(payment);
+	}
+	
+	@Test(expected = SimulationException.class)
+	public void test_weight_changed() throws OverloadException, DisabledException {
+		E.attach(w_observer);
+		Item test_item1 = new Item(20) {};
+		Item test_item2 = new Item(40) {};
+		E.add(test_item1);
+		E.enable();
+		
+		E.add(test_item2);
+		
+		test_object.wish_checkout(payment);
+		
+	}
+	
+	@Test
+	public void test_normal_wish() throws OverloadException, DisabledException {
+		test_object.endConfigurationPhase();
+		E.attach(w_observer);
+		E.endConfigurationPhase();
+		E.enable();
+		test_object.wish_checkout(payment);
+		assertTrue("this should be true",test_object.isDisabled());
+		
+		
+	}
+	
+
+}

commit 9df66fb9f6fa5f4e2e66bc6774ecb962cc9bb7ca
Merge: 4e56cc6 c2b6530
Author: lexahoa <sparr@LAPTOP-V521ED67>
Date:   Fri Mar 18 20:36:32 2022 -0400

    Merge branch 'master' of https://github.com/kev9268/SENGProject

commit 4e56cc6bdbf63ef8e4f3a3d807d3913e10b83769
Author: lexahoa <sparr@LAPTOP-V521ED67>
Date:   Fri Mar 18 20:33:51 2022 -0400

    "delete"

diff --git a/.classpath b/.classpath
deleted file mode 100644
index 6a189c4..0000000
--- a/.classpath
+++ /dev/null
@@ -1,7 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<classpath>
-	<classpathentry kind="src" path="src"/>
-	<classpathentry kind="con" path="org.eclipse.jdt.junit.JUNIT_CONTAINER/4"/>
-	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER"/>
-	<classpathentry kind="output" path="bin"/>
-</classpath>
diff --git a/.project b/.project
deleted file mode 100644
index 57573c6..0000000
--- a/.project
+++ /dev/null
@@ -1,17 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<projectDescription>
-	<name>SCS - Hardware - v1.0</name>
-	<comment></comment>
-	<projects>
-	</projects>
-	<buildSpec>
-		<buildCommand>
-			<name>org.eclipse.jdt.core.javabuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-	</buildSpec>
-	<natures>
-		<nature>org.eclipse.jdt.core.javanature</nature>
-	</natures>
-</projectDescription>
diff --git a/.settings/org.eclipse.jdt.core.prefs b/.settings/org.eclipse.jdt.core.prefs
deleted file mode 100644
index bb35fa0..0000000
--- a/.settings/org.eclipse.jdt.core.prefs
+++ /dev/null
@@ -1,11 +0,0 @@
-eclipse.preferences.version=1
-org.eclipse.jdt.core.compiler.codegen.inlineJsrBytecode=enabled
-org.eclipse.jdt.core.compiler.codegen.targetPlatform=1.8
-org.eclipse.jdt.core.compiler.codegen.unusedLocal=preserve
-org.eclipse.jdt.core.compiler.compliance=1.8
-org.eclipse.jdt.core.compiler.debug.lineNumber=generate
-org.eclipse.jdt.core.compiler.debug.localVariable=generate
-org.eclipse.jdt.core.compiler.debug.sourceFile=generate
-org.eclipse.jdt.core.compiler.problem.assertIdentifier=error
-org.eclipse.jdt.core.compiler.problem.enumIdentifier=error
-org.eclipse.jdt.core.compiler.source=1.8
diff --git a/README.txt b/README.txt
deleted file mode 100644
index 3c74dda..0000000
--- a/README.txt
+++ /dev/null
@@ -1,28 +0,0 @@
-Requirements:
-1.Customer scans an item -(James, Bassel)
-  -Takes in barcode of item
-  -Gathers items information (Price,weight,etc)
-  -Adds cost of item to currect cost
-2.Customer places item in bagging area (Kevin)
-  -Checks for weight of item
-  -Get current weight for electronic scale
-  -Expect new weight on the electronic scale to be the addition of the weight of newly scanned item
-3.Customer wishes to checkout (zhongmin)
-  -keep looping and checking the weight
-  -check how the customer willing to pay (e.g. button pressed)
-4.Customer pays with a coin (Justin)
-  -Coin slot observer to check if slot is open
-  -Observe what coin inserted
-  -Add ammount of money based on what coin was inserted
-  -Check if cost is reached everytime coin is inserted
-5.Customer pays with a banknote - (Manbir)
-  -Banknote slot observer to check if slot is open
-  -Observe what banknote inserted
-  -Add ammount of money based on what banknote was inserted
-  -Check if cost is reached everytime banknote is inserted
-
-TestCases:
--Each person who works on the software control also works on the test cases.
--Check your partner's test cases (2 and 4 check each other's test case, and 3 and 5 check each other's test cases)
--If you think your partner is missing a test case for their task, you can message them to tell them what they should add (you can also add it yourself but that might get messy so it's best to check)
--1 will be 2 people, who will both work on the test cases and version control.
diff --git a/bin/org/lsmr/selfcheckout/Banknote.class b/bin/org/lsmr/selfcheckout/Banknote.class
deleted file mode 100644
index fbc21cf..0000000
Binary files a/bin/org/lsmr/selfcheckout/Banknote.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/Barcode.class b/bin/org/lsmr/selfcheckout/Barcode.class
deleted file mode 100644
index 5cea197..0000000
Binary files a/bin/org/lsmr/selfcheckout/Barcode.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/BarcodedItem.class b/bin/org/lsmr/selfcheckout/BarcodedItem.class
deleted file mode 100644
index 2d68447..0000000
Binary files a/bin/org/lsmr/selfcheckout/BarcodedItem.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/BlockedCardException.class b/bin/org/lsmr/selfcheckout/BlockedCardException.class
deleted file mode 100644
index 536dd3d..0000000
Binary files a/bin/org/lsmr/selfcheckout/BlockedCardException.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/Card$CardData.class b/bin/org/lsmr/selfcheckout/Card$CardData.class
deleted file mode 100644
index 795e5b4..0000000
Binary files a/bin/org/lsmr/selfcheckout/Card$CardData.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/Card$CardInsertData.class b/bin/org/lsmr/selfcheckout/Card$CardInsertData.class
deleted file mode 100644
index a2d7141..0000000
Binary files a/bin/org/lsmr/selfcheckout/Card$CardInsertData.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/Card$CardSwipeData.class b/bin/org/lsmr/selfcheckout/Card$CardSwipeData.class
deleted file mode 100644
index a72d8a2..0000000
Binary files a/bin/org/lsmr/selfcheckout/Card$CardSwipeData.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/Card$CardTapData.class b/bin/org/lsmr/selfcheckout/Card$CardTapData.class
deleted file mode 100644
index 8efccff..0000000
Binary files a/bin/org/lsmr/selfcheckout/Card$CardTapData.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/Card.class b/bin/org/lsmr/selfcheckout/Card.class
deleted file mode 100644
index 262b944..0000000
Binary files a/bin/org/lsmr/selfcheckout/Card.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/ChipFailureException.class b/bin/org/lsmr/selfcheckout/ChipFailureException.class
deleted file mode 100644
index fa389c2..0000000
Binary files a/bin/org/lsmr/selfcheckout/ChipFailureException.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/Coin.class b/bin/org/lsmr/selfcheckout/Coin.class
deleted file mode 100644
index 67690f1..0000000
Binary files a/bin/org/lsmr/selfcheckout/Coin.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/IllegalDigitException.class b/bin/org/lsmr/selfcheckout/IllegalDigitException.class
deleted file mode 100644
index be8be69..0000000
Binary files a/bin/org/lsmr/selfcheckout/IllegalDigitException.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/InvalidPINException.class b/bin/org/lsmr/selfcheckout/InvalidPINException.class
deleted file mode 100644
index c08cda6..0000000
Binary files a/bin/org/lsmr/selfcheckout/InvalidPINException.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/Item.class b/bin/org/lsmr/selfcheckout/Item.class
deleted file mode 100644
index 69e38c1..0000000
Binary files a/bin/org/lsmr/selfcheckout/Item.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/MagneticStripeFailureException.class b/bin/org/lsmr/selfcheckout/MagneticStripeFailureException.class
deleted file mode 100644
index 0f8b1e6..0000000
Binary files a/bin/org/lsmr/selfcheckout/MagneticStripeFailureException.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/Numeral.class b/bin/org/lsmr/selfcheckout/Numeral.class
deleted file mode 100644
index ac8cc6e..0000000
Binary files a/bin/org/lsmr/selfcheckout/Numeral.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/PLUCodedItem.class b/bin/org/lsmr/selfcheckout/PLUCodedItem.class
deleted file mode 100644
index 941940c..0000000
Binary files a/bin/org/lsmr/selfcheckout/PLUCodedItem.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/PriceLookupCode.class b/bin/org/lsmr/selfcheckout/PriceLookupCode.class
deleted file mode 100644
index 0884227..0000000
Binary files a/bin/org/lsmr/selfcheckout/PriceLookupCode.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/TapFailureException.class b/bin/org/lsmr/selfcheckout/TapFailureException.class
deleted file mode 100644
index 8d9b145..0000000
Binary files a/bin/org/lsmr/selfcheckout/TapFailureException.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/devices/AbstractDevice$Phase.class b/bin/org/lsmr/selfcheckout/devices/AbstractDevice$Phase.class
deleted file mode 100644
index 1dae3ed..0000000
Binary files a/bin/org/lsmr/selfcheckout/devices/AbstractDevice$Phase.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/devices/AbstractDevice.class b/bin/org/lsmr/selfcheckout/devices/AbstractDevice.class
deleted file mode 100644
index aff6c5e..0000000
Binary files a/bin/org/lsmr/selfcheckout/devices/AbstractDevice.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/devices/Acceptor.class b/bin/org/lsmr/selfcheckout/devices/Acceptor.class
deleted file mode 100644
index 9043506..0000000
Binary files a/bin/org/lsmr/selfcheckout/devices/Acceptor.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/devices/BanknoteDispenser.class b/bin/org/lsmr/selfcheckout/devices/BanknoteDispenser.class
deleted file mode 100644
index a829b5d..0000000
Binary files a/bin/org/lsmr/selfcheckout/devices/BanknoteDispenser.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/devices/BanknoteSlot.class b/bin/org/lsmr/selfcheckout/devices/BanknoteSlot.class
deleted file mode 100644
index f18b4a4..0000000
Binary files a/bin/org/lsmr/selfcheckout/devices/BanknoteSlot.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/devices/BanknoteStorageUnit.class b/bin/org/lsmr/selfcheckout/devices/BanknoteStorageUnit.class
deleted file mode 100644
index 21d4eff..0000000
Binary files a/bin/org/lsmr/selfcheckout/devices/BanknoteStorageUnit.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/devices/BanknoteValidator.class b/bin/org/lsmr/selfcheckout/devices/BanknoteValidator.class
deleted file mode 100644
index a42c54f..0000000
Binary files a/bin/org/lsmr/selfcheckout/devices/BanknoteValidator.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/devices/BarcodeScanner.class b/bin/org/lsmr/selfcheckout/devices/BarcodeScanner.class
deleted file mode 100644
index 093246f..0000000
Binary files a/bin/org/lsmr/selfcheckout/devices/BarcodeScanner.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/devices/BidirectionalChannel.class b/bin/org/lsmr/selfcheckout/devices/BidirectionalChannel.class
deleted file mode 100644
index 8ae0603..0000000
Binary files a/bin/org/lsmr/selfcheckout/devices/BidirectionalChannel.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/devices/CardReader.class b/bin/org/lsmr/selfcheckout/devices/CardReader.class
deleted file mode 100644
index 1a090b0..0000000
Binary files a/bin/org/lsmr/selfcheckout/devices/CardReader.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/devices/CoinDispenser.class b/bin/org/lsmr/selfcheckout/devices/CoinDispenser.class
deleted file mode 100644
index d069691..0000000
Binary files a/bin/org/lsmr/selfcheckout/devices/CoinDispenser.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/devices/CoinSlot.class b/bin/org/lsmr/selfcheckout/devices/CoinSlot.class
deleted file mode 100644
index db8f809..0000000
Binary files a/bin/org/lsmr/selfcheckout/devices/CoinSlot.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/devices/CoinStorageUnit.class b/bin/org/lsmr/selfcheckout/devices/CoinStorageUnit.class
deleted file mode 100644
index db1e2c4..0000000
Binary files a/bin/org/lsmr/selfcheckout/devices/CoinStorageUnit.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/devices/CoinTray.class b/bin/org/lsmr/selfcheckout/devices/CoinTray.class
deleted file mode 100644
index 6f49c78..0000000
Binary files a/bin/org/lsmr/selfcheckout/devices/CoinTray.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/devices/CoinValidator.class b/bin/org/lsmr/selfcheckout/devices/CoinValidator.class
deleted file mode 100644
index de514e7..0000000
Binary files a/bin/org/lsmr/selfcheckout/devices/CoinValidator.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/devices/DisabledException.class b/bin/org/lsmr/selfcheckout/devices/DisabledException.class
deleted file mode 100644
index 5c66261..0000000
Binary files a/bin/org/lsmr/selfcheckout/devices/DisabledException.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/devices/ElectronicScale.class b/bin/org/lsmr/selfcheckout/devices/ElectronicScale.class
deleted file mode 100644
index a9314d0..0000000
Binary files a/bin/org/lsmr/selfcheckout/devices/ElectronicScale.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/devices/Emitter.class b/bin/org/lsmr/selfcheckout/devices/Emitter.class
deleted file mode 100644
index b23e858..0000000
Binary files a/bin/org/lsmr/selfcheckout/devices/Emitter.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/devices/EmptyException.class b/bin/org/lsmr/selfcheckout/devices/EmptyException.class
deleted file mode 100644
index dc98a0f..0000000
Binary files a/bin/org/lsmr/selfcheckout/devices/EmptyException.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/devices/FlowThroughEmitter.class b/bin/org/lsmr/selfcheckout/devices/FlowThroughEmitter.class
deleted file mode 100644
index 7db53cc..0000000
Binary files a/bin/org/lsmr/selfcheckout/devices/FlowThroughEmitter.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/devices/FromStorageEmitter.class b/bin/org/lsmr/selfcheckout/devices/FromStorageEmitter.class
deleted file mode 100644
index bc15cfc..0000000
Binary files a/bin/org/lsmr/selfcheckout/devices/FromStorageEmitter.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/devices/OverloadException.class b/bin/org/lsmr/selfcheckout/devices/OverloadException.class
deleted file mode 100644
index ce0e2cd..0000000
Binary files a/bin/org/lsmr/selfcheckout/devices/OverloadException.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/devices/ReceiptPrinter.class b/bin/org/lsmr/selfcheckout/devices/ReceiptPrinter.class
deleted file mode 100644
index 4db506b..0000000
Binary files a/bin/org/lsmr/selfcheckout/devices/ReceiptPrinter.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/devices/SelfCheckoutStation.class b/bin/org/lsmr/selfcheckout/devices/SelfCheckoutStation.class
deleted file mode 100644
index 4c8882f..0000000
Binary files a/bin/org/lsmr/selfcheckout/devices/SelfCheckoutStation.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/devices/SimulationException.class b/bin/org/lsmr/selfcheckout/devices/SimulationException.class
deleted file mode 100644
index d616ae5..0000000
Binary files a/bin/org/lsmr/selfcheckout/devices/SimulationException.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/devices/UnidirectionalChannel.class b/bin/org/lsmr/selfcheckout/devices/UnidirectionalChannel.class
deleted file mode 100644
index 964485e..0000000
Binary files a/bin/org/lsmr/selfcheckout/devices/UnidirectionalChannel.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/AbstractDeviceObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/AbstractDeviceObserver.class
deleted file mode 100644
index 3b3f3af..0000000
Binary files a/bin/org/lsmr/selfcheckout/devices/observers/AbstractDeviceObserver.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/BanknoteDispenserObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/BanknoteDispenserObserver.class
deleted file mode 100644
index ef277e1..0000000
Binary files a/bin/org/lsmr/selfcheckout/devices/observers/BanknoteDispenserObserver.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/BanknoteSlotObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/BanknoteSlotObserver.class
deleted file mode 100644
index 8fa6c54..0000000
Binary files a/bin/org/lsmr/selfcheckout/devices/observers/BanknoteSlotObserver.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/BanknoteStorageUnitObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/BanknoteStorageUnitObserver.class
deleted file mode 100644
index dbec2ad..0000000
Binary files a/bin/org/lsmr/selfcheckout/devices/observers/BanknoteStorageUnitObserver.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/BanknoteValidatorObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/BanknoteValidatorObserver.class
deleted file mode 100644
index b779d7e..0000000
Binary files a/bin/org/lsmr/selfcheckout/devices/observers/BanknoteValidatorObserver.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/BarcodeScannerObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/BarcodeScannerObserver.class
deleted file mode 100644
index 3ef8e5f..0000000
Binary files a/bin/org/lsmr/selfcheckout/devices/observers/BarcodeScannerObserver.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/CardReaderObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/CardReaderObserver.class
deleted file mode 100644
index 21606de..0000000
Binary files a/bin/org/lsmr/selfcheckout/devices/observers/CardReaderObserver.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/CoinDispenserObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/CoinDispenserObserver.class
deleted file mode 100644
index 7910341..0000000
Binary files a/bin/org/lsmr/selfcheckout/devices/observers/CoinDispenserObserver.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/CoinSlotObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/CoinSlotObserver.class
deleted file mode 100644
index bd71242..0000000
Binary files a/bin/org/lsmr/selfcheckout/devices/observers/CoinSlotObserver.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/CoinStorageUnitObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/CoinStorageUnitObserver.class
deleted file mode 100644
index b922285..0000000
Binary files a/bin/org/lsmr/selfcheckout/devices/observers/CoinStorageUnitObserver.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/CoinTrayObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/CoinTrayObserver.class
deleted file mode 100644
index 1391af5..0000000
Binary files a/bin/org/lsmr/selfcheckout/devices/observers/CoinTrayObserver.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/CoinValidatorObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/CoinValidatorObserver.class
deleted file mode 100644
index b11003b..0000000
Binary files a/bin/org/lsmr/selfcheckout/devices/observers/CoinValidatorObserver.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/ElectronicScaleObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/ElectronicScaleObserver.class
deleted file mode 100644
index 6bf0d70..0000000
Binary files a/bin/org/lsmr/selfcheckout/devices/observers/ElectronicScaleObserver.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/ReceiptPrinterObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/ReceiptPrinterObserver.class
deleted file mode 100644
index 9cd53cf..0000000
Binary files a/bin/org/lsmr/selfcheckout/devices/observers/ReceiptPrinterObserver.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/TouchScreenObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/TouchScreenObserver.class
deleted file mode 100644
index ef726bb..0000000
Binary files a/bin/org/lsmr/selfcheckout/devices/observers/TouchScreenObserver.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/products/BarcodedProduct.class b/bin/org/lsmr/selfcheckout/products/BarcodedProduct.class
deleted file mode 100644
index aba29ee..0000000
Binary files a/bin/org/lsmr/selfcheckout/products/BarcodedProduct.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/products/PLUCodedProduct.class b/bin/org/lsmr/selfcheckout/products/PLUCodedProduct.class
deleted file mode 100644
index 80746e5..0000000
Binary files a/bin/org/lsmr/selfcheckout/products/PLUCodedProduct.class and /dev/null differ
diff --git a/bin/org/lsmr/selfcheckout/products/Product.class b/bin/org/lsmr/selfcheckout/products/Product.class
deleted file mode 100644
index b3888c1..0000000
Binary files a/bin/org/lsmr/selfcheckout/products/Product.class and /dev/null differ
diff --git a/src/.classpath b/src/.classpath
deleted file mode 100644
index 483d8d0..0000000
--- a/src/.classpath
+++ /dev/null
@@ -1,12 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<classpath>
-	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER">
-		<attributes>
-			<attribute name="module" value="true"/>
-		</attributes>
-	</classpathentry>
-	<classpathentry kind="con" path="org.eclipse.jdt.junit.JUNIT_CONTAINER/4"/>
-	<classpathentry kind="src" path=""/>
-	<classpathentry kind="src" path="/SCS - Hardware - v0.3"/>
-	<classpathentry kind="output" path=""/>
-</classpath>
diff --git a/src/.project b/src/.project
deleted file mode 100644
index 0f6f6a7..0000000
--- a/src/.project
+++ /dev/null
@@ -1,17 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<projectDescription>
-	<name>src</name>
-	<comment></comment>
-	<projects>
-	</projects>
-	<buildSpec>
-		<buildCommand>
-			<name>org.eclipse.jdt.core.javabuilder</name>
-			<arguments>
-			</arguments>
-		</buildCommand>
-	</buildSpec>
-	<natures>
-		<nature>org.eclipse.jdt.core.javanature</nature>
-	</natures>
-</projectDescription>
diff --git a/src/org/lsmr/selfcheckout/.gitignore b/src/org/lsmr/selfcheckout/.gitignore
deleted file mode 100644
index 8741d12..0000000
--- a/src/org/lsmr/selfcheckout/.gitignore
+++ /dev/null
@@ -1,12 +0,0 @@
-/Banknote.class
-/Barcode.class
-/BarcodedItem.class
-/BlockedCardException.class
-/Card$CardData.class
-/Card$CardInsertData.class
-/Card$CardSwipeData.class
-/Card$CardTapData.class
-/Card.class
-/ChipFailureException.class
-/Coin.class
-/SCSLogic.class
diff --git a/src/org/lsmr/selfcheckout/Banknote.java b/src/org/lsmr/selfcheckout/Banknote.java
deleted file mode 100644
index ad0981e..0000000
--- a/src/org/lsmr/selfcheckout/Banknote.java
+++ /dev/null
@@ -1,66 +0,0 @@
-package org.lsmr.selfcheckout;
-
-import java.math.BigDecimal;
-import java.util.Currency;
-
-import org.lsmr.selfcheckout.devices.SimulationException;
-
-/**
- * Instances of this class represent individual banknotes. The value of a
- * banknote is assumed to always be a positive integer multiple of the base
- * currency.
- */
-public class Banknote {
-	private int value;
-	private Currency currency;
-
-	/**
-	 * Constructs a banknote.
-	 * @param currency
-	 *            The currency represented by this banknote.
-	 * @param value
-	 *            The value of the banknote, in multiples of the unit of currency.
-	 * 
-	 * @throws SimulationException
-	 *             If the value is &le;0.
-	 * @throws SimulationException
-	 *             If currency is null.
-	 */
-	public Banknote(Currency currency, int value) {
-		if(currency == null)
-			throw new SimulationException(new NullPointerException("currency is null"));
-
-		if(value <= 0)
-			throw new SimulationException(
-				new IllegalArgumentException("The value must be greater than 0: the argument passed was " + value));
-
-		this.value = value;
-		this.currency = currency;
-	}
-
-	/**
-	 * Accessor for the value.
-	 * 
-	 * @return The value of the banknote. Should always be &gt;0.
-	 */
-	public int getValue() {
-		return value;
-	}
-
-	/**
-	 * Accessor for the currency.
-	 * 
-	 * @return The currency for this banknote. Note that this is not the same as the
-	 *             "denomination" (e.g., a Canadian $10 bill is worth 10 Canadian
-	 *             dollars, so a Canadian $10 bill would have currency "Canadian
-	 *             dollars").
-	 */
-	public Currency getCurrency() {
-		return currency;
-	}
-
-	@Override
-	public String toString() {
-		return Integer.toString(value) + " " + currency;
-	}
-}
diff --git a/src/org/lsmr/selfcheckout/Barcode.java b/src/org/lsmr/selfcheckout/Barcode.java
deleted file mode 100644
index b989b61..0000000
--- a/src/org/lsmr/selfcheckout/Barcode.java
+++ /dev/null
@@ -1,109 +0,0 @@
-package org.lsmr.selfcheckout;
-
-import java.util.ArrayList;
-import java.util.Arrays;
-
-import org.lsmr.selfcheckout.devices.SimulationException;
-
-/**
- * Represents a barcode value (not the graphic barcode itself). Real-world
- * barcodes are a sequence of digits, so that is what is modelled here.
- */
-public class Barcode {
-	private Numeral[] digits;
-
-	/**
-	 * Constructs a barcode from an array of numerals.
-	 * 
-	 * @param code
-	 *            An array of numerals.
-	 * @throws SimulationException
-	 *             If any character in the input is not a digit between 0 and 9,
-	 *             inclusive.
-	 * @throws SimulationException
-	 *             If the code is null
-	 * @throws SimulationException
-	 *             If the code's length is &lt;1 or &gt;48.
-	 */
-	public Barcode(Numeral[] code) {
-		if(code == null)
-			throw new SimulationException(new NullPointerException("code is null"));
-
-		digits = new Numeral[code.length];
-
-		if(code.length < 1)
-			throw new SimulationException(
-				new IllegalArgumentException("A barcode cannot contain less than one digit."));
-
-		if(code.length > 48)
-			throw new SimulationException(
-				new IllegalArgumentException("A barcode cannot contain more than forty-eight digits."));
-
-		for(int i = 0; i < code.length; i++) {
-			if(code[i] == null)
-				throw new SimulationException(new NullPointerException("code[" + i + "] is null"));
-
-			digits[i] = code[i];
-		}
-	}
-
-	/**
-	 * Gets the count of digits in this code.
-	 * 
-	 * @return The count of digits.
-	 */
-	public int digitCount() {
-		return digits.length;
-	}
-
-	/**
-	 * Gets the digit at the indicated index within the code.
-	 * 
-	 * @param index
-	 *            The index of the digit, &ge;0 and &lt;count.
-	 * @return The digit at the indicated index.
-	 * @throws SimulationException
-	 *             If the index is outside the legal range.
-	 */
-	public Numeral getDigitAt(int index) {
-		try {
-			return digits[index];
-		}
-		catch(IndexOutOfBoundsException e) {
-			throw new SimulationException(e);
-		}
-	}
-
-	@Override
-	public String toString() {
-		char[] characters = new char[digits.length];
-
-		for(int i = 0; i < digits.length; i++)
-			characters[i] = Character.forDigit(digits[i].getValue(), 10);
-
-		return new String(characters);
-	}
-
-	@Override
-	public boolean equals(Object object) {
-		if(object instanceof Barcode) {
-			Barcode other = (Barcode)object;
-
-			if(other.digits.length != digits.length)
-				return false;
-
-			for(int i = 0; i < digits.length; i++)
-				if(!digits[i].equals(other.digits[i]))
-					return false;
-
-			return true;
-		}
-
-		return false;
-	}
-
-	@Override
-	public int hashCode() {
-		return Arrays.hashCode(digits);
-	}
-}
\ No newline at end of file
diff --git a/src/org/lsmr/selfcheckout/BarcodedItem.java b/src/org/lsmr/selfcheckout/BarcodedItem.java
deleted file mode 100644
index cc57193..0000000
--- a/src/org/lsmr/selfcheckout/BarcodedItem.java
+++ /dev/null
@@ -1,41 +0,0 @@
-package org.lsmr.selfcheckout;
-
-import org.lsmr.selfcheckout.devices.SimulationException;
-import org.lsmr.selfcheckout.products.Product;
-
-/**
- * Represents items for sale, each with a particular barcode and weight.
- */
-public class BarcodedItem extends Item {
-	private Barcode barcode;
-
-	/**
-	 * Basic constructor.
-	 * 
-	 * @param kind
-	 *            The kind of product that this item is.
-	 * @param weightInGrams
-	 *            The real weight of the item.
-	 * @throws SimulationException
-	 *             If the barcode is null.
-	 * @throws SimulationException
-	 *             If the weight is &le;0.
-	 */
-	public BarcodedItem(Barcode barcode, double weightInGrams) {
-		super(weightInGrams);
-
-		if(barcode == null)
-			throw new SimulationException(new NullPointerException("barcode is null"));
-
-		this.barcode = barcode;
-	}
-
-	/**
-	 * Gets the barcode of this item.
-	 * 
-	 * @return The barcode.
-	 */
-	public Barcode getBarcode() {
-		return barcode;
-	}
-}
diff --git a/src/org/lsmr/selfcheckout/BlockedCardException.java b/src/org/lsmr/selfcheckout/BlockedCardException.java
deleted file mode 100644
index 63b13ba..0000000
--- a/src/org/lsmr/selfcheckout/BlockedCardException.java
+++ /dev/null
@@ -1,15 +0,0 @@
-package org.lsmr.selfcheckout;
-
-import java.io.IOException;
-
-/**
- * Represents exceptions arising from a blocked card.
- */
-public class BlockedCardException extends IOException {
-	private static final long serialVersionUID = 8824192400137175094L;
-
-	/**
-	 * Create an exception.
-	 */
-	public BlockedCardException() {}
-}
diff --git a/src/org/lsmr/selfcheckout/Card.java b/src/org/lsmr/selfcheckout/Card.java
deleted file mode 100644
index e3f6fb9..0000000
--- a/src/org/lsmr/selfcheckout/Card.java
+++ /dev/null
@@ -1,289 +0,0 @@
-package org.lsmr.selfcheckout;
-
-import java.io.IOException;
-import java.util.Random;
-import java.util.concurrent.ThreadLocalRandom;
-
-import org.lsmr.selfcheckout.devices.SimulationException;
-
-/**
- * Represents plastic cards (e.g., credit cards, debit cards, membership cards).
- */
-public final class Card {
-	private final String type;
-	private final String number;
-	private final String cardholder;
-	private final String cvv;
-	private final String pin;
-	public final boolean isTapEnabled;
-	public final boolean hasChip;
-	private int failedTrials = 0;
-	private boolean isBlocked;
-
-	/**
-	 * Create a card instance.
-	 * 
-	 * @param type
-	 *            The type of the card.
-	 * @param number
-	 *            The number of the card. This has to be a string of digits.
-	 * @param cardholder
-	 *            The name of the cardholder.
-	 * @param cvv
-	 *            The card verification value (CVV), a 3- or 4-digit value often on
-	 *            the back of the card. This can be null.
-	 * @param pin
-	 *            The personal identification number (PIN) for access to the card.
-	 *            This can be null if the card has no chip.
-	 * @param isTapEnabled
-	 *            Whether this card is capable of being tapped.
-	 * @param hasChip
-	 *            Whether this card has a chip.
-	 * @throws SimulationException
-	 *             If type, number, or cardholder is null.
-	 * @throws SimulationException
-	 *             If hasChip is true but pin is null.
-	 */
-	public Card(String type, String number, String cardholder, String cvv, String pin, boolean isTapEnabled,
-		boolean hasChip) {
-		if(type == null)
-			throw new SimulationException(new NullPointerException("type is null"));
-
-		if(number == null)
-			throw new SimulationException(new NullPointerException("number is null"));
-
-		if(cardholder == null)
-			throw new SimulationException(new NullPointerException("cardholder is null"));
-
-		if(hasChip && pin == null)
-			throw new SimulationException(new NullPointerException("has chip but pin is null"));
-
-		this.type = type;
-		this.number = number;
-		this.cardholder = cardholder;
-		this.cvv = cvv;
-		this.pin = pin;
-		this.isTapEnabled = isTapEnabled;
-		this.hasChip = hasChip;
-	}
-
-	private static final Random random = new Random(0);
-	private static final double PROBABILITY_OF_MAGNETIC_STRIPE_FAILURE = 0.01;
-	private static final double PROBABILITY_OF_TAP_FAILURE = 0.005;
-	private static final double PROBABILITY_OF_INSERT_FAILURE = 0.001;
-	private static final double PROBABILITY_OF_MAGNETIC_STRIPE_CORRUPTION = 0.001;
-	private static final double PROBABILITY_OF_CHIP_CORRUPTION = 0.00001;
-
-	/**
-	 * Simulates the action of swiping the card.
-	 * 
-	 * @return The card data.
-	 * @throws IOException
-	 *             If anything went wrong with the data transfer.
-	 */
-	public final CardSwipeData swipe() throws IOException {
-		if(isBlocked)
-			throw new BlockedCardException();
-
-		if(random.nextDouble() <= PROBABILITY_OF_MAGNETIC_STRIPE_FAILURE)
-			throw new MagneticStripeFailureException();
-
-		return new CardSwipeData();
-	}
-
-	/**
-	 * Simulates the action of tapping the card.
-	 * 
-	 * @return The card data.
-	 * @throws IOException
-	 *             If anything went wrong with the data transfer.
-	 */
-	public final CardTapData tap() throws IOException {
-		if(isBlocked)
-			throw new BlockedCardException();
-
-		if(isTapEnabled) {
-			if(random.nextDouble() <= PROBABILITY_OF_TAP_FAILURE)
-				throw new TapFailureException();
-
-			return new CardTapData();
-		}
-
-		return null;
-	}
-
-	/**
-	 * Simulates the action of inserting the card.
-	 * 
-	 * @return The card data.
-	 * @throws IOException
-	 *             If anything went wrong with the data transfer.
-	 */
-	public final CardInsertData insert(String pin) throws IOException {
-		if(isBlocked)
-			throw new BlockedCardException();
-
-		if(hasChip) {
-			if(random.nextDouble() <= PROBABILITY_OF_INSERT_FAILURE)
-				throw new ChipFailureException();
-
-			return new CardInsertData(pin);
-		}
-
-		return null;
-	}
-
-	private String randomize(String original, double probability) {
-		if(random.nextDouble() <= probability) {
-			int length = original.length();
-			int index = random.nextInt(length);
-			String first;
-
-			if(index == 0)
-				first = "";
-			else
-				first = original.substring(0, index);
-
-			char second = original.charAt(index);
-			second++;
-
-			String third;
-
-			if(index == length - 1)
-				third = "";
-			else
-				third = original.substring(index + 1, length);
-
-			return first + second + third;
-		}
-
-		return original;
-	}
-
-	/**
-	 * The abstract base type of card data.
-	 */
-	public interface CardData {
-		/**
-		 * Gets the type of the card.
-		 * 
-		 * @return The type of the card.
-		 */
-		public String getType();
-
-		/**
-		 * Gets the number of the card.
-		 * 
-		 * @return The number of the card.
-		 */
-		public String getNumber();
-
-		/**
-		 * Gets the cardholder's name.
-		 * 
-		 * @return The cardholder's name.
-		 */
-		public String getCardholder();
-
-		/**
-		 * Gets the card verification value (CVV) of the card.
-		 * 
-		 * @return The CVV of the card.
-		 * @throws UnsupportedOperationException
-		 *             If this operation is unsupported by this object.
-		 */
-		public String getCVV();
-	}
-
-	/**
-	 * The data from swiping a card.
-	 */
-	public class CardSwipeData implements CardData {
-		@Override
-		public String getType() {
-			return randomize(type, PROBABILITY_OF_MAGNETIC_STRIPE_CORRUPTION);
-		}
-
-		@Override
-		public String getNumber() {
-			return randomize(number, PROBABILITY_OF_MAGNETIC_STRIPE_CORRUPTION);
-		}
-
-		@Override
-		public String getCardholder() {
-			return randomize(cardholder, PROBABILITY_OF_MAGNETIC_STRIPE_CORRUPTION);
-		}
-
-		@Override
-		public String getCVV() {
-			throw new UnsupportedOperationException();
-		}
-	}
-
-	/**
-	 * The data from tapping a card.
-	 */
-	public final class CardTapData implements CardData {
-		@Override
-		public String getType() {
-			return randomize(type, PROBABILITY_OF_CHIP_CORRUPTION);
-		}
-
-		@Override
-		public String getNumber() {
-			return randomize(number, PROBABILITY_OF_CHIP_CORRUPTION);
-		}
-
-		@Override
-		public String getCardholder() {
-			return randomize(cardholder, PROBABILITY_OF_CHIP_CORRUPTION);
-		}
-
-		@Override
-		public String getCVV() {
-			return randomize(cvv, PROBABILITY_OF_CHIP_CORRUPTION);
-		}
-	}
-
-	/**
-	 * The data from inserting a card.
-	 */
-	public final class CardInsertData implements CardData {
-		CardInsertData(String pin) throws InvalidPINException {
-			if(!testPIN(pin))
-				throw new InvalidPINException();
-		}
-
-		@Override
-		public String getType() {
-			return randomize(type, PROBABILITY_OF_CHIP_CORRUPTION);
-		}
-
-		@Override
-		public String getNumber() {
-			return randomize(number, PROBABILITY_OF_CHIP_CORRUPTION);
-		}
-
-		@Override
-		public String getCardholder() {
-			return randomize(cardholder, PROBABILITY_OF_CHIP_CORRUPTION);
-		}
-
-		@Override
-		public String getCVV() {
-			return randomize(cvv, PROBABILITY_OF_CHIP_CORRUPTION);
-		}
-
-		private boolean testPIN(String pinToTest) {
-			if(pinToTest == pin) {
-				failedTrials = 0;
-				return true;
-			}
-
-			if(++failedTrials >= 3)
-				isBlocked = true;
-
-			return false;
-		}
-	}
-}
diff --git a/src/org/lsmr/selfcheckout/ChipFailureException.java b/src/org/lsmr/selfcheckout/ChipFailureException.java
deleted file mode 100644
index 971cf50..0000000
--- a/src/org/lsmr/selfcheckout/ChipFailureException.java
+++ /dev/null
@@ -1,15 +0,0 @@
-package org.lsmr.selfcheckout;
-
-import java.io.IOException;
-
-/**
- * Represents exceptions arising from failures of the chip.
- */
-public class ChipFailureException extends IOException {
-	private static final long serialVersionUID = 3518203688837080092L;
-
-	/**
-	 * Create an exception.
-	 */
-	public ChipFailureException() {}
-}
diff --git a/src/org/lsmr/selfcheckout/Coin.java b/src/org/lsmr/selfcheckout/Coin.java
deleted file mode 100644
index 5681c26..0000000
--- a/src/org/lsmr/selfcheckout/Coin.java
+++ /dev/null
@@ -1,98 +0,0 @@
-package org.lsmr.selfcheckout;
-
-import java.math.BigDecimal;
-import java.util.Currency;
-
-import org.lsmr.selfcheckout.devices.SimulationException;
-
-/**
- * Instances of this class represent individual coins.
- */
-public class Coin {
-	private BigDecimal value;
-	private Currency currency;
-
-	/**
-	 * Rather than specifying a currency for every coin, a default currency can be
-	 * specified which will be used when the currency is not specified.
-	 */
-	public static Currency DEFAULT_CURRENCY;
-
-	/**
-	 * Constructs a coin, using the default currency.
-	 * 
-	 * @param value
-	 *            The value of the coin, in multiples of the unit of currency.
-	 * @throws SimulationException
-	 *             If the value is &le;0.
-	 * @throws SimulationException
-	 *             If the argument is null.
-	 */
-	public Coin(BigDecimal value) {
-		if(value == null)
-			throw new SimulationException(new NullPointerException("value is null"));
-
-		if(DEFAULT_CURRENCY == null)
-			throw new SimulationException(new NullPointerException("Default currency is null"));
-
-		if(value.compareTo(BigDecimal.ZERO) <= 0)
-			throw new SimulationException(
-				new IllegalArgumentException("The value must be greater than 0: the argument passed was " + value));
-
-		this.value = value;
-		this.currency = DEFAULT_CURRENCY;
-	}
-		
-	/**
-	 * Constructs a coin.
-	 * 
-	 * @param currency
-	 *            The currency represented by this coin.
-	 * @param value
-	 *            The value of the coin, in multiples of the unit of currency.
-	 * @throws SimulationException
-	 *             If the value is &le;0.
-	 * @throws SimulationException
-	 *             If either argument is null.
-	 */
-	public Coin(Currency currency, BigDecimal value) {
-		if(value == null)
-			throw new SimulationException(new NullPointerException("value is null"));
-
-		if(currency == null)
-			throw new SimulationException(new NullPointerException("currency is null"));
-
-		if(value.compareTo(BigDecimal.ZERO) <= 0)
-			throw new SimulationException(
-				new IllegalArgumentException("The value must be greater than 0: the argument passed was " + value));
-
-		this.value = value;
-		this.currency = currency;
-	}
-
-	/**
-	 * Accessor for the value.
-	 * 
-	 * @return The value of the coin. Should always be greater than 0.
-	 */
-	public BigDecimal getValue() {
-		return value;
-	}
-
-	/**
-	 * Accessor for the currency.
-	 * 
-	 * @return The currency for this coin. Note that this is not the same as the
-	 *             "denomination" (e.g., a Canadian dime is worth 0.1 Canadian
-	 *             dollars, so a Canadian dime would have currency "Canadian
-	 *             dollars").
-	 */
-	public Currency getCurrency() {
-		return currency;
-	}
-
-	@Override
-	public String toString() {
-		return value.toString() + " " + currency;
-	}
-}
diff --git a/src/org/lsmr/selfcheckout/SCS - Software/.gitignore b/src/org/lsmr/selfcheckout/SCS - Software/.gitignore
deleted file mode 100644
index 9eca640..0000000
--- a/src/org/lsmr/selfcheckout/SCS - Software/.gitignore	
+++ /dev/null
@@ -1 +0,0 @@
-/SCSLogic.class
diff --git a/src/org/lsmr/selfcheckout/SCS - Software/SCS - Software - Test/test b/src/org/lsmr/selfcheckout/SCS - Software/SCS - Software - Test/test
deleted file mode 100644
index 8b13789..0000000
--- a/src/org/lsmr/selfcheckout/SCS - Software/SCS - Software - Test/test	
+++ /dev/null
@@ -1 +0,0 @@
-
diff --git a/src/org/lsmr/selfcheckout/SCS - Software/SCSLogic.java b/src/org/lsmr/selfcheckout/SCS - Software/SCSLogic.java
deleted file mode 100644
index 768629c..0000000
--- a/src/org/lsmr/selfcheckout/SCS - Software/SCSLogic.java	
+++ /dev/null
@@ -1,4 +0,0 @@
-public class SCSLogic {
-	
-	
-}
diff --git a/src/org/lsmr/selfcheckout/SCSLogic.java b/src/org/lsmr/selfcheckout/SCSLogic.java
deleted file mode 100644
index 9a74570..0000000
--- a/src/org/lsmr/selfcheckout/SCSLogic.java
+++ /dev/null
@@ -1,83 +0,0 @@
-package org.lsmr.selfcheckout;
-
-import org.lsmr.selfcheckout.devices.AbstractDevice;
-import org.lsmr.selfcheckout.devices.Acceptor;
-import org.lsmr.selfcheckout.devices.DisabledException;
-import org.lsmr.selfcheckout.devices.ElectronicScale;
-import org.lsmr.selfcheckout.devices.OverloadException;
-import org.lsmr.selfcheckout.devices.SimulationException;
-import org.lsmr.selfcheckout.devices.observers.AbstractDeviceObserver;
-
-public class SCSLogic extends AbstractDevice<AbstractDeviceObserver> implements Acceptor<AbstractDeviceObserver>{
-	
-	private ElectronicScale electronic;
-	
-	
-	
-	
-	public SCSLogic(ElectronicScale e) {
-		this.electronic = e;
-	}
-	
-	
-	
-	
-	public void wish_checkout(AbstractDeviceObserver payment_method) throws OverloadException, DisabledException  {
-		
-		try {
-			this.attach(payment_method);
-			while(true) {
-				if (!electronic.isDisabled()) {  // keep checking the weight of bagging area, check if the weight has changed
-					
-					this.accept(payment_method);
-					
-					if (this.isDisabled()) {
-						break;
-					}
-					else { //this should never been run
-						throw new SimulationException("can't receive payment method");
-					}
-					
-				}
-				else {
-					throw new SimulationException("the weight has changed");
-				}
-				
-			}
-			//....might need to call the matched payment method
-			
-		} catch (OverloadException e) {
-			throw e;
-		}catch (DisabledException e) {
-		    throw e;
-		}
-		
-		
-		
-		
-		
-	}
-
-
-
-
-
-
-
-
-
-
-	@Override
-	public void accept(AbstractDeviceObserver thing) throws OverloadException, DisabledException {
-			thing.enabled(this);
-	}
-
-
-
-	@Override
-	public boolean hasSpace() { //not used yet
-		// TODO Auto-generated method stub
-		return false;
-	}
-	
-}
diff --git a/src/org/lsmr/selfcheckout/devices/.gitignore b/src/org/lsmr/selfcheckout/devices/.gitignore
deleted file mode 100644
index 8271a9b..0000000
--- a/src/org/lsmr/selfcheckout/devices/.gitignore
+++ /dev/null
@@ -1,22 +0,0 @@
-/AbstractDevice$Phase.class
-/AbstractDevice.class
-/Acceptor.class
-/BanknoteDispenser.class
-/BanknoteSlot.class
-/BanknoteStorageUnit.class
-/BanknoteValidator.class
-/BarcodeScanner.class
-/BidirectionalChannel.class
-/CardReader.class
-/CoinDispenser.class
-/CoinSlot.class
-/CoinStorageUnit.class
-/CoinTray.class
-/CoinValidator.class
-/DisabledException.class
-/ElectronicScale.class
-/Emitter.class
-/EmptyException.class
-/FlowThroughEmitter.class
-/FromStorageEmitter.class
-/SimulationException.class
diff --git a/src/org/lsmr/selfcheckout/devices/AbstractDevice.java b/src/org/lsmr/selfcheckout/devices/AbstractDevice.java
deleted file mode 100644
index 89f4880..0000000
--- a/src/org/lsmr/selfcheckout/devices/AbstractDevice.java
+++ /dev/null
@@ -1,193 +0,0 @@
-package org.lsmr.selfcheckout.devices;
-
-import java.util.ArrayList;
-
-import org.lsmr.selfcheckout.devices.observers.AbstractDeviceObserver;
-
-/**
- * The abstract base class for all devices involved in the simulator.
- * <p>
- * This class utilizes the Observer design pattern. Subclasses inherit the
- * attach method, but each must define its own notifyXXX methods.
- * </p>
- * <p>
- * Each device must be coupled to an appropriate observer interface, which
- * extends AbstractDeviceObserver; the type parameter T represents this
- * observer.
- * <p>
- * <p>
- * Any individual device can be disabled, which means it will not permit
- * physical movements to be caused by the software. Any method that could cause
- * a physical movement will declare that it throws DisabledException.
- * </p>
- * 
- * @param <T>
- *            The type of observers used for this device. For a device whose
- *            class is X, its corresponding observer interface would typically
- *            be XObserver.
- */
-public abstract class AbstractDevice<T extends AbstractDeviceObserver> {
-	/**
-	 * Used to represent the operation phase of this device.
-	 */
-	protected enum Phase {
-		/**
-		 * The device is being configured.
-		 */
-		CONFIGURATION,
-		/**
-		 * The device is in normal operation.
-		 */
-		NORMAL,
-		/**
-		 * The device has undergone a fatal error requiring physical repair and reset.
-		 */
-		ERROR
-	}
-
-	/**
-	 * The current operation phase of this device.
-	 */
-	protected Phase phase = Phase.CONFIGURATION;
-
-	/**
-	 * Many devices require configuration before their use. Before configuration is
-	 * complete, the device should not operate. Once configuration is complete, any
-	 * further configuration attempts should cause exceptions.
-	 */
-	public void endConfigurationPhase() {
-		phase = Phase.NORMAL;
-	}
-
-	/**
-	 * For testing purposes only. Forces this device into an erroneous state.
-	 */
-	public void forceErrorPhase() {
-		phase = Phase.ERROR;
-	}
-
-	/**
-	 * A list of the registered observers on this device.
-	 */
-	protected ArrayList<T> observers = new ArrayList<>();
-
-	/**
-	 * Locates the indicated observer and removes it such that it will no longer be
-	 * informed of events from this device. If the observer is not currently
-	 * registered with this device, calls to this method will return false, but
-	 * otherwise have no effect.
-	 * <p>
-	 * This operation is permissible during the configuration phase.
-	 * 
-	 * @param observer
-	 *            The observer to remove.
-	 * @return true if the observer was found and removed, false otherwise.
-	 */
-	public final boolean detach(T observer) {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-
-		return observers.remove(observer);
-	}
-
-	/**
-	 * All observers registered with this device are removed. If there are none,
-	 * calls to this method have no effect.
-	 * <p>
-	 * This operation is permissible during the configuration phase.
-	 */
-	public final void detachAll() {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-
-		observers.clear();
-	}
-
-	/**
-	 * Registers the indicated observer to receive event notifications from this
-	 * device.
-	 * <p>
-	 * This operation is permissible during the configuration phase.
-	 * 
-	 * @param observer
-	 *            The observer to be added.
-	 */
-	public final void attach(T observer) {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-
-		if(observer == null)
-			throw new SimulationException(new IllegalArgumentException(
-				"This method may not receive null, as it has no analogue in the real world."));
-
-		observers.add(observer);
-	}
-
-	private boolean disabled = false;
-
-	/**
-	 * Disables this device from receiving input and producing output.
-	 * <p>
-	 * This operation is not permissible during the configuration phase.
-	 */
-	public final void disable() {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-		if(phase == Phase.CONFIGURATION)
-			throw new SimulationException(
-				new IllegalStateException("This method may not be called during the configuration phase."));
-
-		disabled = true;
-		notifyDisabled();
-	}
-
-	private void notifyDisabled() {
-		for(T observer : observers)
-			observer.disabled(this);
-	}
-
-	/**
-	 * Enables this device for receiving input and producing output.
-	 * <p>
-	 * This operation is not permissible during the configuration phase.
-	 */
-	public final void enable() {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-		if(phase == Phase.CONFIGURATION)
-			throw new SimulationException(
-				new IllegalStateException("This method may not be called during the configuration phase."));
-
-		disabled = false;
-		notifyEnabled();
-	}
-
-	private void notifyEnabled() {
-		for(T observer : observers)
-			observer.enabled(this);
-	}
-
-	/**
-	 * Returns whether this device is currently disabled from receiving input and
-	 * producing output.
-	 * <p>
-	 * This operation is illegal during the configuration phase.
-	 * 
-	 * @return true if the device is disabled; false if the device is enabled.
-	 */
-	public final boolean isDisabled() {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-		if(phase == Phase.CONFIGURATION)
-			throw new SimulationException(
-				new IllegalStateException("This method may not be called during the configuration phase."));
-
-		return disabled;
-	}
-}
diff --git a/src/org/lsmr/selfcheckout/devices/Acceptor.java b/src/org/lsmr/selfcheckout/devices/Acceptor.java
deleted file mode 100644
index 4534b94..0000000
--- a/src/org/lsmr/selfcheckout/devices/Acceptor.java
+++ /dev/null
@@ -1,37 +0,0 @@
-package org.lsmr.selfcheckout.devices;
-
-import org.lsmr.selfcheckout.Coin;
-
-/**
- * A simple interface for devices that accept things.
- * 
- * @param <T>
- *            The type of the things to accept.
- */
-public interface Acceptor<T> {
-	/**
-	 * Instructs the device to take the thing as input.
-	 * <p>
-	 * This operation may not be called during the configuration phase.
-	 * 
-	 * @param thing
-	 *            The thing to be taken as input.
-	 * @throws OverloadException
-	 *             If the device does not have enough space for the thing.
-	 * @throws DisabledException
-	 *             If the device is disabled.
-	 */
-	public void accept(T thing) throws OverloadException, DisabledException;
-
-	/**
-	 * Checks whether the device has enough space to expect one more thing. If this
-	 * method returns true, an immediate call to accept should not throw
-	 * CapacityExceededException, unless an asynchronous addition has occurred in
-	 * the meantime.
-	 * <p>
-	 * This operation may not be called during the configuration phase.
-	 * 
-	 * @return true If there is space; otherwise, false.
-	 */
-	public boolean hasSpace();
-}
diff --git a/src/org/lsmr/selfcheckout/devices/BanknoteDispenser.java b/src/org/lsmr/selfcheckout/devices/BanknoteDispenser.java
deleted file mode 100644
index de25f9c..0000000
--- a/src/org/lsmr/selfcheckout/devices/BanknoteDispenser.java
+++ /dev/null
@@ -1,213 +0,0 @@
-package org.lsmr.selfcheckout.devices;
-
-import java.util.ArrayList;
-import java.util.LinkedList;
-import java.util.List;
-import java.util.Queue;
-
-import org.lsmr.selfcheckout.Banknote;
-import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
-import org.lsmr.selfcheckout.devices.observers.BanknoteDispenserObserver;
-
-/**
- * Represents a device that stores banknotes (as known as bills, paper money,
- * etc.) of a particular denomination to dispense them as change.
- * <p>
- * Banknote dispensers can receive banknotes from other sources. To simplify the
- * simulation, no check is performed on the value of each banknote.
- * </p>
- */
-public final class BanknoteDispenser extends AbstractDevice<BanknoteDispenserObserver>
-	implements FromStorageEmitter<Banknote> {
-	private int maxCapacity;
-	private Queue<Banknote> queue = new LinkedList<Banknote>();
-	private UnidirectionalChannel<Banknote> sink;
-
-	/**
-	 * Creates a banknote dispenser with the indicated maximum capacity.
-	 * 
-	 * @param capacity
-	 *            The maximum number of banknotes that can be stored in the
-	 *            dispenser. Must be positive.
-	 * @throws SimulationException
-	 *             If capacity is not positive.
-	 */
-	public BanknoteDispenser(int capacity) {
-		if(capacity <= 0)
-			throw new SimulationException(new IllegalArgumentException("Capacity must be positive: " + capacity));
-
-		this.maxCapacity = capacity;
-	}
-
-	/**
-	 * Accesses the current number of banknotes in the dispenser.
-	 * <p>
-	 * This operation is illegal during the configuration phase.
-	 * 
-	 * @return The number of banknotes currently in the dispenser.
-	 */
-	public int size() {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-		if(phase == Phase.CONFIGURATION)
-			throw new SimulationException(
-				new IllegalStateException("This method may not be called during the configuration phase."));
-
-		return queue.size();
-	}
-
-	/**
-	 * Allows a set of banknotes to be loaded into the dispenser directly. Existing
-	 * banknotes in the dispenser are not removed.
-	 * <p>
-	 * This operation is permissible during the configuration phase.
-	 * 
-	 * @param banknotes
-	 *            A sequence of banknotes to be added. Each may not be null.
-	 * @throws OverloadException
-	 *             if the number of banknotes to be loaded exceeds the capacity of
-	 *             the dispenser.
-	 * @throws SimulationException
-	 *             If any banknote is null.
-	 */
-	public void load(Banknote... banknotes) throws SimulationException, OverloadException {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-
-		if(maxCapacity < queue.size() + banknotes.length)
-			throw new OverloadException("Capacity of dispenser is exceeded by load");
-
-		for(Banknote banknote : banknotes)
-			if(banknote == null)
-				throw new SimulationException(new NullPointerException("A banknote is null."));
-			else
-				queue.add(banknote);
-
-		notifyBanknotesLoaded(banknotes);
-	}
-
-	/**
-	 * Unloads banknotes from the dispenser directly. Causes a "banknotesUnloaded"
-	 * event to be announced.
-	 * <p>
-	 * This operation is permissible during the configuration phase.
-	 * 
-	 * @return A list of the banknotes unloaded. May be empty. Will never be null.
-	 */
-	public List<Banknote> unload() {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-
-		List<Banknote> result = new ArrayList<>(queue);
-		queue.clear();
-
-		notifyBanknotesUnoaded(result.toArray(new Banknote[result.size()]));
-
-		return result;
-	}
-
-	/**
-	 * Connects an output channel to this banknote dispenser. Any existing output
-	 * channels are disconnected. Causes no events to be announced.
-	 * <p>
-	 * This operation is permissible only during the configuration phase.
-	 * 
-	 * @param sink
-	 *            The new output device to act as output. Can be null, which leaves
-	 *            the channel without an output.
-	 */
-	public void connect(UnidirectionalChannel<Banknote> sink) {
-		if(phase != Phase.CONFIGURATION)
-			throw new SimulationException(
-				new IllegalStateException("This method may only be called during the configuration phase."));
-
-		this.sink = sink;
-	}
-
-	/**
-	 * Returns the maximum capacity of this banknote dispenser.
-	 * <p>
-	 * This operation is permissible during the configuration phase.
-	 * 
-	 * @return The capacity. Will be positive.
-	 */
-	public int getCapacity() {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-
-		return maxCapacity;
-	}
-
-	/**
-	 * Emits a single banknote from this banknote dispenser. If successful, a
-	 * "banknoteRemoved" event is announced to its observers. If a successful
-	 * banknote removal causes the dispenser to become empty, a "banknotesEmpty"
-	 * event is instead announced to its observers.
-	 * <p>
-	 * This operation is illegal during the configuration phase.
-	 * 
-	 * @throws OverloadException
-	 *             if the output channel is unable to accept another banknote.
-	 * @throws EmptyException
-	 *             if no banknotes are present in the dispenser to release.
-	 * @throws DisabledException
-	 *             if the dispenser is currently disabled.
-	 */
-	public void emit() throws EmptyException, DisabledException, OverloadException {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-		if(phase == Phase.CONFIGURATION)
-			throw new SimulationException(
-				new IllegalStateException("This method may not be called during the configuration phase."));
-
-		if(isDisabled())
-			throw new DisabledException();
-
-		if(queue.size() == 0)
-			throw new EmptyException();
-
-		Banknote banknote = queue.remove();
-
-		if(sink.hasSpace())
-			try {
-				sink.deliver(banknote);
-			}
-			catch(OverloadException e) {
-				// Should never happen
-				phase = Phase.ERROR;
-				throw new SimulationException(e);
-			}
-		else
-			throw new OverloadException("The sink is full.");
-
-		if(queue.isEmpty())
-			notifyBanknotesEmpty();
-		else
-			notifyBanknoteRemoved(banknote);
-	}
-
-	private void notifyBanknoteRemoved(Banknote banknote) {
-		for(BanknoteDispenserObserver observer : observers)
-			observer.banknoteRemoved(this, banknote);
-	}
-
-	private void notifyBanknotesEmpty() {
-		for(BanknoteDispenserObserver observer : observers)
-			observer.banknotesEmpty(this);
-	}
-
-	private void notifyBanknotesLoaded(Banknote[] banknotes) {
-		for(BanknoteDispenserObserver observer : observers)
-			observer.banknotesLoaded(this, banknotes);
-	}
-
-	private void notifyBanknotesUnoaded(Banknote[] banknotes) {
-		for(BanknoteDispenserObserver observer : observers)
-			observer.banknotesUnloaded(this, banknotes);
-	}
-}
diff --git a/src/org/lsmr/selfcheckout/devices/BanknoteSlot.java b/src/org/lsmr/selfcheckout/devices/BanknoteSlot.java
deleted file mode 100644
index 9037e26..0000000
--- a/src/org/lsmr/selfcheckout/devices/BanknoteSlot.java
+++ /dev/null
@@ -1,191 +0,0 @@
-package org.lsmr.selfcheckout.devices;
-
-import org.lsmr.selfcheckout.Banknote;
-import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
-import org.lsmr.selfcheckout.devices.observers.BanknoteSlotObserver;
-
-/**
- * Represents a simple banknote slot device that can either accept a banknote or
- * eject the most recently inserted banknote, leaving it dangling until the
- * customer removes it, via {@link #removeDanglingBanknote()}.
- */
-public class BanknoteSlot extends AbstractDevice<BanknoteSlotObserver>
-	implements Acceptor<Banknote>, FlowThroughEmitter<Banknote> {
-	private BidirectionalChannel<Banknote> sink;
-	private boolean invert;
-
-	/**
-	 * Creates a banknote slot.
-	 * 
-	 * @param invert
-	 *            If the slot is to be inverted.
-	 */
-	public BanknoteSlot(boolean invert) {
-		this.invert = invert;
-	}
-
-	/**
-	 * Connects an output channel to the banknote slot. Causes no events.
-	 * <p>
-	 * This operation is permissible only during the configuration phase.
-	 * 
-	 * @param sink
-	 *            Where banknotes are passed into the machine.
-	 */
-	public void connect(BidirectionalChannel<Banknote> sink) {
-		if(phase != Phase.CONFIGURATION)
-			throw new SimulationException(
-				new IllegalStateException("This method may only be called during the configuration phase."));
-
-		this.sink = sink;
-	}
-
-	/**
-	 * Tells the banknote slot that the indicated banknote is being inserted. If the
-	 * sink can accept the banknote, the banknote is passed to the sink and a
-	 * "banknoteInserted" event is announced to the slot's observers; otherwise, a
-	 * "banknoteEjected" event is announced to the slot's observers, meaning that
-	 * the banknote is returned to the user.
-	 * <p>
-	 * This operation is not permissible during the configuration phase.
-	 * 
-	 * @param banknote
-	 *            The banknote to be added. Cannot be null.
-	 * @throws DisabledException
-	 *             if the banknote slot is currently disabled.
-	 * @throws SimulationException
-	 *             If the banknote is null.
-	 * @throws OverloadException
-	 *             If a banknote is dangling from the slot.
-	 */
-	public void accept(Banknote banknote) throws DisabledException, OverloadException {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-		if(phase == Phase.CONFIGURATION)
-			throw new SimulationException(
-				new IllegalStateException("This method may not be called during the configuration phase."));
-
-		if(isDisabled())
-			throw new DisabledException();
-
-		if(danglingEjectedBanknote != null)
-			throw new OverloadException("A banknote is dangling from the slot. Remove that before adding another.");
-
-		notifyBanknoteInserted();
-
-		if(!invert && sink.hasSpace()) {
-			try {
-				sink.deliver(banknote);
-			}
-			catch(OverloadException e) {
-				// Should never happen
-				phase = Phase.ERROR;
-				throw new SimulationException(e);
-			}
-		}
-		else {
-			danglingEjectedBanknote = banknote;
-			notifyBanknoteEjected();
-		}
-	}
-
-	private Banknote danglingEjectedBanknote = null;
-
-	/**
-	 * Ejects the indicated banknote, leaving it dangling until the customer grabs
-	 * it.
-	 * <p>
-	 * This operation is not permissible during the configuration phase.
-	 * 
-	 * @param banknote
-	 *            The banknote to be ejected.
-	 * @throws DisabledException
-	 *             If the device is disabled.
-	 * @throws SimulationException
-	 *             If the argument is null.
-	 * @throws SimulationException
-	 *             If a banknote is already dangling from the slot.
-	 */
-	public void emit(Banknote banknote) throws DisabledException, SimulationException {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-		if(phase == Phase.CONFIGURATION)
-			throw new SimulationException(
-				new IllegalStateException("This method may not be called during the configuration phase."));
-
-		if(isDisabled())
-			throw new DisabledException();
-
-		if(banknote == null)
-			throw new SimulationException(new NullPointerException("banknote is null"));
-
-		if(danglingEjectedBanknote != null)
-			throw new SimulationException(
-				"A banknote is already dangling from the slot. Remove that before ejecting another.");
-
-		danglingEjectedBanknote = banknote;
-
-		notifyBanknoteEjected();
-	}
-
-	/**
-	 * Simulates the user removing a banknote that is dangling from the slot.
-	 * <p>
-	 * This operation is not permissible during the configuration phase.
-	 * 
-	 * @return The formerly dangling banknote.
-	 */
-	public Banknote removeDanglingBanknote() {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-		if(phase == Phase.CONFIGURATION)
-			throw new SimulationException(
-				new IllegalStateException("This method may not be called during the configuration phase."));
-
-		if(danglingEjectedBanknote == null)
-			throw new SimulationException("A banknote that does not exist cannot be removed.");
-
-		Banknote b = danglingEjectedBanknote;
-		danglingEjectedBanknote = null;
-		notifyBanknoteRemoved();
-
-		return b;
-	}
-
-	/**
-	 * Tests whether a banknote can be accepted by or ejected from this slot.
-	 * <p>
-	 * This operation is not permissible during the configuration phase.
-	 * 
-	 * @return True if the slot is not occupied by a dangling banknote; otherwise,
-	 *             false.
-	 */
-	public boolean hasSpace() {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-		if(phase == Phase.CONFIGURATION)
-			throw new SimulationException(
-				new IllegalStateException("This method may not be called during the configuration phase."));
-
-		return danglingEjectedBanknote == null;
-	}
-
-	private void notifyBanknoteInserted() {
-		for(BanknoteSlotObserver observer : observers)
-			observer.banknoteInserted(this);
-	}
-
-	private void notifyBanknoteEjected() {
-		for(BanknoteSlotObserver observer : observers)
-			observer.banknoteEjected(this);
-	}
-
-	private void notifyBanknoteRemoved() {
-		for(BanknoteSlotObserver observer : observers)
-			observer.banknoteRemoved(this);
-	}
-}
diff --git a/src/org/lsmr/selfcheckout/devices/BanknoteStorageUnit.java b/src/org/lsmr/selfcheckout/devices/BanknoteStorageUnit.java
deleted file mode 100644
index 34e6a81..0000000
--- a/src/org/lsmr/selfcheckout/devices/BanknoteStorageUnit.java
+++ /dev/null
@@ -1,199 +0,0 @@
-package org.lsmr.selfcheckout.devices;
-
-import java.util.Arrays;
-import java.util.List;
-
-import org.lsmr.selfcheckout.Banknote;
-import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
-import org.lsmr.selfcheckout.devices.observers.BanknoteStorageUnitObserver;
-
-/**
- * Represents devices that store banknotes. They only receive banknotes, not
- * dispense them. To access the banknotes inside, a human operator needs to
- * physically remove the banknotes, simulated with the {@link #unload()} method.
- * A {@link #load(Banknote...)} method is provided for symmetry.
- */
-public class BanknoteStorageUnit extends AbstractDevice<BanknoteStorageUnitObserver> implements Acceptor<Banknote> {
-	private Banknote[] storage;
-	private int nextIndex = 0;
-
-	/**
-	 * Creates a banknote storage unit that can hold the indicated number of
-	 * banknotes.
-	 * 
-	 * @param capacity
-	 *            The maximum number of banknotes that the unit can hold.
-	 * @throws SimulationException
-	 *             If the capacity is not positive.
-	 */
-	public BanknoteStorageUnit(int capacity) {
-		if(capacity <= 0)
-			throw new SimulationException(new IllegalArgumentException("The capacity must be positive."));
-
-		storage = new Banknote[capacity];
-	}
-
-	/**
-	 * Gets the maximum number of banknotes that this storage unit can hold.
-	 * <p>
-	 * This operation is permissible during the configuration phase.
-	 * 
-	 * @return The capacity.
-	 */
-	public int getCapacity() {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-
-		return storage.length;
-	}
-
-	/**
-	 * Gets the current count of banknotes contained in this storage unit.
-	 * <p>
-	 * This operation is permissible during the configuration phase.
-	 * 
-	 * @return The current count.
-	 */
-	public int getBanknoteCount() {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-
-		return nextIndex;
-	}
-
-	/**
-	 * Allows a set of banknotes to be loaded into the storage unit directly.
-	 * Existing banknotes in the dispenser are not removed. Causes a
-	 * "banknotesLoaded" event to be announced. Disabling has no effect on
-	 * loading/unloading.
-	 * <p>
-	 * This operation is permissible during the configuration phase.
-	 * 
-	 * @param banknotes
-	 *            A sequence of banknotes to be added. Each cannot be null.
-	 * @throws SimulationException
-	 *             if the number of banknotes to be loaded exceeds the capacity of
-	 *             the unit.
-	 * @throws SimulationException
-	 *             If the banknotes argument is null.
-	 * @throws SimulationException
-	 *             If any banknote is null.
-	 * @throws OverloadException
-	 *             If too many banknotes are stuffed in the unit.
-	 */
-	public void load(Banknote... banknotes) throws SimulationException, OverloadException {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-
-		if(banknotes == null)
-			throw new SimulationException(
-				new NullPointerException("banknotes is null which has no analogue in the real world"));
-
-		if(banknotes.length + nextIndex > storage.length)
-			throw new OverloadException("You tried to stuff too many banknotes in the storage unit.");
-
-		for(Banknote banknote : banknotes)
-			if(banknote == null)
-				throw new SimulationException(
-					new NullPointerException("No banknote may be null, which has no analogue in the real world."));
-
-		System.arraycopy(banknotes, 0, storage, nextIndex, banknotes.length);
-		nextIndex += banknotes.length;
-
-		notifyBanknotesLoaded();
-	}
-
-	/**
-	 * Unloads banknotes from the storage unit directly. Causes a
-	 * "banknotesUnloaded" event to be announced.
-	 * <p>
-	 * This operation is permissible during the configuration phase.
-	 * 
-	 * @return A list of the banknotes unloaded. May be empty. Will never be null.
-	 */
-	public List<Banknote> unload() {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-
-		List<Banknote> banknotes = Arrays.asList(storage);
-
-		storage = new Banknote[storage.length];
-		nextIndex = 0;
-		notifyBanknotesUnloaded();
-
-		return banknotes;
-	}
-
-	/**
-	 * Causes the indicated banknote to be added to the storage unit. If successful,
-	 * a "banknoteAdded" event is announced to its observers. If a successful
-	 * banknote addition causes the unit to become full, a "banknotesFull" event is
-	 * instead announced to its observers.
-	 * <p>
-	 * This operation is not permissible during the configuration phase.
-	 * 
-	 * @param banknote
-	 *            The banknote to add.
-	 * @throws DisabledException
-	 *             If the unit is currently disabled.
-	 * @throws SimulationException
-	 *             If banknote is null.
-	 * @throws OverloadException
-	 *             If the unit is already full.
-	 */
-	public void accept(Banknote banknote) throws DisabledException, OverloadException {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-		if(phase == Phase.CONFIGURATION)
-			throw new SimulationException(
-				new IllegalStateException("This method may not be called during the configuration phase."));
-
-		if(isDisabled())
-			throw new DisabledException();
-
-		if(banknote == null)
-			throw new SimulationException(
-				new NullPointerException("banknote is null, which has no analogue in the real world."));
-
-		if(nextIndex < storage.length) {
-			storage[nextIndex++] = banknote;
-
-			if(nextIndex == storage.length)
-				notifyBanknotesFull();
-			else
-				notifyBanknoteAdded();
-		}
-		else
-			throw new OverloadException();
-	}
-
-	@Override
-	public boolean hasSpace() {
-		return nextIndex < storage.length;
-	}
-
-	private void notifyBanknotesLoaded() {
-		for(BanknoteStorageUnitObserver l : observers)
-			l.banknotesLoaded(this);
-	}
-
-	private void notifyBanknotesUnloaded() {
-		for(BanknoteStorageUnitObserver l : observers)
-			l.banknotesUnloaded(this);
-	}
-
-	private void notifyBanknotesFull() {
-		for(BanknoteStorageUnitObserver l : observers)
-			l.banknotesFull(this);
-	}
-
-	private void notifyBanknoteAdded() {
-		for(BanknoteStorageUnitObserver l : observers)
-			l.banknoteAdded(this);
-	}
-}
diff --git a/src/org/lsmr/selfcheckout/devices/BanknoteValidator.java b/src/org/lsmr/selfcheckout/devices/BanknoteValidator.java
deleted file mode 100644
index e014ea9..0000000
--- a/src/org/lsmr/selfcheckout/devices/BanknoteValidator.java
+++ /dev/null
@@ -1,201 +0,0 @@
-package org.lsmr.selfcheckout.devices;
-
-import java.util.Arrays;
-import java.util.Currency;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.Random;
-
-import org.lsmr.selfcheckout.Banknote;
-import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
-import org.lsmr.selfcheckout.devices.observers.BanknoteValidatorObserver;
-
-/**
- * Represents a device for optically and/or magnetically validating banknotes.
- * Banknotes deemed valid are moved to storage; banknotes deemed invalid are
- * ejected.
- */
-public final class BanknoteValidator extends AbstractDevice<BanknoteValidatorObserver>
-	implements Acceptor<Banknote>, Emitter<Banknote> {
-	private final Currency currency;
-	private final int[] denominations;
-	private BidirectionalChannel<Banknote> source;
-	private UnidirectionalChannel<Banknote> sink;
-
-	/**
-	 * Creates a banknote validator that recognizes banknotes of the specified
-	 * denominations (i.e., values) and currency.
-	 * 
-	 * @param currency
-	 *            The kind of currency to accept.
-	 * @param denominations
-	 *            An array of the valid banknote denominations (like $5, $10, etc.)
-	 *            to accept. Each value must be &gt;0 and unique in this array.
-	 * @throws SimulationException
-	 *             If either argument is null.
-	 * @throws SimulationException
-	 *             If the denominations array does not contain at least one value.
-	 * @throws SimulationException
-	 *             If any value in the denominations array is non-positive.
-	 * @throws SimulationException
-	 *             If any value in the denominations array is non-unique.
-	 */
-	public BanknoteValidator(Currency currency, int[] denominations) {
-		if(currency == null)
-			throw new SimulationException(
-				new NullPointerException("currency is null, which has no analogue in the real world."));
-
-		if(denominations == null)
-			throw new SimulationException(
-				new NullPointerException("denominations is null, which has no analogue in the real world."));
-
-		if(denominations.length < 1)
-			throw new SimulationException(new IllegalArgumentException("There must be at least one denomination."));
-
-		this.currency = currency;
-		Arrays.sort(denominations);
-
-		HashSet<Integer> set = new HashSet<>();
-
-		for(int denomination : denominations) {
-			if(denomination <= 0)
-				throw new SimulationException(
-					new IllegalArgumentException("Non-positive denomination detected: " + denomination + "."));
-
-			if(set.contains(denomination))
-				throw new SimulationException(new IllegalArgumentException(
-					"Each denomination must be unique, but " + denomination + " is repeated."));
-
-			set.add(denomination);
-		}
-
-		this.denominations = denominations;
-	}
-
-	/**
-	 * Connects input and output channels to the banknote validator. Causes no events.
-	 * <p>
-	 * This operation is permissible only during the configuration phase.
-	 * 
-	 * @param source
-	 *            The channel from which banknotes normally arrive for validation,
-	 *            and to which invalid banknotes will be ejected.
-	 * @param sink
-	 *            The channel to which all valid banknotes are routed.
-	 */
-	public void connect(BidirectionalChannel<Banknote> source, UnidirectionalChannel<Banknote> sink) {
-		if(phase != Phase.CONFIGURATION)
-			throw new SimulationException(
-				new IllegalStateException("This method may only be called during the configuration phase."));
-
-		this.source = source;
-		this.sink = sink;
-	}
-
-	private final Random pseudoRandomNumberGenerator = new Random();
-	private static final int PROBABILITY_OF_FALSE_REJECTION = 1; /* out of 100 */
-
-	private boolean isValid(Banknote banknote) {
-		if(currency.equals(banknote.getCurrency()))
-			for(int denomination : denominations)
-				if(denomination == banknote.getValue())
-					return pseudoRandomNumberGenerator.nextInt(100) >= PROBABILITY_OF_FALSE_REJECTION;
-
-		return false;
-	}
-
-	/**
-	 * Tells the banknote validator that the indicated banknote is being inserted.
-	 * If the banknote is valid, a "validBanknoteDetected" event is announced to its
-	 * observers; otherwise, an "invalidBanknoteDetected" event is announced to its
-	 * observers.
-	 * <p>
-	 * If there is space in the machine to store a valid banknote, it is passed to
-	 * the sink channel.
-	 * </p>
-	 * <p>
-	 * If there is no space in the machine to store it or the banknote is invalid,
-	 * the banknote is ejected to the source.
-	 * </p>
-	 * <p>
-	 * This operation is not permissible during the configuration phase.
-	 * 
-	 * @param banknote
-	 *            The banknote to be added. Cannot be null.
-	 * @throws DisabledException
-	 *             if the banknote validator is currently disabled.
-	 * @throws SimulationException
-	 *             If the banknote is null.
-	 */
-	@Override
-	public void accept(Banknote banknote) throws DisabledException {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-		if(phase == Phase.CONFIGURATION)
-			throw new SimulationException(
-				new IllegalStateException("This method may not be called during the configuration phase."));
-
-		if(isDisabled())
-			throw new DisabledException();
-
-		if(banknote == null)
-			throw new SimulationException(new NullPointerException("banknote is null"));
-
-		if(isValid(banknote)) {
-			notifyValidBanknoteDetected(banknote);
-
-			if(sink.hasSpace()) {
-				try {
-					sink.deliver(banknote);
-				}
-				catch(OverloadException e) {
-					// Should never happen
-					phase = Phase.ERROR;
-					throw new SimulationException(e);
-				}
-			}
-			else {
-				try {
-					source.eject(banknote);
-				}
-				catch(OverloadException e) {
-					// Should never happen
-					phase = Phase.ERROR;
-					throw new SimulationException(e);
-				}
-			}
-		}
-		else {
-			notifyInvalidBanknoteDetected();
-
-			try {
-				source.eject(banknote);
-			}
-			catch(OverloadException e) {
-				// Should never happen
-				phase = Phase.ERROR;
-				throw new SimulationException("Unable to route banknote: sink is full");
-			}
-		}
-	}
-
-	@Override
-	public boolean hasSpace() {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-
-		return true;
-	}
-
-	private void notifyValidBanknoteDetected(Banknote banknote) {
-		for(BanknoteValidatorObserver observer : observers)
-			observer.validBanknoteDetected(this, banknote.getCurrency(), banknote.getValue());
-	}
-
-	private void notifyInvalidBanknoteDetected() {
-		for(BanknoteValidatorObserver observer : observers)
-			observer.invalidBanknoteDetected(this);
-	}
-}
diff --git a/src/org/lsmr/selfcheckout/devices/BarcodeScanner.java b/src/org/lsmr/selfcheckout/devices/BarcodeScanner.java
deleted file mode 100644
index 872da0e..0000000
--- a/src/org/lsmr/selfcheckout/devices/BarcodeScanner.java
+++ /dev/null
@@ -1,60 +0,0 @@
-package org.lsmr.selfcheckout.devices;
-
-import java.util.Random;
-
-import org.lsmr.selfcheckout.BarcodedItem;
-import org.lsmr.selfcheckout.Item;
-import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
-import org.lsmr.selfcheckout.devices.observers.BarcodeScannerObserver;
-
-/**
- * A complex device hidden behind a simple simulation. They can scan and that is
- * about all.
- */
-public class BarcodeScanner extends AbstractDevice<BarcodeScannerObserver> {
-	/**
-	 * Create a barcode scanner.
-	 */
-	public BarcodeScanner() {}
-
-	private Random random = new Random();
-	private static final int PROBABILITY_OF_FAILED_SCAN = 10; /* out of 100 */
-
-	/**
-	 * Simulates the customer's action of scanning an item. The result of the scan
-	 * is only announced to any registered observers.
-	 * <p>
-	 * This operation is not permissible during the configuration phase.
-	 * 
-	 * @param item
-	 *            The item to scan. Of course, it will only work if the item has a
-	 *            barcode, and maybe not even then.
-	 * @throws SimulationException
-	 *             If item is null.
-	 */
-	public void scan(Item item) {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-		if(phase == Phase.CONFIGURATION)
-			throw new SimulationException(
-				new IllegalStateException("This method may not be called during the configuration phase."));
-
-		if(isDisabled())
-			return; // silently ignore it
-
-		if(item == null)
-			throw new SimulationException(
-				new NullPointerException("item is null, which has no analogue in the real world."));
-
-		if(item instanceof BarcodedItem && random.nextInt(100) >= PROBABILITY_OF_FAILED_SCAN)
-			notifyBarcodeScanned((BarcodedItem)item);
-
-		// otherwise, silently ignore it
-	}
-
-	private void notifyBarcodeScanned(BarcodedItem item) {
-		for(BarcodeScannerObserver l : observers)
-			l.barcodeScanned(this, item.getBarcode());
-	}
-}
diff --git a/src/org/lsmr/selfcheckout/devices/BidirectionalChannel.java b/src/org/lsmr/selfcheckout/devices/BidirectionalChannel.java
deleted file mode 100644
index 4d67894..0000000
--- a/src/org/lsmr/selfcheckout/devices/BidirectionalChannel.java
+++ /dev/null
@@ -1,69 +0,0 @@
-package org.lsmr.selfcheckout.devices;
-
-import org.lsmr.selfcheckout.Banknote;
-import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
-
-/**
- * Represents a simple device (like, say, a tube or just a physical connection)
- * that moves things between other devices. This channel is bidirectional.
- * 
- * @param <T>
- *            The type of the things to move.
- */
-public final class BidirectionalChannel<T> {
-	private FlowThroughEmitter<T> source;
-	private Acceptor<T> sink;
-
-	/**
-	 * Constructs a new channel whose input is connected to the indicated source and
-	 * whose output is connected to the indicated sink.
-	 * 
-	 * @param source
-	 *            The device at the output end of the channel.
-	 * @param sink
-	 *            The device at the output end of the channel.
-	 */
-	public BidirectionalChannel(FlowThroughEmitter<T> source, Acceptor<T> sink) {
-		this.source = source;
-		this.sink = sink;
-	}
-
-	/**
-	 * Moves the indicated thing to the source. This method should be called by
-	 * the sink device, and not by an external application.
-	 * 
-	 * @param thing
-	 *            The thing to transport via the channel.
-	 * @throws OverloadException
-	 *             if the sink has no space for the banknote.
-	 * @throws DisabledException
-	 *             if the sink is currently disabled.
-	 */
-	public void eject(T thing) throws OverloadException, DisabledException {
-		source.emit(thing);
-	}
-
-	/**
-	 * Moves the indicated banknote to the sink. This method should be called by the
-	 * source device, and not by an external application.
-	 * 
-	 * @param banknote
-	 *            The banknote to transport via the channel.
-	 * @throws OverloadException
-	 *             if the sink has no space for the banknote.
-	 * @throws DisabledException
-	 *             if the sink is currently disabled.
-	 */
-	public void deliver(T banknote) throws OverloadException, DisabledException {
-		sink.accept(banknote);
-	}
-
-	/**
-	 * Returns whether the sink has space for at least one more banknote.
-	 * 
-	 * @return true if the sink can accept a banknote; false otherwise.
-	 */
-	public boolean hasSpace() {
-		return sink.hasSpace();
-	}
-}
diff --git a/src/org/lsmr/selfcheckout/devices/CardReader.java b/src/org/lsmr/selfcheckout/devices/CardReader.java
deleted file mode 100644
index de592f1..0000000
--- a/src/org/lsmr/selfcheckout/devices/CardReader.java
+++ /dev/null
@@ -1,185 +0,0 @@
-package org.lsmr.selfcheckout.devices;
-
-import java.awt.image.BufferedImage;
-import java.io.IOException;
-import java.util.concurrent.ThreadLocalRandom;
-
-import org.lsmr.selfcheckout.Card;
-import org.lsmr.selfcheckout.Card.CardData;
-import org.lsmr.selfcheckout.ChipFailureException;
-import org.lsmr.selfcheckout.MagneticStripeFailureException;
-import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
-import org.lsmr.selfcheckout.devices.observers.CardReaderObserver;
-
-/**
- * Represents the card reader, capable of tap, chip insert, and swipe. Either
- * the reader or the card may fail, or the data read in can be corrupted, with
- * varying probabilities.
- */
-public class CardReader extends AbstractDevice<CardReaderObserver> {
-	private boolean cardIsInserted = false;
-
-	/**
-	 * Create a card reader.
-	 */
-	public CardReader() {}
-
-	private final static ThreadLocalRandom random = ThreadLocalRandom.current();
-	private final static double PROBABILITY_OF_TAP_FAILURE = 0.01;
-	private final static double PROBABILITY_OF_INSERT_FAILURE = 0.01;
-	private final static double PROBABILITY_OF_SWIPE_FAILURE = 0.1;
-
-	/**
-	 * Tap the card.
-	 * <p>
-	 * This operation is not permissible during the configuration phase.
-	 * 
-	 * @param card
-	 *            The card to tap.
-	 * @return The card's (possibly corrupted) data, or null if the card is not tap
-	 *             enabled.
-	 * @throws IOException
-	 *             If the tap failed (lack of failure does not mean that the data is
-	 *             not corrupted).
-	 */
-	public CardData tap(Card card) throws IOException {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-		if(phase == Phase.CONFIGURATION)
-			throw new SimulationException(
-				new IllegalStateException("This method may not be called during the configuration phase."));
-
-		if(card.isTapEnabled) {
-			notifyCardTapped();
-
-			if(random.nextDouble(0.0, 1.0) > PROBABILITY_OF_TAP_FAILURE) {
-				CardData data = card.tap();
-
-				notifyCardDataRead(data);
-
-				return data;
-			}
-			else
-				throw new ChipFailureException();
-		}
-
-		// else ignore
-		return null;
-	}
-
-	/**
-	 * Swipe the card.
-	 * <p>
-	 * This operation is not permissible during the configuration phase.
-	 * 
-	 * @param card
-	 *            The card to swipe.
-	 * @return The card data.
-	 * @throws IOException
-	 *             If the swipe failed.
-	 */
-	public CardData swipe(Card card) throws IOException {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-		if(phase == Phase.CONFIGURATION)
-			throw new SimulationException(
-				new IllegalStateException("This method may not be called during the configuration phase."));
-
-		notifyCardSwiped();
-
-		if(random.nextDouble(0.0, 1.0) > PROBABILITY_OF_SWIPE_FAILURE) {
-			CardData data = card.swipe();
-
-			notifyCardDataRead(data);
-
-			return data;
-		}
-
-		throw new MagneticStripeFailureException();
-	}
-
-	/**
-	 * Insert the card.
-	 * <p>
-	 * This operation is not permissible during the configuration phase.
-	 * 
-	 * @param card
-	 *            The card to insert.
-	 * @param pin
-	 *            The customer's PIN.
-	 * @return The card data.
-	 * @throws SimulationException
-	 *             If there is already a card in the slot.
-	 * @throws IOException
-	 *             The insertion failed.
-	 */
-	public CardData insert(Card card, String pin) throws IOException {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-		if(phase == Phase.CONFIGURATION)
-			throw new SimulationException(
-				new IllegalStateException("This method may not be called during the configuration phase."));
-
-		if(cardIsInserted)
-			throw new IllegalStateException("There is already a card in the slot");
-
-		cardIsInserted = true;
-
-		notifyCardInserted();
-
-		if(card.hasChip && random.nextDouble(0.0, 1.0) > PROBABILITY_OF_INSERT_FAILURE) {
-			CardData data = card.insert(pin);
-
-			notifyCardDataRead(data);
-
-			return data;
-		}
-
-		throw new ChipFailureException();
-	}
-
-	/**
-	 * Remove the card from the slot.
-	 * <p>
-	 * This operation is not permissible during the configuration phase.
-	 */
-	public void remove() {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-		if(phase == Phase.CONFIGURATION)
-			throw new SimulationException(
-				new IllegalStateException("This method may not be called during the configuration phase."));
-
-		cardIsInserted = false;
-		notifyCardRemoved();
-	}
-
-	private void notifyCardTapped() {
-		for(CardReaderObserver l : observers)
-			l.cardTapped(this);
-	}
-
-	private void notifyCardInserted() {
-		for(CardReaderObserver l : observers)
-			l.cardInserted(this);
-	}
-
-	private void notifyCardSwiped() {
-		for(CardReaderObserver l : observers)
-			l.cardSwiped(this);
-	}
-
-	private void notifyCardDataRead(CardData data) {
-		for(CardReaderObserver l : observers)
-			l.cardDataRead(this, data);
-	}
-
-	private void notifyCardRemoved() {
-		for(CardReaderObserver l : observers)
-			l.cardRemoved(this);
-	}
-}
diff --git a/src/org/lsmr/selfcheckout/devices/CoinDispenser.java b/src/org/lsmr/selfcheckout/devices/CoinDispenser.java
deleted file mode 100644
index e6cdc73..0000000
--- a/src/org/lsmr/selfcheckout/devices/CoinDispenser.java
+++ /dev/null
@@ -1,262 +0,0 @@
-package org.lsmr.selfcheckout.devices;
-
-import java.util.ArrayList;
-import java.util.LinkedList;
-import java.util.List;
-import java.util.Queue;
-
-import org.lsmr.selfcheckout.Coin;
-import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
-import org.lsmr.selfcheckout.devices.observers.CoinDispenserObserver;
-
-/**
- * Represents a device that stores coins of a particular denomination to
- * dispense them as change.
- * <p>
- * Coin dispensers can receive coins from other sources. To simplify the
- * simulation, no check is performed on the value of each coin, meaning it is an
- * external responsibility to ensure the correct routing of coins.
- * </p>
- */
-public final class CoinDispenser extends AbstractDevice<CoinDispenserObserver>
-	implements Acceptor<Coin>, FromStorageEmitter<Coin> {
-	private int maxCapacity;
-	private Queue<Coin> queue = new LinkedList<Coin>();
-	private UnidirectionalChannel<Coin> sink;
-
-	/**
-	 * Creates a coin dispenser with the indicated maximum capacity.
-	 * 
-	 * @param capacity
-	 *            The maximum number of coins that can be stored in the dispenser.
-	 *            Must be positive.
-	 * @throws SimulationException
-	 *             if capacity is not positive.
-	 */
-	public CoinDispenser(int capacity) {
-		if(capacity <= 0)
-			throw new SimulationException(new IllegalArgumentException("Capacity must be positive: " + capacity));
-
-		this.maxCapacity = capacity;
-	}
-
-	/**
-	 * Accesses the current number of coins in the dispenser.
-	 * <p>
-	 * This operation is permissible during the configuration phase.
-	 * 
-	 * @return The number of coins currently in the dispenser.
-	 */
-	public int size() {
-		return queue.size();
-	}
-
-	/**
-	 * Allows a set of coins to be loaded into the dispenser directly. Existing
-	 * coins in the dispenser are not removed. Causes a "coinsLoaded" event to be
-	 * announced.
-	 * <p>
-	 * This operation is permissible during the configuration phase.
-	 * 
-	 * @param coins
-	 *            A sequence of coins to be added. Each cannot be null.
-	 * @throws OverloadException
-	 *             if the number of coins to be loaded exceeds the capacity of the
-	 *             dispenser.
-	 * @throws SimulationException
-	 *             If any coin is null.
-	 */
-	public void load(Coin... coins) throws SimulationException, OverloadException {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-
-		if(maxCapacity < queue.size() + coins.length)
-			throw new OverloadException("Capacity of dispenser is exceeded by load");
-
-		for(Coin coin : coins)
-			if(coin == null)
-				throw new SimulationException(new NullPointerException("A coin is null"));
-			else
-				queue.add(coin);
-
-		notifyLoad(coins);
-	}
-
-	private void notifyLoad(Coin[] coins) {
-		for(CoinDispenserObserver observer : observers)
-			observer.coinsLoaded(this, coins);
-	}
-
-	/**
-	 * Unloads coins from the dispenser directly. Causes a "coinsUnloaded" event to
-	 * be announced.
-	 * <p>
-	 * This operation is permissible during the configuration phase.
-	 * 
-	 * @return A list of the coins unloaded. May be empty. Will never be null.
-	 */
-	public List<Coin> unload() {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-
-		List<Coin> result = new ArrayList<>(queue);
-		queue.clear();
-
-		notifyUnload(result.toArray(new Coin[result.size()]));
-
-		return result;
-	}
-
-	private void notifyUnload(Coin[] coins) {
-		for(CoinDispenserObserver observer : observers)
-			observer.coinsUnloaded(this, coins);
-	}
-
-	/**
-	 * Connects an output channel to this coin dispenser. Any existing output
-	 * channels are disconnected. Causes no events to be announced.
-	 * <p>
-	 * This operation is only permissible during the configuration phase.
-	 * 
-	 * @param sink
-	 *            The new output device to act as output. Can be null, which leaves
-	 *            the channel without an output.
-	 */
-	public void connect(UnidirectionalChannel<Coin> sink) {
-		if(phase != Phase.CONFIGURATION)
-			throw new SimulationException(
-				new IllegalStateException("This method may only be called during the configuration phase."));
-
-		this.sink = sink;
-	}
-
-	/**
-	 * Returns the maximum capacity of this coin dispenser.
-	 * <p>
-	 * This operation is permissible during the configuration phase.
-	 * 
-	 * @return The capacity. Will be positive.
-	 */
-	public int getCapacity() {
-		return maxCapacity;
-	}
-
-	/**
-	 * Causes the indicated coin to be added into the dispenser. If successful, a
-	 * "coinAdded" event is announced to its observers. If a successful coin
-	 * addition causes the dispenser to become full, a "coinsFull" event is
-	 * announced to its observers.
-	 * <p>
-	 * This operation is not permissible during the configuration phase.
-	 * 
-	 * @throws DisabledException
-	 *             If the coin dispenser is currently disabled.
-	 * @throws SimulationException
-	 *             If coin is null.
-	 * @throws OverloadException
-	 *             If the coin dispenser is already full.
-	 */
-	@Override
-	public void accept(Coin coin) throws OverloadException, DisabledException {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-		if(phase == Phase.CONFIGURATION)
-			throw new SimulationException(
-				new IllegalStateException("This method may not be called during the configuration phase."));
-
-		if(isDisabled())
-			throw new DisabledException();
-
-		if(coin == null)
-			throw new SimulationException(
-				new NullPointerException("coin is null, which has no analogue in the real world."));
-
-		if(queue.size() >= maxCapacity)
-			throw new OverloadException();
-
-		queue.add(coin);
-		notifyCoinAdded(coin);
-
-		if(queue.size() >= maxCapacity)
-			notifyCoinsFull();
-	}
-
-	/**
-	 * Releases a single coin from this coin dispenser. If successful, a
-	 * "coinRemoved" event is announced to its observers. If a successful coin
-	 * removal causes the dispenser to become empty, a "coinsEmpty" event is
-	 * announced to its observers.
-	 * <p>
-	 * This operation is not permissible during the configuration phase.
-	 * 
-	 * @throws OverloadException
-	 *             If the output channel is unable to accept another coin.
-	 * @throws EmptyException
-	 *             If no coins are present in the dispenser to release.
-	 * @throws DisabledException
-	 *             If the dispenser is currently disabled.
-	 */
-	public void emit() throws OverloadException, EmptyException, DisabledException {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-		if(phase == Phase.CONFIGURATION)
-			throw new SimulationException(
-				new IllegalStateException("This method may not be called during the configuration phase."));
-
-		if(isDisabled())
-			throw new DisabledException();
-
-		if(queue.size() == 0)
-			throw new EmptyException();
-
-		Coin coin = queue.remove();
-
-		notifyCoinRemoved(coin);
-		sink.deliver(coin);
-
-		if(queue.isEmpty())
-			notifyCoinsEmpty();
-	}
-
-	/**
-	 * Returns whether this coin dispenser has enough space to accept at least one
-	 * more coin. Announces no events.
-	 * <p>
-	 * This operation is not permissible during the configuration phase.
-	 */
-	@Override
-	public boolean hasSpace() {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-		if(phase == Phase.CONFIGURATION)
-			throw new SimulationException(
-				new IllegalStateException("This method may not be called during the configuration phase."));
-
-		return queue.size() < maxCapacity;
-	}
-
-	private void notifyCoinAdded(Coin coin) {
-		for(CoinDispenserObserver observer : observers)
-			observer.coinAdded(this, coin);
-	}
-
-	private void notifyCoinRemoved(Coin coin) {
-		for(CoinDispenserObserver observer : observers)
-			observer.coinRemoved(this, coin);
-	}
-
-	private void notifyCoinsFull() {
-		for(CoinDispenserObserver observer : observers)
-			observer.coinsFull(this);
-	}
-
-	private void notifyCoinsEmpty() {
-		for(CoinDispenserObserver observer : observers)
-			observer.coinsEmpty(this);
-	}
-}
diff --git a/src/org/lsmr/selfcheckout/devices/CoinSlot.java b/src/org/lsmr/selfcheckout/devices/CoinSlot.java
deleted file mode 100644
index 514af14..0000000
--- a/src/org/lsmr/selfcheckout/devices/CoinSlot.java
+++ /dev/null
@@ -1,97 +0,0 @@
-package org.lsmr.selfcheckout.devices;
-
-import org.lsmr.selfcheckout.Coin;
-import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
-import org.lsmr.selfcheckout.devices.observers.CoinSlotObserver;
-
-/**
- * Represents a simple coin slot device that has one output channel. The slot is
- * stupid: it has no functionality other than being enabled/disabled, and cannot
- * determine the value and currency of the coin.
- */
-public final class CoinSlot extends AbstractDevice<CoinSlotObserver> implements Acceptor<Coin> {
-	private UnidirectionalChannel<Coin> sink;
-
-	/**
-	 * Creates a coin slot.
-	 */
-	public CoinSlot() {}
-
-	/**
-	 * Connects channels to the coin slot. Causes no events.
-	 * <p>
-	 * This operation is permissible only during the configuration phase.
-	 * 
-	 * @param sink
-	 *            Where coins will always be passed.
-	 */
-	public void connect(UnidirectionalChannel<Coin> sink) {
-		if(phase != Phase.CONFIGURATION)
-			throw new SimulationException(
-				new IllegalStateException("This method may only be called during the configuration phase."));
-
-		this.sink = sink;
-	}
-
-	/**
-	 * Tells the coin slot that the indicated coin is being inserted. If the slot is
-	 * enabled, this causes a "coinInserted" event to be announced to its observers.
-	 * <p>
-	 * This operation is not permissible during the configuration phase.
-	 * 
-	 * @param coin
-	 *            The coin to be added. Cannot be null.
-	 * @throws DisabledException
-	 *             If the coin slot is currently disabled.
-	 * @throws SimulationException
-	 *             If coin is null.
-	 * @throws NullPointerException
-	 *             If the coin is null.
-	 */
-	public void accept(Coin coin) throws DisabledException {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-		if(phase == Phase.CONFIGURATION)
-			throw new SimulationException(
-				new IllegalStateException("This method may not be called during the configuration phase."));
-
-		if(isDisabled())
-			throw new DisabledException();
-
-		if(coin == null)
-			throw new SimulationException(new NullPointerException("coin is null"));
-
-		notifyCoinInserted();
-
-		if(sink.hasSpace()) {
-			try {
-				sink.deliver(coin);
-			}
-			catch(OverloadException e) {
-				// Should never happen
-				phase = Phase.ERROR;
-				throw new SimulationException(e);
-			}
-		}
-		else
-			throw new SimulationException("Unable to route coin: Output channel is full");
-	}
-
-	@Override
-	public boolean hasSpace() {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-		if(phase == Phase.CONFIGURATION)
-			throw new SimulationException(
-				new IllegalStateException("This method may not be called during the configuration phase."));
-
-		return sink.hasSpace();
-	}
-
-	private void notifyCoinInserted() {
-		for(CoinSlotObserver observer : observers)
-			observer.coinInserted(this);
-	}
-}
diff --git a/src/org/lsmr/selfcheckout/devices/CoinStorageUnit.java b/src/org/lsmr/selfcheckout/devices/CoinStorageUnit.java
deleted file mode 100644
index 6fc0059..0000000
--- a/src/org/lsmr/selfcheckout/devices/CoinStorageUnit.java
+++ /dev/null
@@ -1,186 +0,0 @@
-package org.lsmr.selfcheckout.devices;
-
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.List;
-
-import org.lsmr.selfcheckout.Coin;
-import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
-import org.lsmr.selfcheckout.devices.observers.CoinStorageUnitObserver;
-
-/**
- * Represents devices that store coins. They only receive coins, not dispense
- * them. To access the coins inside, a human operator needs to physically remove
- * the coins, simulated with the {@link #unload()} method. A
- * {@link #load(Coin...)} method is provided for symmetry.
- */
-public class CoinStorageUnit extends AbstractDevice<CoinStorageUnitObserver> implements Acceptor<Coin> {
-	private Coin[] storage;
-	private int nextIndex = 0;
-
-	/**
-	 * Creates a coin storage unit that can hold the indicated number of coins.
-	 * 
-	 * @param capacity
-	 *            The maximum number of coins that the unit can hold.
-	 * @throws SimulationException
-	 *             If the capacity is not positive.
-	 */
-	public CoinStorageUnit(int capacity) {
-		if(capacity <= 0)
-			throw new SimulationException(new IllegalArgumentException("The capacity must be positive."));
-
-		storage = new Coin[capacity];
-	}
-
-	/**
-	 * Gets the maximum number of coins that this storage unit can hold.
-	 * <p>
-	 * This operation is permissible during the configuration phase.
-	 * 
-	 * @return The capacity.
-	 */
-	public int getCapacity() {
-		return storage.length;
-	}
-
-	/**
-	 * Gets the current count of coins contained in this storage unit.
-	 * <p>
-	 * This operation is permissible during the configuration phase.
-	 * 
-	 * @return The current count.
-	 */
-	public int getCoinCount() {
-		return nextIndex;
-	}
-
-	/**
-	 * Allows a set of coins to be loaded into the storage unit directly. Existing
-	 * coins in the dispenser are not removed. Causes a "coinsLoaded" event to be
-	 * announced. Disabling has no effect on loading/unloading.
-	 * <p>
-	 * This operation is not permissible during the configuration phase.
-	 * 
-	 * @param coins
-	 *            A sequence of coins to be added. Each cannot be null.
-	 * @throws SimulationException
-	 *             if the number of coins to be loaded exceeds the capacity of the
-	 *             unit.
-	 * @throws SimulationException
-	 *             If coins is null.
-	 * @throws SimulationException
-	 *             If any coin is null.
-	 * @throws OverloadException
-	 *             If too many coins are loaded.
-	 */
-	public void load(Coin... coins) throws SimulationException, OverloadException {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-
-		if(coins == null)
-			throw new SimulationException(
-				new NullPointerException("coins is null, which has no analogue in the real world."));
-
-		if(coins.length + nextIndex > storage.length)
-			throw new OverloadException("You tried to stuff too many coins in the storage unit.");
-
-		for(Coin coin : coins)
-			if(coin == null)
-				throw new SimulationException(new NullPointerException("No coin may be null"));
-
-		System.arraycopy(coins, 0, storage, nextIndex, coins.length);
-		nextIndex += coins.length;
-
-		notifyCoinsLoaded();
-	}
-
-	/**
-	 * Unloads coins from the storage unit directly. Causes a "coinsUnloaded" event
-	 * to be announced.
-	 * <p>
-	 * This operation is permissible during the configuration phase.
-	 * 
-	 * @return A list of the coins unloaded. May be empty. Will never be null.
-	 */
-	public List<Coin> unload() {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-
-		List<Coin> coins = Arrays.asList(storage);
-
-		storage = new Coin[storage.length];
-		nextIndex = 0;
-		notifyCoinsUnloaded();
-
-		return coins;
-	}
-
-	/**
-	 * Causes the indicated coin to be added to the storage unit. If successful, a
-	 * "coinAdded" event is announced to its observers. If a successful coin
-	 * addition instead causes the unit to become full, a "coinsFull" event is
-	 * announced to its observers.
-	 * <p>
-	 * This operation is not permissible during the configuration phase.
-	 * 
-	 * @throws DisabledException
-	 *             If the unit is currently disabled.
-	 * @throws SimulationException
-	 *             If coin is null.
-	 * @throws OverloadException
-	 *             If the unit is already full.
-	 */
-	public void accept(Coin coin) throws DisabledException, OverloadException {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-		if(phase == Phase.CONFIGURATION)
-			throw new SimulationException(
-				new IllegalStateException("This method may not be called during the configuration phase."));
-
-		if(isDisabled())
-			throw new DisabledException();
-
-		if(coin == null)
-			throw new SimulationException(new NullPointerException("coin is null"));
-
-		if(nextIndex < storage.length) {
-			storage[nextIndex++] = coin;
-
-			if(nextIndex == storage.length)
-				notifyCoinsFull();
-			else
-				notifyCoinAdded();
-		}
-		else
-			throw new OverloadException();
-	}
-
-	@Override
-	public boolean hasSpace() {
-		return nextIndex < storage.length;
-	}
-
-	private void notifyCoinsLoaded() {
-		for(CoinStorageUnitObserver l : observers)
-			l.coinsLoaded(this);
-	}
-
-	private void notifyCoinsUnloaded() {
-		for(CoinStorageUnitObserver l : observers)
-			l.coinsUnloaded(this);
-	}
-
-	private void notifyCoinsFull() {
-		for(CoinStorageUnitObserver l : observers)
-			l.coinsFull(this);
-	}
-
-	private void notifyCoinAdded() {
-		for(CoinStorageUnitObserver l : observers)
-			l.coinAdded(this);
-	}
-}
diff --git a/src/org/lsmr/selfcheckout/devices/CoinTray.java b/src/org/lsmr/selfcheckout/devices/CoinTray.java
deleted file mode 100644
index dabc9c3..0000000
--- a/src/org/lsmr/selfcheckout/devices/CoinTray.java
+++ /dev/null
@@ -1,102 +0,0 @@
-package org.lsmr.selfcheckout.devices;
-
-import java.util.Arrays;
-import java.util.List;
-
-import org.lsmr.selfcheckout.Coin;
-import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
-import org.lsmr.selfcheckout.devices.observers.CoinTrayObserver;
-
-/**
- * Simulates the tray where dispensed coins go for the user to collect them.
- */
-public class CoinTray extends AbstractDevice<CoinTrayObserver> implements Acceptor<Coin> {
-	private Coin[] coins;
-	private int nextIndex = 0;
-
-	/**
-	 * Creates a coin tray.
-	 * 
-	 * @param capacity
-	 *            The maximum number of coins that this tray can hold without
-	 *            overflowing.
-	 * @throws SimulationException
-	 *             If the capacity is &le;0.
-	 */
-	public CoinTray(int capacity) {
-		if(capacity <= 0)
-			throw new SimulationException(new IllegalArgumentException("capacity must be positive."));
-
-		coins = new Coin[capacity];
-	}
-
-	/**
-	 * Causes the indicated coin to be added to the tray. A "coinAdded" event is
-	 * announced to observers.
-	 * <p>
-	 * This operation is not permissible during the configuration phase.
-	 * 
-	 * @param coin
-	 *            The coin to add.
-	 * @throws SimulationException
-	 *             If coin is null.
-	 * @throws OverloadException
-	 *             If the tray overflows.
-	 */
-	public void accept(Coin coin) throws OverloadException, DisabledException {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-		if(phase == Phase.CONFIGURATION)
-			throw new SimulationException(
-				new IllegalStateException("This method may not be called during the configuration phase."));
-
-		if(coin == null)
-			throw new SimulationException(
-				new NullPointerException("coin is null, which has no analogue in the real world."));
-
-		if(nextIndex < coins.length) {
-			coins[nextIndex++] = coin;
-			notifyCoinAdded();
-		}
-		else
-			throw new OverloadException("The tray has overflowed.");
-	}
-
-	/**
-	 * Simulates the act of physically removing coins from the try by a user.
-	 * <p>
-	 * This operation is not permissible during the configuration phase.
-	 * 
-	 * @return The list of coins collected. May not be null. May be empty.
-	 */
-	public List<Coin> collectCoins() {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-		if(phase == Phase.CONFIGURATION)
-			throw new SimulationException(
-				new IllegalStateException("This method may not be called during the configuration phase."));
-
-		List<Coin> result = Arrays.asList(coins);
-
-		coins = new Coin[coins.length];
-		nextIndex = 0;
-
-		return result;
-	}
-
-	/**
-	 * Returns whether this coin receptacle has enough space to accept at least one
-	 * more coin: always true. Causes no events.
-	 */
-	@Override
-	public boolean hasSpace() {
-		return nextIndex < coins.length;
-	}
-
-	private void notifyCoinAdded() {
-		for(CoinTrayObserver l : observers)
-			l.coinAdded(this);
-	}
-}
diff --git a/src/org/lsmr/selfcheckout/devices/CoinValidator.java b/src/org/lsmr/selfcheckout/devices/CoinValidator.java
deleted file mode 100644
index faf47e3..0000000
--- a/src/org/lsmr/selfcheckout/devices/CoinValidator.java
+++ /dev/null
@@ -1,268 +0,0 @@
-package org.lsmr.selfcheckout.devices;
-
-import java.math.BigDecimal;
-import java.util.Collections;
-import java.util.Currency;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Map;
-import java.util.Random;
-
-import org.lsmr.selfcheckout.Coin;
-import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
-import org.lsmr.selfcheckout.devices.observers.CoinValidatorObserver;
-
-/**
- * Represents a device for optically and/or physically validating coins. Coins
- * deemed valid are moved to storage; coins deemed invalid are ejected.
- */
-public final class CoinValidator extends AbstractDevice<CoinValidatorObserver> implements Acceptor<Coin> {
-	public final Currency currency;
-	private List<BigDecimal> denominations;
-	private UnidirectionalChannel<Coin> rejectionSink, overflowSink;
-	private Map<BigDecimal, UnidirectionalChannel<Coin>> standardSinks = null;
-
-	/**
-	 * Creates a coin validator that recognizes coins of the specified denominations
-	 * (i.e., values) and currency.
-	 * 
-	 * @param currency
-	 *            The kind of currency to accept.
-	 * @param denominations
-	 *            An array of the valid coin denominations (like $0.05, $0.10, etc.)
-	 *            to accept. Each value must be &gt;0 and unique in this array.
-	 * @throws SimulationException
-	 *             If either argument is null.
-	 * @throws SimulationException
-	 *             If the denominations array does not contain at least one value.
-	 * @throws SimulationException
-	 *             If any value in the denominations array is non-positive.
-	 * @throws SimulationException
-	 *             If any value in the denominations array is non-unique.
-	 */
-	public CoinValidator(Currency currency, List<BigDecimal> denominations) {
-		if(currency == null)
-			throw new SimulationException(
-				new NullPointerException("currency is null, which has no analogue in the real world."));
-
-		if(denominations == null)
-			throw new SimulationException(
-				new NullPointerException("denominations is null, which has no analogue in the real world."));
-
-		if(denominations.size() < 1)
-			throw new SimulationException(new IllegalArgumentException("There must be at least one denomination."));
-
-		this.currency = currency;
-		Collections.sort(denominations);
-
-		standardSinks = new HashMap<>();
-
-		for(BigDecimal denomination : denominations) {
-			if(denomination == null)
-				throw new SimulationException(new NullPointerException("A denomination is null"));
-
-			if(denomination.compareTo(BigDecimal.ZERO) <= 0)
-				throw new SimulationException(
-					new IllegalArgumentException("Non-positive denomination detected: " + denomination + "."));
-
-			if(standardSinks.containsKey(denomination))
-				throw new SimulationException(new IllegalArgumentException(
-					"Each denomination must be unique, but " + denomination + " is repeated."));
-
-			standardSinks.put(denomination, null);
-		}
-
-		this.denominations = denominations;
-	}
-
-	/**
-	 * Connects input and output channels to the coin slot. Causes no events.
-	 * <p>
-	 * This operation is permissible only during the configuration phase.
-	 * 
-	 * @param rejectionSink
-	 *            The channel to which rejected coins are routed.
-	 * @param overflowSink
-	 *            The channel to which valid coins are routed when the normal sink
-	 *            is full.
-	 * @param standardSinks
-	 *            The channels to which valid coins are normally routed. There must
-	 *            be one sink to correspond to each valid currency denomination, and
-	 *            they must be in the same order as the valid denominations.
-	 * @throws SimulationException
-	 *             If any argument is null.
-	 * @throws SimulationException
-	 *             If any standard sink is null.
-	 * @throws SimulationException
-	 *             If the number of standard sinks differs from the number of
-	 *             denominations.
-	 * @throws SimulationException
-	 *             If any sink is used in more than one position.
-	 */
-	public void connect(UnidirectionalChannel<Coin> rejectionSink,
-		Map<BigDecimal, UnidirectionalChannel<Coin>> standardSinks, UnidirectionalChannel<Coin> overflowSink) {
-		if(phase != Phase.CONFIGURATION)
-			throw new SimulationException(
-				new IllegalStateException("This method may only be called during the configuration phase."));
-
-		if(rejectionSink == null)
-			throw new SimulationException(
-				new NullPointerException("rejectionSink is null, which has no analogue in the real world."));
-
-		if(overflowSink == null)
-			throw new SimulationException(
-				new NullPointerException("overflowSink is null, which has no analogue in the real world."));
-
-		if(standardSinks == null)
-			throw new SimulationException(
-				new NullPointerException("standardSinks is null, which has no analogue in the real world."));
-
-		if(standardSinks.keySet().size() != denominations.size())
-			throw new SimulationException(
-				new IllegalArgumentException("The number of standard sinks must equal the number of denominations."));
-
-		this.rejectionSink = rejectionSink;
-		this.overflowSink = overflowSink;
-
-		HashSet<UnidirectionalChannel<Coin>> set = new HashSet<>();
-
-		for(BigDecimal denomination : standardSinks.keySet()) {
-			UnidirectionalChannel<Coin> sink = standardSinks.get(denomination);
-			if(sink == null)
-				throw new SimulationException(
-					new NullPointerException("The sink for denomination " + denomination + " is null."));
-			else {
-				if(set.contains(sink))
-					throw new SimulationException(new IllegalArgumentException("Each channel must be unique."));
-
-				set.add(sink);
-			}
-		}
-
-		this.standardSinks = standardSinks;
-
-		if(set.contains(rejectionSink))
-			throw new SimulationException(new IllegalArgumentException("Each channel must be unique."));
-		else
-			set.add(rejectionSink);
-
-		if(set.contains(overflowSink))
-			throw new SimulationException(new IllegalArgumentException("Each channel must be unique."));
-
-		this.overflowSink = overflowSink;
-	}
-
-	private final Random pseudoRandomNumberGenerator = new Random();
-	private static final int PROBABILITY_OF_FALSE_REJECTION = 1; /* out of 100 */
-
-	private boolean isValid(Coin coin) {
-		if(currency.equals(coin.getCurrency()))
-			for(BigDecimal denomination : denominations)
-				if(denomination.equals(coin.getValue()))
-					return pseudoRandomNumberGenerator.nextInt(100) >= PROBABILITY_OF_FALSE_REJECTION;
-
-		return false;
-	}
-
-	/**
-	 * Tells the coin validator that the indicated coin is being inserted. If the
-	 * coin is valid, a "validCoinDetected" event is announced to its observers;
-	 * otherwise, an "invalidCoinDetected" event is announced to its observers.
-	 * <p>
-	 * If there is space in the machine to store a valid coin, it is passed to the
-	 * sink channel corresponding to the denomination of the coin.
-	 * </p>
-	 * <p>
-	 * If there is no space in the machine to store it or the coin is invalid, the
-	 * coin is ejected to the source.
-	 * </p>
-	 * <p>
-	 * This operation is not permissible during the configuration phase.
-	 * 
-	 * @param coin
-	 *            The coin to be added. Cannot be null.
-	 * @throws DisabledException
-	 *             if the coin validator is currently disabled.
-	 * @throws SimulationException
-	 *             If the coin is null.
-	 * @throws SimulationException
-	 *             If the coin cannot be delivered.
-	 */
-	public void accept(Coin coin) throws DisabledException {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-		if(phase == Phase.CONFIGURATION)
-			throw new SimulationException(
-				new IllegalStateException("This method may not be called during the configuration phase."));
-
-		if(isDisabled())
-			throw new DisabledException();
-
-		if(coin == null)
-			throw new SimulationException(
-				new NullPointerException("coin is null, which has no analogue in the real world."));
-
-		if(isValid(coin)) {
-			notifyValidCoinDetected(coin);
-
-			UnidirectionalChannel<Coin> sink = standardSinks.get(coin.getValue());
-
-			if(sink.hasSpace()) {
-				try {
-					sink.deliver(coin);
-				}
-				catch(OverloadException e) {
-					// Should never happen
-					phase = Phase.ERROR;
-					throw new SimulationException(e);
-				}
-			}
-			else {
-				try {
-					rejectionSink.deliver(coin);
-				}
-				catch(OverloadException e) {
-					// Should never happen
-					phase = Phase.ERROR;
-					throw new SimulationException(e);
-				}
-			}
-		}
-		else {
-			notifyInvalidCoinDetected(coin);
-
-			try {
-				rejectionSink.deliver(coin);
-			}
-			catch(OverloadException e) {
-				// Should never happen
-				phase = Phase.ERROR;
-				throw new SimulationException(e);
-			}
-		}
-	}
-
-	@Override
-	public boolean hasSpace() {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-		if(phase == Phase.CONFIGURATION)
-			throw new SimulationException(
-				new IllegalStateException("This method may not be called during the configuration phase."));
-
-		return true; // Since we cannot know yet where a coin will route, assume that it is OK.
-	}
-
-	private void notifyValidCoinDetected(Coin coin) {
-		for(CoinValidatorObserver observer : observers)
-			observer.validCoinDetected(this, coin.getValue());
-	}
-
-	private void notifyInvalidCoinDetected(Coin coin) {
-		for(CoinValidatorObserver observer : observers)
-			observer.invalidCoinDetected(this);
-	}
-}
diff --git a/src/org/lsmr/selfcheckout/devices/DisabledException.java b/src/org/lsmr/selfcheckout/devices/DisabledException.java
deleted file mode 100644
index 6f1690f..0000000
--- a/src/org/lsmr/selfcheckout/devices/DisabledException.java
+++ /dev/null
@@ -1,8 +0,0 @@
-package org.lsmr.selfcheckout.devices;
-
-/**
- * Issued when a device cannot perform its usual functions because it has been
- * disabled.
- */
-@SuppressWarnings("serial")
-public class DisabledException extends Exception {}
diff --git a/src/org/lsmr/selfcheckout/devices/ElectronicScale.java b/src/org/lsmr/selfcheckout/devices/ElectronicScale.java
deleted file mode 100644
index ffdc112..0000000
--- a/src/org/lsmr/selfcheckout/devices/ElectronicScale.java
+++ /dev/null
@@ -1,171 +0,0 @@
-package org.lsmr.selfcheckout.devices;
-
-import java.util.ArrayList;
-
-import org.lsmr.selfcheckout.Item;
-import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
-import org.lsmr.selfcheckout.devices.observers.ElectronicScaleObserver;
-
-public class ElectronicScale extends AbstractDevice<ElectronicScaleObserver> {
-	private ArrayList<Item> items = new ArrayList<>();
-
-	private double weightLimitInGrams;
-	private double currentWeightInGrams = 0;
-	private double weightAtLastEvent = 0;
-	private double sensitivity;
-
-	/**
-	 * Constructs an electronic scale with the indicated maximum weight that it can
-	 * handle before going into overload.
-	 * 
-	 * @param weightLimitInGrams
-	 *            The weight threshold beyond which the scale will overload.
-	 * @param sensitivity
-	 *            The number of grams that can be added or removed since the last
-	 *            change event, without causing a new change event.
-	 * @throws SimulationException
-	 *             If either argument is &le;0.
-	 */
-	public ElectronicScale(int weightLimitInGrams, int sensitivity) {
-		if(weightLimitInGrams <= 0)
-			throw new SimulationException(new IllegalArgumentException("The maximum weight cannot be zero or less."));
-
-		if(sensitivity <= 0)
-			throw new SimulationException(new IllegalArgumentException("The sensitivity cannot be zero or less."));
-
-		this.weightLimitInGrams = weightLimitInGrams;
-		this.sensitivity = sensitivity;
-	}
-
-	/**
-	 * Gets the weight limit for the scale.
-	 * <p>
-	 * This operation is permissible during the configuration phase.
-	 * 
-	 * @return The weight limit.
-	 */
-	public double getWeightLimit() {
-		return weightLimitInGrams;
-	}
-
-	/**
-	 * Gets the current weight on the scale.
-	 * <p>
-	 * This operation is not permissible during the configuration phase.
-	 * 
-	 * @return The current weight.
-	 * @throws OverloadException
-	 *             If the weight has overloaded the scale.
-	 */
-	public double getCurrentWeight() throws OverloadException {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-		if(phase == Phase.CONFIGURATION)
-			throw new SimulationException(
-				new IllegalStateException("This method may not be called during the configuration phase."));
-
-		if(currentWeightInGrams <= weightLimitInGrams)
-			return currentWeightInGrams;
-
-		throw new OverloadException();
-	}
-
-	/**
-	 * Gets the sensitivity of the scale. Changes smaller than this limit are not
-	 * noticed or announced.
-	 * <p>
-	 * This operation is permissible during the configuration phase.
-	 * 
-	 * @return The sensitivity.
-	 */
-	public double getSensitivity() {
-		return sensitivity;
-	}
-
-	/**
-	 * Adds an item to the scale.
-	 * <p>
-	 * This operation is not permissible during the configuration phase.
-	 * 
-	 * @param item
-	 *            The item to add.
-	 * @throws SimulationException
-	 *             If the same item is added more than once.
-	 */
-	public void add(Item item) {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-		if(phase == Phase.CONFIGURATION)
-			throw new SimulationException(
-				new IllegalStateException("This method may not be called during the configuration phase."));
-
-		if(items.contains(item))
-			throw new SimulationException("The same item cannot be added more than once to the scale.");
-
-		currentWeightInGrams += item.getWeight();
-
-		items.add(item);
-
-		if(currentWeightInGrams > weightLimitInGrams)
-			notifyOverload();
-		else if(currentWeightInGrams - weightAtLastEvent > sensitivity)
-			notifyWeightChanged();
-	}
-
-	/**
-	 * Removes an item from the scale.
-	 * <p>
-	 * This operation is not permissible during the configuration phase.
-	 * 
-	 * @param item
-	 *            The item to remove.
-	 * @throws SimulationException
-	 *             If the item is not on the scale.
-	 */
-	public void remove(Item item) {
-		if(phase == Phase.ERROR)
-			throw new SimulationException(new IllegalStateException(
-				"This method may not be used when the device is in an erroneous operation phase."));
-		if(phase == Phase.CONFIGURATION)
-			throw new SimulationException(
-				new IllegalStateException("This method may not be called during the configuration phase."));
-
-		if(!items.remove(item))
-			throw new SimulationException("The item was not found amongst those on the scale.");
-
-		// To avoid drift in the sum due to round-off error, recalculate the weight.
-		double newWeightInGrams = 0.0;
-		for(Item itemOnScale : items)
-			newWeightInGrams += itemOnScale.getWeight();
-
-		double original = currentWeightInGrams;
-		currentWeightInGrams = newWeightInGrams;
-
-		if(original > weightLimitInGrams && newWeightInGrams <= weightLimitInGrams)
-			notifyOutOfOverload();
-
-		if(currentWeightInGrams <= weightLimitInGrams && weightAtLastEvent - currentWeightInGrams >= sensitivity)
-			notifyWeightChanged();
-	}
-
-	private void notifyOverload() {
-		for(ElectronicScaleObserver l : observers)
-			l.overload(this);
-	}
-
-	private void notifyOutOfOverload() {
-		weightAtLastEvent = currentWeightInGrams;
-
-		for(ElectronicScaleObserver l : observers)
-			l.outOfOverload(this);
-	}
-
-	private void notifyWeightChanged() {
-		weightAtLastEvent = currentWeightInGrams;
-
-		for(ElectronicScaleObserver l : observers)
-			l.weightChanged(this, currentWeightInGrams);
-	}
-}
diff --git a/src/org/lsmr/selfcheckout/devices/Emitter.java b/src/org/lsmr/selfcheckout/devices/Emitter.java
deleted file mode 100644
index a8ab600..0000000
--- a/src/org/lsmr/selfcheckout/devices/Emitter.java
+++ /dev/null
@@ -1,12 +0,0 @@
-package org.lsmr.selfcheckout.devices;
-
-import org.lsmr.selfcheckout.Coin;
-
-/**
- * A simple base interface for devices that emit things.
- * 
- * @param <T>
- *            The type of the things to emit.
- */
-public interface Emitter<T> {
-}
diff --git a/src/org/lsmr/selfcheckout/devices/EmptyException.java b/src/org/lsmr/selfcheckout/devices/EmptyException.java
deleted file mode 100644
index b726903..0000000
--- a/src/org/lsmr/selfcheckout/devices/EmptyException.java
+++ /dev/null
@@ -1,9 +0,0 @@
-package org.lsmr.selfcheckout.devices;
-
-/**
- * Represents the situation when a device is emptied but an attempt is made to
- * remove something from it.
- */
-public class EmptyException extends Exception {
-	private static final long serialVersionUID = 3566954386000387724L;
-}
diff --git a/src/org/lsmr/selfcheckout/devices/FlowThroughEmitter.java b/src/org/lsmr/selfcheckout/devices/FlowThroughEmitter.java
deleted file mode 100644
index ff60458..0000000
--- a/src/org/lsmr/selfcheckout/devices/FlowThroughEmitter.java
+++ /dev/null
@@ -1,26 +0,0 @@
-package org.lsmr.selfcheckout.devices;
-
-import org.lsmr.selfcheckout.Coin;
-
-/**
- * A simple interface for devices that emit things.
- * 
- * @param <T>
- *            The type of the things to emit.
- */
-public interface FlowThroughEmitter<T> {
-	/**
-	 * Instructs the device to emit a specific thing, meaning that the device is
-	 * being handed this thing to pass onwards.
-	 * <p>
-	 * This operation is not permissible during the configuration phase.
-	 * 
-	 * @param thing
-	 *            The thing to emit.
-	 * @throws DisabledException
-	 *             If the device is disabled.
-	 * @throws OverloadException
-	 *             If the receiving device is already full.
-	 */
-	public void emit(T thing) throws DisabledException, OverloadException;
-}
diff --git a/src/org/lsmr/selfcheckout/devices/FromStorageEmitter.java b/src/org/lsmr/selfcheckout/devices/FromStorageEmitter.java
deleted file mode 100644
index ddb964a..0000000
--- a/src/org/lsmr/selfcheckout/devices/FromStorageEmitter.java
+++ /dev/null
@@ -1,26 +0,0 @@
-package org.lsmr.selfcheckout.devices;
-
-import org.lsmr.selfcheckout.Coin;
-
-/**
- * A simple interface for devices that emit things.
- * 
- * @param <T>
- *            The type of the things to emit.
- */
-public interface FromStorageEmitter<T> {
-	/**
-	 * Instructs the device to emit one thing, meaning that the device stores a set
-	 * of things and one of them is to be emitted.
-	 * <p>
-	 * This operation is not permissible during the configuration phase.
-	 * 
-	 * @throws DisabledException
-	 *             If the device is disabled.
-	 * @throws EmptyException
-	 *             If the device is empty and cannot emit.
-	 * @throws OverloadException
-	 *             If the receiving device is already full.
-	 */
-	public void emit() throws DisabledException, EmptyException, OverloadException;
-}
diff --git a/src/org/lsmr/selfcheckout/devices/SimulationException.java b/src/org/lsmr/selfcheckout/devices/SimulationException.java
deleted file mode 100644
index 7001f20..0000000
--- a/src/org/lsmr/selfcheckout/devices/SimulationException.java
+++ /dev/null
@@ -1,32 +0,0 @@
-package org.lsmr.selfcheckout.devices;
-
-/**
- * An exception that can be raised when the behaviour within the simulator makes
- * no sense, typically when it has not been configured correctly. This is
- * different from an exception being raised because the preconditions of a
- * component are violated, but that would make sense in the real world.
- */
-@SuppressWarnings("serial")
-public class SimulationException extends RuntimeException {
-	private String nested;
-
-	/**
-	 * Constructor used to nest other exceptions.
-	 * 
-	 * @param nested
-	 *            An underlying exception that is to be wrapped.
-	 */
-	public SimulationException(Exception nested) {
-		this.nested = nested.toString();
-	}
-
-	/**
-	 * Basic constructor.
-	 * 
-	 * @param message
-	 *            An explanatory message of the problem.
-	 */
-	public SimulationException(String message) {
-		nested = message;
-	}
-}
diff --git a/src/org/lsmr/selfcheckout/devices/observers/.gitignore b/src/org/lsmr/selfcheckout/devices/observers/.gitignore
deleted file mode 100644
index f538ad6..0000000
--- a/src/org/lsmr/selfcheckout/devices/observers/.gitignore
+++ /dev/null
@@ -1,10 +0,0 @@
-/AbstractDeviceObserver.class
-/BanknoteDispenserObserver.class
-/BanknoteSlotObserver.class
-/BanknoteStorageUnitObserver.class
-/BanknoteValidatorObserver.class
-/BarcodeScannerObserver.class
-/CardReaderObserver.class
-/CoinDispenserObserver.class
-/CoinSlotObserver.class
-/CoinStorageUnitObserver.class
diff --git a/src/org/lsmr/selfcheckout/devices/observers/AbstractDeviceObserver.java b/src/org/lsmr/selfcheckout/devices/observers/AbstractDeviceObserver.java
deleted file mode 100644
index ced7820..0000000
--- a/src/org/lsmr/selfcheckout/devices/observers/AbstractDeviceObserver.java
+++ /dev/null
@@ -1,26 +0,0 @@
-package org.lsmr.selfcheckout.devices.observers;
-
-import org.lsmr.selfcheckout.devices.AbstractDevice;
-
-/**
- * This class represents the abstract interface for all device observers. All
- * subclasses should add their own event notification methods, the first
- * parameter of which should always be the device affected.
- */
-public interface AbstractDeviceObserver {
-	/**
-	 * Announces that the indicated device has been enabled.
-	 * 
-	 * @param device
-	 *                 The device that has been enabled.
-	 */
-	public void enabled(AbstractDevice<? extends AbstractDeviceObserver> device);
-
-	/**
-	 * Announces that the indicated device has been disabled.
-	 * 
-	 * @param device
-	 *                 The device that has been enabled.
-	 */
-	public void disabled(AbstractDevice<? extends AbstractDeviceObserver> device);
-}
diff --git a/src/org/lsmr/selfcheckout/devices/observers/BanknoteDispenserObserver.java b/src/org/lsmr/selfcheckout/devices/observers/BanknoteDispenserObserver.java
deleted file mode 100644
index d4363bf..0000000
--- a/src/org/lsmr/selfcheckout/devices/observers/BanknoteDispenserObserver.java
+++ /dev/null
@@ -1,71 +0,0 @@
-package org.lsmr.selfcheckout.devices.observers;
-
-import org.lsmr.selfcheckout.Banknote;
-import org.lsmr.selfcheckout.devices.BanknoteDispenser;
-
-/**
- * Observes events emanating from a banknote dispenser.
- */
-public interface BanknoteDispenserObserver extends AbstractDeviceObserver {
-	/**
-	 * Announces that the indicated banknote dispenser is full of banknotes.
-	 * 
-	 * @param dispenser
-	 *            The dispenser where the event occurred.
-	 */
-	void moneyFull(BanknoteDispenser dispenser);
-
-	/**
-	 * Announces that the indicated banknote dispenser is empty of banknotes.
-	 * 
-	 * @param dispenser
-	 *            The dispenser where the event occurred.
-	 */
-	void banknotesEmpty(BanknoteDispenser dispenser);
-
-	/**
-	 * Announces that the indicated banknote has been added to the indicated
-	 * banknote dispenser.
-	 * 
-	 * @param dispenser
-	 *            The dispenser where the event occurred.
-	 * @param banknote
-	 *            The banknote that was added.
-	 */
-	void billAdded(BanknoteDispenser dispenser, Banknote banknote);
-
-	/**
-	 * Announces that the indicated banknote has been added to the indicated
-	 * banknote dispenser.
-	 * 
-	 * @param dispenser
-	 *            The dispenser where the event occurred.
-	 * @param banknote
-	 *            The banknote that was removed.
-	 */
-	void banknoteRemoved(BanknoteDispenser dispenser, Banknote banknote);
-
-	/**
-	 * Announces that the indicated sequence of banknotes has been added to the
-	 * indicated banknote dispenser. Used to simulate direct, physical loading of
-	 * the dispenser.
-	 * 
-	 * @param dispenser
-	 *            The dispenser where the event occurred.
-	 * @param banknotes
-	 *            The banknotes that were loaded.
-	 */
-	void banknotesLoaded(BanknoteDispenser dispenser, Banknote... banknotes);
-
-	/**
-	 * Announces that the indicated sequence of banknotes has been removed to the
-	 * indicated banknote dispenser. Used to simulate direct, physical unloading of
-	 * the dispenser.
-	 * 
-	 * @param dispenser
-	 *            The dispenser where the event occurred.
-	 * @param banknotes
-	 *            The banknotes that were unloaded.
-	 */
-	void banknotesUnloaded(BanknoteDispenser dispenser, Banknote... banknotes);
-}
diff --git a/src/org/lsmr/selfcheckout/devices/observers/BanknoteSlotObserver.java b/src/org/lsmr/selfcheckout/devices/observers/BanknoteSlotObserver.java
deleted file mode 100644
index 20ced82..0000000
--- a/src/org/lsmr/selfcheckout/devices/observers/BanknoteSlotObserver.java
+++ /dev/null
@@ -1,34 +0,0 @@
-package org.lsmr.selfcheckout.devices.observers;
-
-import org.lsmr.selfcheckout.Banknote;
-import org.lsmr.selfcheckout.devices.BanknoteSlot;
-
-/**
- * Observes events emanating from a banknote slot.
- */
-public interface BanknoteSlotObserver extends AbstractDeviceObserver {
-	/**
-	 * An event announcing that a banknote has been inserted.
-	 * 
-	 * @param slot
-	 *            The device on which the event occurred.
-	 */
-	void banknoteInserted(BanknoteSlot slot);
-
-	/**
-	 * An event announcing that a banknote has been returned to the user, dangling
-	 * from the slot.
-	 * 
-	 * @param slot
-	 *            The device on which the event occurred.
-	 */
-	void banknoteEjected(BanknoteSlot slot);
-
-	/**
-	 * An event announcing that a dangling banknote has been removed by the user.
-	 * 
-	 * @param slot
-	 *            The device on which the event occurred.
-	 */
-	void banknoteRemoved(BanknoteSlot slot);
-}
diff --git a/src/org/lsmr/selfcheckout/devices/observers/BanknoteStorageUnitObserver.java b/src/org/lsmr/selfcheckout/devices/observers/BanknoteStorageUnitObserver.java
deleted file mode 100644
index 9f17942..0000000
--- a/src/org/lsmr/selfcheckout/devices/observers/BanknoteStorageUnitObserver.java
+++ /dev/null
@@ -1,43 +0,0 @@
-package org.lsmr.selfcheckout.devices.observers;
-
-import org.lsmr.selfcheckout.Banknote;
-import org.lsmr.selfcheckout.devices.BanknoteStorageUnit;
-
-/**
- * Observes events emanating from a banknote storage unit.
- */
-public interface BanknoteStorageUnitObserver extends AbstractDeviceObserver {
-	/**
-	 * Announces that the indicated banknote storage unit is full of banknotes.
-	 * 
-	 * @param unit
-	 *            The storage unit where the event occurred.
-	 */
-	void banknotesFull(BanknoteStorageUnit unit);
-
-	/**
-	 * Announces that a banknote has been added to the indicated storage unit.
-	 * 
-	 * @param unit
-	 *            The storage unit where the event occurred.
-	 */
-	void banknoteAdded(BanknoteStorageUnit unit);
-
-	/**
-	 * Announces that the indicated storage unit has been loaded with banknotes.
-	 * Used to simulate direct, physical loading of the unit.
-	 * 
-	 * @param unit
-	 *            The storage unit where the event occurred.
-	 */
-	void banknotesLoaded(BanknoteStorageUnit unit);
-
-	/**
-	 * Announces that the storage unit has been emptied of banknotes. Used to
-	 * simulate direct, physical unloading of the unit.
-	 * 
-	 * @param unit
-	 *            The storage unit where the event occurred.
-	 */
-	void banknotesUnloaded(BanknoteStorageUnit unit);
-}
diff --git a/src/org/lsmr/selfcheckout/devices/observers/BanknoteValidatorObserver.java b/src/org/lsmr/selfcheckout/devices/observers/BanknoteValidatorObserver.java
deleted file mode 100644
index 583fa9d..0000000
--- a/src/org/lsmr/selfcheckout/devices/observers/BanknoteValidatorObserver.java
+++ /dev/null
@@ -1,33 +0,0 @@
-package org.lsmr.selfcheckout.devices.observers;
-
-import java.util.Currency;
-
-import org.lsmr.selfcheckout.Banknote;
-import org.lsmr.selfcheckout.devices.BanknoteValidator;
-
-/**
- * Observes events emanating from a banknote validator.
- */
-public interface BanknoteValidatorObserver extends AbstractDeviceObserver {
-	/**
-	 * An event announcing that the indicated banknote has been detected and
-	 * determined to be valid.
-	 * 
-	 * @param validator
-	 *            The device on which the event occurred.
-	 * @param currency
-	 *            The kind of currency of the inserted banknote.
-	 * @param value
-	 *            The value of the inserted banknote.
-	 */
-	void validBanknoteDetected(BanknoteValidator validator, Currency currency, int value);
-
-	/**
-	 * An event announcing that the indicated banknote has been detected and
-	 * determined to be invalid.
-	 * 
-	 * @param validator
-	 *            The device on which the event occurred.
-	 */
-	void invalidBanknoteDetected(BanknoteValidator validator);
-}
diff --git a/src/org/lsmr/selfcheckout/devices/observers/BarcodeScannerObserver.java b/src/org/lsmr/selfcheckout/devices/observers/BarcodeScannerObserver.java
deleted file mode 100644
index 5a73307..0000000
--- a/src/org/lsmr/selfcheckout/devices/observers/BarcodeScannerObserver.java
+++ /dev/null
@@ -1,20 +0,0 @@
-package org.lsmr.selfcheckout.devices.observers;
-
-import org.lsmr.selfcheckout.Barcode;
-import org.lsmr.selfcheckout.devices.BarcodeScanner;
-
-/**
- * Observes events emanating from a barcode scanner.
- */
-public interface BarcodeScannerObserver extends AbstractDeviceObserver {
-	/**
-	 * An event announcing that the indicated barcode has been successfully scanned.
-	 * 
-	 * @param barcodeScanner
-	 *            The device on which the event occurred.
-	 * @param barcode
-	 *            The barcode that was read by the scanner.
-	 */
-	void barcodeScanned(BarcodeScanner barcodeScanner, Barcode barcode);
-
-}
diff --git a/src/org/lsmr/selfcheckout/devices/observers/CardReaderObserver.java b/src/org/lsmr/selfcheckout/devices/observers/CardReaderObserver.java
deleted file mode 100644
index 9256e3a..0000000
--- a/src/org/lsmr/selfcheckout/devices/observers/CardReaderObserver.java
+++ /dev/null
@@ -1,52 +0,0 @@
-package org.lsmr.selfcheckout.devices.observers;
-
-import org.lsmr.selfcheckout.Card.CardData;
-import org.lsmr.selfcheckout.devices.CardReader;
-
-/**
- * Observes events emanating from a coin dispenser.
- */
-public interface CardReaderObserver extends AbstractDeviceObserver {
-	/**
-	 * Announces that a card has been inserted in the indicated card reader.
-	 * 
-	 * @param reader
-	 *            The reader where the event occurred.
-	 */
-	void cardInserted(CardReader reader);
-
-	/**
-	 * Announces that a card has been removed from the indicated card reader.
-	 * 
-	 * @param reader
-	 *            The reader where the event occurred.
-	 */
-	void cardRemoved(CardReader reader);
-
-	/**
-	 * Announces that a (tap-enabled) card has been tapped on the indicated card
-	 * reader.
-	 * 
-	 * @param reader
-	 *            The reader where the event occurred.
-	 */
-	void cardTapped(CardReader reader);
-
-	/**
-	 * Announces that a card has swiped on the indicated card reader.
-	 * 
-	 * @param reader
-	 *            The reader where the event occurred.
-	 */
-	void cardSwiped(CardReader reader);
-
-	/**
-	 * Announces that the data has been read from a card.
-	 * 
-	 * @param reader
-	 *            The reader where the event occurred.
-	 * @param data
-	 *            The data that was read. Note that this data may be corrupted.
-	 */
-	void cardDataRead(CardReader reader, CardData data);
-}
diff --git a/src/org/lsmr/selfcheckout/devices/observers/CoinDispenserObserver.java b/src/org/lsmr/selfcheckout/devices/observers/CoinDispenserObserver.java
deleted file mode 100644
index d388e06..0000000
--- a/src/org/lsmr/selfcheckout/devices/observers/CoinDispenserObserver.java
+++ /dev/null
@@ -1,67 +0,0 @@
-package org.lsmr.selfcheckout.devices.observers;
-
-import org.lsmr.selfcheckout.Coin;
-import org.lsmr.selfcheckout.devices.CoinDispenser;
-
-/**
- * Observes events emanating from a coin dispenser.
- */
-public interface CoinDispenserObserver extends AbstractDeviceObserver {
-	/**
-	 * Announces that the indicated coin dispenser is full of coins.
-	 * 
-	 * @param dispenser
-	 *             The dispenser where the event occurred.
-	 */
-	void coinsFull(CoinDispenser dispenser);
-
-	/**
-	 * Announces that the indicated coin dispenser is empty of coins.
-	 * 
-	 * @param dispenser
-	 *             The dispenser where the event occurred.
-	 */
-	void coinsEmpty(CoinDispenser dispenser);
-
-	/**
-	 * Announces that the indicated coin has been added to the indicated coin dispenser.
-	 * 
-	 * @param dispenser
-	 *             The dispenser where the event occurred.
-	 * @param coin
-	 *             The coin that was added.
-	 */
-	void coinAdded(CoinDispenser dispenser, Coin coin);
-
-	/**
-	 * Announces that the indicated coin has been added to the indicated coin dispenser.
-	 * 
-	 * @param dispenser
-	 *             The dispenser where the event occurred.
-	 * @param coin
-	 *             The coin that was removed.
-	 */
-	void coinRemoved(CoinDispenser dispenser, Coin coin);
-
-	/**
-	 * Announces that the indicated sequence of coins has been added to the
-	 * indicated coin dispenser. Used to simulate direct, physical loading of the dispenser.
-	 * 
-	 * @param dispenser
-	 *              The dispenser where the event occurred.
-	 * @param coins
-	 *              The coins that were loaded.
-	 */
-	void coinsLoaded(CoinDispenser dispenser, Coin... coins);
-
-	/**
-	 * Announces that the indicated sequence of coins has been removed to the
-	 * indicated coin dispenser. Used to simulate direct, physical unloading of the dispenser.
-	 * 
-	 * @param dispenser
-	 *              The dispenser where the event occurred.
-	 * @param coins
-	 *              The coins that were unloaded.
-	 */
-	void coinsUnloaded(CoinDispenser dispenser, Coin... coins);
-}
diff --git a/src/org/lsmr/selfcheckout/devices/observers/CoinSlotObserver.java b/src/org/lsmr/selfcheckout/devices/observers/CoinSlotObserver.java
deleted file mode 100644
index a091cb2..0000000
--- a/src/org/lsmr/selfcheckout/devices/observers/CoinSlotObserver.java
+++ /dev/null
@@ -1,17 +0,0 @@
-package org.lsmr.selfcheckout.devices.observers;
-
-import org.lsmr.selfcheckout.Coin;
-import org.lsmr.selfcheckout.devices.CoinSlot;
-
-/**
- * Observes events emanating from a coin slot.
- */
-public interface CoinSlotObserver extends AbstractDeviceObserver {
-	/**
-	 * An event announcing that a coin has been inserted.
-	 * 
-	 * @param slot
-	 *             The device on which the event occurred.
-	 */
-	void coinInserted(CoinSlot slot);
-}
diff --git a/src/org/lsmr/selfcheckout/devices/observers/CoinStorageUnitObserver.java b/src/org/lsmr/selfcheckout/devices/observers/CoinStorageUnitObserver.java
deleted file mode 100644
index 6049c36..0000000
--- a/src/org/lsmr/selfcheckout/devices/observers/CoinStorageUnitObserver.java
+++ /dev/null
@@ -1,43 +0,0 @@
-package org.lsmr.selfcheckout.devices.observers;
-
-import org.lsmr.selfcheckout.Coin;
-import org.lsmr.selfcheckout.devices.CoinStorageUnit;
-
-/**
- * Observes events emanating from a coin storage unit.
- */
-public interface CoinStorageUnitObserver extends AbstractDeviceObserver {
-	/**
-	 * Announces that the indicated coin storage unit is full of coins.
-	 * 
-	 * @param unit
-	 *            The storage unit where the event occurred.
-	 */
-	void coinsFull(CoinStorageUnit unit);
-
-	/**
-	 * Announces that a coin has been added to the indicated storage unit.
-	 * 
-	 * @param unit
-	 *            The storage unit where the event occurred.
-	 */
-	void coinAdded(CoinStorageUnit unit);
-
-	/**
-	 * Announces that the indicated storage unit has been loaded with coins.
-	 * Used to simulate direct, physical loading of the unit.
-	 * 
-	 * @param unit
-	 *            The storage unit where the event occurred.
-	 */
-	void coinsLoaded(CoinStorageUnit unit);
-
-	/**
-	 * Announces that the storage unit has been emptied of coins. Used to
-	 * simulate direct, physical unloading of the unit.
-	 * 
-	 * @param unit
-	 *            The storage unit where the event occurred.
-	 */
-	void coinsUnloaded(CoinStorageUnit unit);
-}
diff --git a/src/org/lsmr/selfcheckout/tests/.gitignore b/src/org/lsmr/selfcheckout/tests/.gitignore
deleted file mode 100644
index 7ba8755..0000000
--- a/src/org/lsmr/selfcheckout/tests/.gitignore
+++ /dev/null
@@ -1,5 +0,0 @@
-/test_wish_to_checkout.class
-/AbstractDeviceObserverStub.class
-/ElectronicScaleObserverStub.class
-/test_wish_to_checkout$1.class
-/test_wish_to_checkout$2.class
diff --git a/src/org/lsmr/selfcheckout/tests/AbstractDeviceObserverStub.java b/src/org/lsmr/selfcheckout/tests/AbstractDeviceObserverStub.java
deleted file mode 100644
index d888524..0000000
--- a/src/org/lsmr/selfcheckout/tests/AbstractDeviceObserverStub.java
+++ /dev/null
@@ -1,19 +0,0 @@
-package org.lsmr.selfcheckout.tests;
-
-import org.lsmr.selfcheckout.devices.AbstractDevice;
-import org.lsmr.selfcheckout.devices.observers.AbstractDeviceObserver;
-
-public class AbstractDeviceObserverStub implements AbstractDeviceObserver {
-
-	@Override
-	public void enabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
-		device.disable();	
-	}
-
-	@Override
-	public void disabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
-		// TODO Auto-generated method stub
-		
-	}
-
-}
diff --git a/src/org/lsmr/selfcheckout/tests/ElectronicScaleObserverStub.java b/src/org/lsmr/selfcheckout/tests/ElectronicScaleObserverStub.java
deleted file mode 100644
index a548bbd..0000000
--- a/src/org/lsmr/selfcheckout/tests/ElectronicScaleObserverStub.java
+++ /dev/null
@@ -1,40 +0,0 @@
-package org.lsmr.selfcheckout.tests;
-
-import org.lsmr.selfcheckout.devices.AbstractDevice;
-import org.lsmr.selfcheckout.devices.ElectronicScale;
-import org.lsmr.selfcheckout.devices.observers.AbstractDeviceObserver;
-import org.lsmr.selfcheckout.devices.observers.ElectronicScaleObserver;
-
-public class ElectronicScaleObserverStub implements ElectronicScaleObserver {
-
-	@Override
-	public void enabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
-		// TODO Auto-generated method stub
-		
-	}
-
-	@Override
-	public void disabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
-		// TODO Auto-generated method stub
-		
-	}
-
-	@Override
-	public void weightChanged(ElectronicScale scale, double weightInGrams) {
-		scale.disable();
-		
-	}
-
-	@Override
-	public void overload(ElectronicScale scale) {
-		// TODO Auto-generated method stub
-		
-	}
-
-	@Override
-	public void outOfOverload(ElectronicScale scale) {
-		// TODO Auto-generated method stub
-		
-	}
-
-}
diff --git a/src/org/lsmr/selfcheckout/tests/test_wish_to_checkout.java b/src/org/lsmr/selfcheckout/tests/test_wish_to_checkout.java
deleted file mode 100644
index 43cef01..0000000
--- a/src/org/lsmr/selfcheckout/tests/test_wish_to_checkout.java
+++ /dev/null
@@ -1,69 +0,0 @@
-package org.lsmr.selfcheckout.tests;
-
-import static org.junit.Assert.*;
-
-import org.junit.Before;
-import org.junit.Test;
-import org.lsmr.selfcheckout.Item;
-import org.lsmr.selfcheckout.SCSLogic;
-import org.lsmr.selfcheckout.devices.AbstractDevice;
-import org.lsmr.selfcheckout.devices.DisabledException;
-import org.lsmr.selfcheckout.devices.ElectronicScale;
-import org.lsmr.selfcheckout.devices.OverloadException;
-import org.lsmr.selfcheckout.devices.SimulationException;
-import org.lsmr.selfcheckout.devices.observers.AbstractDeviceObserver;
-
-import junit.extensions.TestSetup;
-import junit.framework.Assert;
-
-public class test_wish_to_checkout {
-
-	private SCSLogic test_object;
-	private AbstractDeviceObserverStub payment;
-	private ElectronicScaleObserverStub w_observer;
-	private ElectronicScale E;
-	
-	@Before
-	public void TestSetup() {
-		this.E = new ElectronicScale(100, 1);
-		this.test_object = new SCSLogic(E);
-		this.payment = new AbstractDeviceObserverStub();
-		this.w_observer = new ElectronicScaleObserverStub();
-		
-	}
-	
-	@Test(expected = SimulationException.class)
-	public void test_attachment() throws OverloadException, DisabledException {
-		test_object.wish_checkout(payment);
-		test_object.detach(payment);
-		test_object.detach(payment);
-	}
-	
-	@Test(expected = SimulationException.class)
-	public void test_weight_changed() throws OverloadException, DisabledException {
-		E.attach(w_observer);
-		Item test_item1 = new Item(20) {};
-		Item test_item2 = new Item(40) {};
-		E.add(test_item1);
-		E.enable();
-		
-		E.add(test_item2);
-		
-		test_object.wish_checkout(payment);
-		
-	}
-	
-	@Test
-	public void test_normal_wish() throws OverloadException, DisabledException {
-		test_object.endConfigurationPhase();
-		E.attach(w_observer);
-		E.endConfigurationPhase();
-		E.enable();
-		test_object.wish_checkout(payment);
-		assertTrue("this should be true",test_object.isDisabled());
-		
-		
-	}
-	
-
-}

commit a7a89b3b72ebd9f27c5af21db2abadc6903011f8
Author: kev9268 <99704077+kev9268@users.noreply.github.com>
Date:   Fri Mar 18 18:06:12 2022 -0600

    Rename README.md to README.txt

diff --git a/README.md b/README.txt
similarity index 100%
rename from README.md
rename to README.txt

commit 02a209ba1bcfe897b533338cecf2d62d767fefe3
Author: kev9268 <99704077+kev9268@users.noreply.github.com>
Date:   Fri Mar 18 18:06:01 2022 -0600

    Create README.md

diff --git a/README.md b/README.md
new file mode 100644
index 0000000..3c74dda
--- /dev/null
+++ b/README.md
@@ -0,0 +1,28 @@
+Requirements:
+1.Customer scans an item -(James, Bassel)
+  -Takes in barcode of item
+  -Gathers items information (Price,weight,etc)
+  -Adds cost of item to currect cost
+2.Customer places item in bagging area (Kevin)
+  -Checks for weight of item
+  -Get current weight for electronic scale
+  -Expect new weight on the electronic scale to be the addition of the weight of newly scanned item
+3.Customer wishes to checkout (zhongmin)
+  -keep looping and checking the weight
+  -check how the customer willing to pay (e.g. button pressed)
+4.Customer pays with a coin (Justin)
+  -Coin slot observer to check if slot is open
+  -Observe what coin inserted
+  -Add ammount of money based on what coin was inserted
+  -Check if cost is reached everytime coin is inserted
+5.Customer pays with a banknote - (Manbir)
+  -Banknote slot observer to check if slot is open
+  -Observe what banknote inserted
+  -Add ammount of money based on what banknote was inserted
+  -Check if cost is reached everytime banknote is inserted
+
+TestCases:
+-Each person who works on the software control also works on the test cases.
+-Check your partner's test cases (2 and 4 check each other's test case, and 3 and 5 check each other's test cases)
+-If you think your partner is missing a test case for their task, you can message them to tell them what they should add (you can also add it yourself but that might get messy so it's best to check)
+-1 will be 2 people, who will both work on the test cases and version control.

commit c2b6530d73930431cbebe7021a5ec4071d23f106
Author: lexahoa <60637851+lexahoa@users.noreply.github.com>
Date:   Fri Mar 18 20:03:19 2022 -0400

    Add files via upload

diff --git a/README.txt b/README.txt
new file mode 100644
index 0000000..a0c9153
--- /dev/null
+++ b/README.txt
@@ -0,0 +1,28 @@
+Requirements:
+1.Customer scans an item -(James, Bassel)
+  -Takes in barcode of item
+  -Gathers items information (Price,weight,etc)
+  -Adds cost of item to currect cost
+2.Customer places item in bagging area (Kevin)
+  -Checks for weight of item
+  -Get current weight for electronic scale
+  -Expect new weight on the electronic scale to be the addition of the weight of newly scanned item
+3.Customer wishes to checkout (zhongmin)
+  -keep looping and checking the weight
+  -check how the customer willing to pay (e.g. button pressed)
+4.Customer pays with a coin (Justin)
+  -Coin slot observer to check if slot is open
+  -Observe what coin inserted
+  -Add ammount of money based on what coin was inserted
+  -Check if cost is reached everytime coin is inserted
+5.Customer pays with a banknote - (Manbir)
+  -Banknote slot observer to check if slot is open
+  -Observe what banknote inserted
+  -Add ammount of money based on what banknote was inserted
+  -Check if cost is reached everytime banknote is inserted
+
+TestCases:
+-Each person who works on the software control also works on the test cases.
+-Check your partner's test cases (2 and 4 check each other's test case, and 3 and 5 check each other's test cases)
+-If you think your partner is missing a test case for their task, you can message them to tell them what they should add (you can also add it yourself but that might get messy so it's best to check)
+-1 will be 2 people, who will both work on the test cases and version control.

commit a8279415c176848761734800875ed2993c22317c
Author: Manbir Sandhu <mana24129@hotmail.com>
Date:   Fri Mar 18 18:00:45 2022 -0600

    Attached banknoteController to bankNoteStorage

diff --git a/bin/BanknoteController.class b/bin/BanknoteController.class
index 7ff8015..6c0aa0b 100644
Binary files a/bin/BanknoteController.class and b/bin/BanknoteController.class differ
diff --git a/src/BanknoteController.java b/src/BanknoteController.java
index 7c00f37..a663689 100644
--- a/src/BanknoteController.java
+++ b/src/BanknoteController.java
@@ -17,6 +17,7 @@ public class BanknoteController implements BanknoteValidatorObserver, BanknoteSt
 	
 	public BanknoteController(SelfCheckoutStation s) {
 		s.banknoteValidator.attach(this);
+		s.banknoteStorage.attach(this);
 		availableFunds = 0;
 	}
 

commit 19ed93feb6633cb31bcbff536caa6fa2d9f72d55
Author: Manbir Sandhu <mana24129@hotmail.com>
Date:   Fri Mar 18 17:52:13 2022 -0600

    project setup

diff --git a/.classpath b/.classpath
new file mode 100644
index 0000000..8cf4aa1
--- /dev/null
+++ b/.classpath
@@ -0,0 +1,11 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<classpath>
+	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/JavaSE-17">
+		<attributes>
+			<attribute name="module" value="true"/>
+		</attributes>
+	</classpathentry>
+	<classpathentry kind="src" path="src"/>
+	<classpathentry kind="src" path="SCS - Hardware - v1.0/src"/>
+	<classpathentry kind="output" path="bin"/>
+</classpath>
diff --git a/.project b/.project
new file mode 100644
index 0000000..711bba8
--- /dev/null
+++ b/.project
@@ -0,0 +1,17 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>SCS - Software</name>
+	<comment></comment>
+	<projects>
+	</projects>
+	<buildSpec>
+		<buildCommand>
+			<name>org.eclipse.jdt.core.javabuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+	</buildSpec>
+	<natures>
+		<nature>org.eclipse.jdt.core.javanature</nature>
+	</natures>
+</projectDescription>
diff --git a/.settings/org.eclipse.jdt.core.prefs b/.settings/org.eclipse.jdt.core.prefs
new file mode 100644
index 0000000..8c9943d
--- /dev/null
+++ b/.settings/org.eclipse.jdt.core.prefs
@@ -0,0 +1,14 @@
+eclipse.preferences.version=1
+org.eclipse.jdt.core.compiler.codegen.inlineJsrBytecode=enabled
+org.eclipse.jdt.core.compiler.codegen.targetPlatform=17
+org.eclipse.jdt.core.compiler.codegen.unusedLocal=preserve
+org.eclipse.jdt.core.compiler.compliance=17
+org.eclipse.jdt.core.compiler.debug.lineNumber=generate
+org.eclipse.jdt.core.compiler.debug.localVariable=generate
+org.eclipse.jdt.core.compiler.debug.sourceFile=generate
+org.eclipse.jdt.core.compiler.problem.assertIdentifier=error
+org.eclipse.jdt.core.compiler.problem.enablePreviewFeatures=disabled
+org.eclipse.jdt.core.compiler.problem.enumIdentifier=error
+org.eclipse.jdt.core.compiler.problem.reportPreviewFeatures=warning
+org.eclipse.jdt.core.compiler.release=enabled
+org.eclipse.jdt.core.compiler.source=17
diff --git a/SCS - Hardware - v1.0/.classpath b/SCS - Hardware - v1.0/.classpath
new file mode 100644
index 0000000..6a189c4
--- /dev/null
+++ b/SCS - Hardware - v1.0/.classpath	
@@ -0,0 +1,7 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<classpath>
+	<classpathentry kind="src" path="src"/>
+	<classpathentry kind="con" path="org.eclipse.jdt.junit.JUNIT_CONTAINER/4"/>
+	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER"/>
+	<classpathentry kind="output" path="bin"/>
+</classpath>
diff --git a/SCS - Hardware - v1.0/.project b/SCS - Hardware - v1.0/.project
new file mode 100644
index 0000000..57573c6
--- /dev/null
+++ b/SCS - Hardware - v1.0/.project	
@@ -0,0 +1,17 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>SCS - Hardware - v1.0</name>
+	<comment></comment>
+	<projects>
+	</projects>
+	<buildSpec>
+		<buildCommand>
+			<name>org.eclipse.jdt.core.javabuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+	</buildSpec>
+	<natures>
+		<nature>org.eclipse.jdt.core.javanature</nature>
+	</natures>
+</projectDescription>
diff --git a/SCS - Hardware - v1.0/.settings/org.eclipse.jdt.core.prefs b/SCS - Hardware - v1.0/.settings/org.eclipse.jdt.core.prefs
new file mode 100644
index 0000000..bb35fa0
--- /dev/null
+++ b/SCS - Hardware - v1.0/.settings/org.eclipse.jdt.core.prefs	
@@ -0,0 +1,11 @@
+eclipse.preferences.version=1
+org.eclipse.jdt.core.compiler.codegen.inlineJsrBytecode=enabled
+org.eclipse.jdt.core.compiler.codegen.targetPlatform=1.8
+org.eclipse.jdt.core.compiler.codegen.unusedLocal=preserve
+org.eclipse.jdt.core.compiler.compliance=1.8
+org.eclipse.jdt.core.compiler.debug.lineNumber=generate
+org.eclipse.jdt.core.compiler.debug.localVariable=generate
+org.eclipse.jdt.core.compiler.debug.sourceFile=generate
+org.eclipse.jdt.core.compiler.problem.assertIdentifier=error
+org.eclipse.jdt.core.compiler.problem.enumIdentifier=error
+org.eclipse.jdt.core.compiler.source=1.8
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Banknote.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Banknote.class
new file mode 100644
index 0000000..fbc21cf
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Banknote.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Barcode.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Barcode.class
new file mode 100644
index 0000000..5cea197
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Barcode.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/BarcodedItem.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/BarcodedItem.class
new file mode 100644
index 0000000..2d68447
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/BarcodedItem.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/BlockedCardException.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/BlockedCardException.class
new file mode 100644
index 0000000..536dd3d
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/BlockedCardException.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Card$CardData.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Card$CardData.class
new file mode 100644
index 0000000..795e5b4
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Card$CardData.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Card$CardInsertData.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Card$CardInsertData.class
new file mode 100644
index 0000000..a2d7141
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Card$CardInsertData.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Card$CardSwipeData.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Card$CardSwipeData.class
new file mode 100644
index 0000000..a72d8a2
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Card$CardSwipeData.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Card$CardTapData.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Card$CardTapData.class
new file mode 100644
index 0000000..8efccff
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Card$CardTapData.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Card.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Card.class
new file mode 100644
index 0000000..262b944
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Card.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/ChipFailureException.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/ChipFailureException.class
new file mode 100644
index 0000000..fa389c2
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/ChipFailureException.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Coin.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Coin.class
new file mode 100644
index 0000000..67690f1
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Coin.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/IllegalDigitException.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/IllegalDigitException.class
new file mode 100644
index 0000000..be8be69
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/IllegalDigitException.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/InvalidPINException.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/InvalidPINException.class
new file mode 100644
index 0000000..c08cda6
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/InvalidPINException.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Item.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Item.class
new file mode 100644
index 0000000..69e38c1
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Item.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/MagneticStripeFailureException.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/MagneticStripeFailureException.class
new file mode 100644
index 0000000..0f8b1e6
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/MagneticStripeFailureException.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Numeral.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Numeral.class
new file mode 100644
index 0000000..ac8cc6e
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Numeral.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/PLUCodedItem.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/PLUCodedItem.class
new file mode 100644
index 0000000..941940c
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/PLUCodedItem.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/PriceLookupCode.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/PriceLookupCode.class
new file mode 100644
index 0000000..0884227
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/PriceLookupCode.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/TapFailureException.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/TapFailureException.class
new file mode 100644
index 0000000..8d9b145
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/TapFailureException.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/AbstractDevice$Phase.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/AbstractDevice$Phase.class
new file mode 100644
index 0000000..1dae3ed
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/AbstractDevice$Phase.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/AbstractDevice.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/AbstractDevice.class
new file mode 100644
index 0000000..aff6c5e
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/AbstractDevice.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/Acceptor.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/Acceptor.class
new file mode 100644
index 0000000..9043506
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/Acceptor.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/BanknoteDispenser.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/BanknoteDispenser.class
new file mode 100644
index 0000000..a829b5d
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/BanknoteDispenser.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/BanknoteSlot.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/BanknoteSlot.class
new file mode 100644
index 0000000..f18b4a4
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/BanknoteSlot.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/BanknoteStorageUnit.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/BanknoteStorageUnit.class
new file mode 100644
index 0000000..21d4eff
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/BanknoteStorageUnit.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/BanknoteValidator.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/BanknoteValidator.class
new file mode 100644
index 0000000..a42c54f
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/BanknoteValidator.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/BarcodeScanner.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/BarcodeScanner.class
new file mode 100644
index 0000000..093246f
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/BarcodeScanner.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/BidirectionalChannel.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/BidirectionalChannel.class
new file mode 100644
index 0000000..8ae0603
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/BidirectionalChannel.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/CardReader.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/CardReader.class
new file mode 100644
index 0000000..1a090b0
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/CardReader.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/CoinDispenser.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/CoinDispenser.class
new file mode 100644
index 0000000..d069691
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/CoinDispenser.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/CoinSlot.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/CoinSlot.class
new file mode 100644
index 0000000..db8f809
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/CoinSlot.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/CoinStorageUnit.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/CoinStorageUnit.class
new file mode 100644
index 0000000..db1e2c4
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/CoinStorageUnit.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/CoinTray.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/CoinTray.class
new file mode 100644
index 0000000..6f49c78
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/CoinTray.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/CoinValidator.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/CoinValidator.class
new file mode 100644
index 0000000..de514e7
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/CoinValidator.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/DisabledException.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/DisabledException.class
new file mode 100644
index 0000000..5c66261
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/DisabledException.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/ElectronicScale.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/ElectronicScale.class
new file mode 100644
index 0000000..a9314d0
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/ElectronicScale.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/Emitter.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/Emitter.class
new file mode 100644
index 0000000..b23e858
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/Emitter.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/EmptyException.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/EmptyException.class
new file mode 100644
index 0000000..dc98a0f
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/EmptyException.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/FlowThroughEmitter.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/FlowThroughEmitter.class
new file mode 100644
index 0000000..7db53cc
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/FlowThroughEmitter.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/FromStorageEmitter.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/FromStorageEmitter.class
new file mode 100644
index 0000000..bc15cfc
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/FromStorageEmitter.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/OverloadException.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/OverloadException.class
new file mode 100644
index 0000000..ce0e2cd
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/OverloadException.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/ReceiptPrinter.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/ReceiptPrinter.class
new file mode 100644
index 0000000..4db506b
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/ReceiptPrinter.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/SelfCheckoutStation.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/SelfCheckoutStation.class
new file mode 100644
index 0000000..4c8882f
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/SelfCheckoutStation.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/SimulationException.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/SimulationException.class
new file mode 100644
index 0000000..d616ae5
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/SimulationException.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/UnidirectionalChannel.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/UnidirectionalChannel.class
new file mode 100644
index 0000000..964485e
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/UnidirectionalChannel.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/AbstractDeviceObserver.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/AbstractDeviceObserver.class
new file mode 100644
index 0000000..3b3f3af
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/AbstractDeviceObserver.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/BanknoteDispenserObserver.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/BanknoteDispenserObserver.class
new file mode 100644
index 0000000..ef277e1
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/BanknoteDispenserObserver.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/BanknoteSlotObserver.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/BanknoteSlotObserver.class
new file mode 100644
index 0000000..8fa6c54
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/BanknoteSlotObserver.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/BanknoteStorageUnitObserver.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/BanknoteStorageUnitObserver.class
new file mode 100644
index 0000000..dbec2ad
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/BanknoteStorageUnitObserver.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/BanknoteValidatorObserver.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/BanknoteValidatorObserver.class
new file mode 100644
index 0000000..b779d7e
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/BanknoteValidatorObserver.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/BarcodeScannerObserver.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/BarcodeScannerObserver.class
new file mode 100644
index 0000000..3ef8e5f
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/BarcodeScannerObserver.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/CardReaderObserver.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/CardReaderObserver.class
new file mode 100644
index 0000000..21606de
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/CardReaderObserver.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/CoinDispenserObserver.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/CoinDispenserObserver.class
new file mode 100644
index 0000000..7910341
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/CoinDispenserObserver.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/CoinSlotObserver.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/CoinSlotObserver.class
new file mode 100644
index 0000000..bd71242
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/CoinSlotObserver.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/CoinStorageUnitObserver.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/CoinStorageUnitObserver.class
new file mode 100644
index 0000000..b922285
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/CoinStorageUnitObserver.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/CoinTrayObserver.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/CoinTrayObserver.class
new file mode 100644
index 0000000..1391af5
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/CoinTrayObserver.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/CoinValidatorObserver.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/CoinValidatorObserver.class
new file mode 100644
index 0000000..b11003b
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/CoinValidatorObserver.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/ElectronicScaleObserver.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/ElectronicScaleObserver.class
new file mode 100644
index 0000000..6bf0d70
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/ElectronicScaleObserver.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/ReceiptPrinterObserver.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/ReceiptPrinterObserver.class
new file mode 100644
index 0000000..9cd53cf
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/ReceiptPrinterObserver.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/TouchScreenObserver.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/TouchScreenObserver.class
new file mode 100644
index 0000000..ef726bb
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/TouchScreenObserver.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/products/BarcodedProduct.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/products/BarcodedProduct.class
new file mode 100644
index 0000000..aba29ee
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/products/BarcodedProduct.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/products/PLUCodedProduct.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/products/PLUCodedProduct.class
new file mode 100644
index 0000000..80746e5
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/products/PLUCodedProduct.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/products/Product.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/products/Product.class
new file mode 100644
index 0000000..b3888c1
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/products/Product.class differ
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/Banknote.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/Banknote.java
new file mode 100644
index 0000000..ad0981e
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/Banknote.java	
@@ -0,0 +1,66 @@
+package org.lsmr.selfcheckout;
+
+import java.math.BigDecimal;
+import java.util.Currency;
+
+import org.lsmr.selfcheckout.devices.SimulationException;
+
+/**
+ * Instances of this class represent individual banknotes. The value of a
+ * banknote is assumed to always be a positive integer multiple of the base
+ * currency.
+ */
+public class Banknote {
+	private int value;
+	private Currency currency;
+
+	/**
+	 * Constructs a banknote.
+	 * @param currency
+	 *            The currency represented by this banknote.
+	 * @param value
+	 *            The value of the banknote, in multiples of the unit of currency.
+	 * 
+	 * @throws SimulationException
+	 *             If the value is &le;0.
+	 * @throws SimulationException
+	 *             If currency is null.
+	 */
+	public Banknote(Currency currency, int value) {
+		if(currency == null)
+			throw new SimulationException(new NullPointerException("currency is null"));
+
+		if(value <= 0)
+			throw new SimulationException(
+				new IllegalArgumentException("The value must be greater than 0: the argument passed was " + value));
+
+		this.value = value;
+		this.currency = currency;
+	}
+
+	/**
+	 * Accessor for the value.
+	 * 
+	 * @return The value of the banknote. Should always be &gt;0.
+	 */
+	public int getValue() {
+		return value;
+	}
+
+	/**
+	 * Accessor for the currency.
+	 * 
+	 * @return The currency for this banknote. Note that this is not the same as the
+	 *             "denomination" (e.g., a Canadian $10 bill is worth 10 Canadian
+	 *             dollars, so a Canadian $10 bill would have currency "Canadian
+	 *             dollars").
+	 */
+	public Currency getCurrency() {
+		return currency;
+	}
+
+	@Override
+	public String toString() {
+		return Integer.toString(value) + " " + currency;
+	}
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/Barcode.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/Barcode.java
new file mode 100644
index 0000000..b989b61
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/Barcode.java	
@@ -0,0 +1,109 @@
+package org.lsmr.selfcheckout;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+
+import org.lsmr.selfcheckout.devices.SimulationException;
+
+/**
+ * Represents a barcode value (not the graphic barcode itself). Real-world
+ * barcodes are a sequence of digits, so that is what is modelled here.
+ */
+public class Barcode {
+	private Numeral[] digits;
+
+	/**
+	 * Constructs a barcode from an array of numerals.
+	 * 
+	 * @param code
+	 *            An array of numerals.
+	 * @throws SimulationException
+	 *             If any character in the input is not a digit between 0 and 9,
+	 *             inclusive.
+	 * @throws SimulationException
+	 *             If the code is null
+	 * @throws SimulationException
+	 *             If the code's length is &lt;1 or &gt;48.
+	 */
+	public Barcode(Numeral[] code) {
+		if(code == null)
+			throw new SimulationException(new NullPointerException("code is null"));
+
+		digits = new Numeral[code.length];
+
+		if(code.length < 1)
+			throw new SimulationException(
+				new IllegalArgumentException("A barcode cannot contain less than one digit."));
+
+		if(code.length > 48)
+			throw new SimulationException(
+				new IllegalArgumentException("A barcode cannot contain more than forty-eight digits."));
+
+		for(int i = 0; i < code.length; i++) {
+			if(code[i] == null)
+				throw new SimulationException(new NullPointerException("code[" + i + "] is null"));
+
+			digits[i] = code[i];
+		}
+	}
+
+	/**
+	 * Gets the count of digits in this code.
+	 * 
+	 * @return The count of digits.
+	 */
+	public int digitCount() {
+		return digits.length;
+	}
+
+	/**
+	 * Gets the digit at the indicated index within the code.
+	 * 
+	 * @param index
+	 *            The index of the digit, &ge;0 and &lt;count.
+	 * @return The digit at the indicated index.
+	 * @throws SimulationException
+	 *             If the index is outside the legal range.
+	 */
+	public Numeral getDigitAt(int index) {
+		try {
+			return digits[index];
+		}
+		catch(IndexOutOfBoundsException e) {
+			throw new SimulationException(e);
+		}
+	}
+
+	@Override
+	public String toString() {
+		char[] characters = new char[digits.length];
+
+		for(int i = 0; i < digits.length; i++)
+			characters[i] = Character.forDigit(digits[i].getValue(), 10);
+
+		return new String(characters);
+	}
+
+	@Override
+	public boolean equals(Object object) {
+		if(object instanceof Barcode) {
+			Barcode other = (Barcode)object;
+
+			if(other.digits.length != digits.length)
+				return false;
+
+			for(int i = 0; i < digits.length; i++)
+				if(!digits[i].equals(other.digits[i]))
+					return false;
+
+			return true;
+		}
+
+		return false;
+	}
+
+	@Override
+	public int hashCode() {
+		return Arrays.hashCode(digits);
+	}
+}
\ No newline at end of file
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/BarcodedItem.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/BarcodedItem.java
new file mode 100644
index 0000000..cc57193
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/BarcodedItem.java	
@@ -0,0 +1,41 @@
+package org.lsmr.selfcheckout;
+
+import org.lsmr.selfcheckout.devices.SimulationException;
+import org.lsmr.selfcheckout.products.Product;
+
+/**
+ * Represents items for sale, each with a particular barcode and weight.
+ */
+public class BarcodedItem extends Item {
+	private Barcode barcode;
+
+	/**
+	 * Basic constructor.
+	 * 
+	 * @param kind
+	 *            The kind of product that this item is.
+	 * @param weightInGrams
+	 *            The real weight of the item.
+	 * @throws SimulationException
+	 *             If the barcode is null.
+	 * @throws SimulationException
+	 *             If the weight is &le;0.
+	 */
+	public BarcodedItem(Barcode barcode, double weightInGrams) {
+		super(weightInGrams);
+
+		if(barcode == null)
+			throw new SimulationException(new NullPointerException("barcode is null"));
+
+		this.barcode = barcode;
+	}
+
+	/**
+	 * Gets the barcode of this item.
+	 * 
+	 * @return The barcode.
+	 */
+	public Barcode getBarcode() {
+		return barcode;
+	}
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/BlockedCardException.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/BlockedCardException.java
new file mode 100644
index 0000000..63b13ba
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/BlockedCardException.java	
@@ -0,0 +1,15 @@
+package org.lsmr.selfcheckout;
+
+import java.io.IOException;
+
+/**
+ * Represents exceptions arising from a blocked card.
+ */
+public class BlockedCardException extends IOException {
+	private static final long serialVersionUID = 8824192400137175094L;
+
+	/**
+	 * Create an exception.
+	 */
+	public BlockedCardException() {}
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/Card.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/Card.java
new file mode 100644
index 0000000..e3f6fb9
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/Card.java	
@@ -0,0 +1,289 @@
+package org.lsmr.selfcheckout;
+
+import java.io.IOException;
+import java.util.Random;
+import java.util.concurrent.ThreadLocalRandom;
+
+import org.lsmr.selfcheckout.devices.SimulationException;
+
+/**
+ * Represents plastic cards (e.g., credit cards, debit cards, membership cards).
+ */
+public final class Card {
+	private final String type;
+	private final String number;
+	private final String cardholder;
+	private final String cvv;
+	private final String pin;
+	public final boolean isTapEnabled;
+	public final boolean hasChip;
+	private int failedTrials = 0;
+	private boolean isBlocked;
+
+	/**
+	 * Create a card instance.
+	 * 
+	 * @param type
+	 *            The type of the card.
+	 * @param number
+	 *            The number of the card. This has to be a string of digits.
+	 * @param cardholder
+	 *            The name of the cardholder.
+	 * @param cvv
+	 *            The card verification value (CVV), a 3- or 4-digit value often on
+	 *            the back of the card. This can be null.
+	 * @param pin
+	 *            The personal identification number (PIN) for access to the card.
+	 *            This can be null if the card has no chip.
+	 * @param isTapEnabled
+	 *            Whether this card is capable of being tapped.
+	 * @param hasChip
+	 *            Whether this card has a chip.
+	 * @throws SimulationException
+	 *             If type, number, or cardholder is null.
+	 * @throws SimulationException
+	 *             If hasChip is true but pin is null.
+	 */
+	public Card(String type, String number, String cardholder, String cvv, String pin, boolean isTapEnabled,
+		boolean hasChip) {
+		if(type == null)
+			throw new SimulationException(new NullPointerException("type is null"));
+
+		if(number == null)
+			throw new SimulationException(new NullPointerException("number is null"));
+
+		if(cardholder == null)
+			throw new SimulationException(new NullPointerException("cardholder is null"));
+
+		if(hasChip && pin == null)
+			throw new SimulationException(new NullPointerException("has chip but pin is null"));
+
+		this.type = type;
+		this.number = number;
+		this.cardholder = cardholder;
+		this.cvv = cvv;
+		this.pin = pin;
+		this.isTapEnabled = isTapEnabled;
+		this.hasChip = hasChip;
+	}
+
+	private static final Random random = new Random(0);
+	private static final double PROBABILITY_OF_MAGNETIC_STRIPE_FAILURE = 0.01;
+	private static final double PROBABILITY_OF_TAP_FAILURE = 0.005;
+	private static final double PROBABILITY_OF_INSERT_FAILURE = 0.001;
+	private static final double PROBABILITY_OF_MAGNETIC_STRIPE_CORRUPTION = 0.001;
+	private static final double PROBABILITY_OF_CHIP_CORRUPTION = 0.00001;
+
+	/**
+	 * Simulates the action of swiping the card.
+	 * 
+	 * @return The card data.
+	 * @throws IOException
+	 *             If anything went wrong with the data transfer.
+	 */
+	public final CardSwipeData swipe() throws IOException {
+		if(isBlocked)
+			throw new BlockedCardException();
+
+		if(random.nextDouble() <= PROBABILITY_OF_MAGNETIC_STRIPE_FAILURE)
+			throw new MagneticStripeFailureException();
+
+		return new CardSwipeData();
+	}
+
+	/**
+	 * Simulates the action of tapping the card.
+	 * 
+	 * @return The card data.
+	 * @throws IOException
+	 *             If anything went wrong with the data transfer.
+	 */
+	public final CardTapData tap() throws IOException {
+		if(isBlocked)
+			throw new BlockedCardException();
+
+		if(isTapEnabled) {
+			if(random.nextDouble() <= PROBABILITY_OF_TAP_FAILURE)
+				throw new TapFailureException();
+
+			return new CardTapData();
+		}
+
+		return null;
+	}
+
+	/**
+	 * Simulates the action of inserting the card.
+	 * 
+	 * @return The card data.
+	 * @throws IOException
+	 *             If anything went wrong with the data transfer.
+	 */
+	public final CardInsertData insert(String pin) throws IOException {
+		if(isBlocked)
+			throw new BlockedCardException();
+
+		if(hasChip) {
+			if(random.nextDouble() <= PROBABILITY_OF_INSERT_FAILURE)
+				throw new ChipFailureException();
+
+			return new CardInsertData(pin);
+		}
+
+		return null;
+	}
+
+	private String randomize(String original, double probability) {
+		if(random.nextDouble() <= probability) {
+			int length = original.length();
+			int index = random.nextInt(length);
+			String first;
+
+			if(index == 0)
+				first = "";
+			else
+				first = original.substring(0, index);
+
+			char second = original.charAt(index);
+			second++;
+
+			String third;
+
+			if(index == length - 1)
+				third = "";
+			else
+				third = original.substring(index + 1, length);
+
+			return first + second + third;
+		}
+
+		return original;
+	}
+
+	/**
+	 * The abstract base type of card data.
+	 */
+	public interface CardData {
+		/**
+		 * Gets the type of the card.
+		 * 
+		 * @return The type of the card.
+		 */
+		public String getType();
+
+		/**
+		 * Gets the number of the card.
+		 * 
+		 * @return The number of the card.
+		 */
+		public String getNumber();
+
+		/**
+		 * Gets the cardholder's name.
+		 * 
+		 * @return The cardholder's name.
+		 */
+		public String getCardholder();
+
+		/**
+		 * Gets the card verification value (CVV) of the card.
+		 * 
+		 * @return The CVV of the card.
+		 * @throws UnsupportedOperationException
+		 *             If this operation is unsupported by this object.
+		 */
+		public String getCVV();
+	}
+
+	/**
+	 * The data from swiping a card.
+	 */
+	public class CardSwipeData implements CardData {
+		@Override
+		public String getType() {
+			return randomize(type, PROBABILITY_OF_MAGNETIC_STRIPE_CORRUPTION);
+		}
+
+		@Override
+		public String getNumber() {
+			return randomize(number, PROBABILITY_OF_MAGNETIC_STRIPE_CORRUPTION);
+		}
+
+		@Override
+		public String getCardholder() {
+			return randomize(cardholder, PROBABILITY_OF_MAGNETIC_STRIPE_CORRUPTION);
+		}
+
+		@Override
+		public String getCVV() {
+			throw new UnsupportedOperationException();
+		}
+	}
+
+	/**
+	 * The data from tapping a card.
+	 */
+	public final class CardTapData implements CardData {
+		@Override
+		public String getType() {
+			return randomize(type, PROBABILITY_OF_CHIP_CORRUPTION);
+		}
+
+		@Override
+		public String getNumber() {
+			return randomize(number, PROBABILITY_OF_CHIP_CORRUPTION);
+		}
+
+		@Override
+		public String getCardholder() {
+			return randomize(cardholder, PROBABILITY_OF_CHIP_CORRUPTION);
+		}
+
+		@Override
+		public String getCVV() {
+			return randomize(cvv, PROBABILITY_OF_CHIP_CORRUPTION);
+		}
+	}
+
+	/**
+	 * The data from inserting a card.
+	 */
+	public final class CardInsertData implements CardData {
+		CardInsertData(String pin) throws InvalidPINException {
+			if(!testPIN(pin))
+				throw new InvalidPINException();
+		}
+
+		@Override
+		public String getType() {
+			return randomize(type, PROBABILITY_OF_CHIP_CORRUPTION);
+		}
+
+		@Override
+		public String getNumber() {
+			return randomize(number, PROBABILITY_OF_CHIP_CORRUPTION);
+		}
+
+		@Override
+		public String getCardholder() {
+			return randomize(cardholder, PROBABILITY_OF_CHIP_CORRUPTION);
+		}
+
+		@Override
+		public String getCVV() {
+			return randomize(cvv, PROBABILITY_OF_CHIP_CORRUPTION);
+		}
+
+		private boolean testPIN(String pinToTest) {
+			if(pinToTest == pin) {
+				failedTrials = 0;
+				return true;
+			}
+
+			if(++failedTrials >= 3)
+				isBlocked = true;
+
+			return false;
+		}
+	}
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/ChipFailureException.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/ChipFailureException.java
new file mode 100644
index 0000000..971cf50
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/ChipFailureException.java	
@@ -0,0 +1,15 @@
+package org.lsmr.selfcheckout;
+
+import java.io.IOException;
+
+/**
+ * Represents exceptions arising from failures of the chip.
+ */
+public class ChipFailureException extends IOException {
+	private static final long serialVersionUID = 3518203688837080092L;
+
+	/**
+	 * Create an exception.
+	 */
+	public ChipFailureException() {}
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/Coin.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/Coin.java
new file mode 100644
index 0000000..5681c26
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/Coin.java	
@@ -0,0 +1,98 @@
+package org.lsmr.selfcheckout;
+
+import java.math.BigDecimal;
+import java.util.Currency;
+
+import org.lsmr.selfcheckout.devices.SimulationException;
+
+/**
+ * Instances of this class represent individual coins.
+ */
+public class Coin {
+	private BigDecimal value;
+	private Currency currency;
+
+	/**
+	 * Rather than specifying a currency for every coin, a default currency can be
+	 * specified which will be used when the currency is not specified.
+	 */
+	public static Currency DEFAULT_CURRENCY;
+
+	/**
+	 * Constructs a coin, using the default currency.
+	 * 
+	 * @param value
+	 *            The value of the coin, in multiples of the unit of currency.
+	 * @throws SimulationException
+	 *             If the value is &le;0.
+	 * @throws SimulationException
+	 *             If the argument is null.
+	 */
+	public Coin(BigDecimal value) {
+		if(value == null)
+			throw new SimulationException(new NullPointerException("value is null"));
+
+		if(DEFAULT_CURRENCY == null)
+			throw new SimulationException(new NullPointerException("Default currency is null"));
+
+		if(value.compareTo(BigDecimal.ZERO) <= 0)
+			throw new SimulationException(
+				new IllegalArgumentException("The value must be greater than 0: the argument passed was " + value));
+
+		this.value = value;
+		this.currency = DEFAULT_CURRENCY;
+	}
+		
+	/**
+	 * Constructs a coin.
+	 * 
+	 * @param currency
+	 *            The currency represented by this coin.
+	 * @param value
+	 *            The value of the coin, in multiples of the unit of currency.
+	 * @throws SimulationException
+	 *             If the value is &le;0.
+	 * @throws SimulationException
+	 *             If either argument is null.
+	 */
+	public Coin(Currency currency, BigDecimal value) {
+		if(value == null)
+			throw new SimulationException(new NullPointerException("value is null"));
+
+		if(currency == null)
+			throw new SimulationException(new NullPointerException("currency is null"));
+
+		if(value.compareTo(BigDecimal.ZERO) <= 0)
+			throw new SimulationException(
+				new IllegalArgumentException("The value must be greater than 0: the argument passed was " + value));
+
+		this.value = value;
+		this.currency = currency;
+	}
+
+	/**
+	 * Accessor for the value.
+	 * 
+	 * @return The value of the coin. Should always be greater than 0.
+	 */
+	public BigDecimal getValue() {
+		return value;
+	}
+
+	/**
+	 * Accessor for the currency.
+	 * 
+	 * @return The currency for this coin. Note that this is not the same as the
+	 *             "denomination" (e.g., a Canadian dime is worth 0.1 Canadian
+	 *             dollars, so a Canadian dime would have currency "Canadian
+	 *             dollars").
+	 */
+	public Currency getCurrency() {
+		return currency;
+	}
+
+	@Override
+	public String toString() {
+		return value.toString() + " " + currency;
+	}
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/IllegalDigitException.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/IllegalDigitException.java
new file mode 100644
index 0000000..d93a133
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/IllegalDigitException.java	
@@ -0,0 +1,19 @@
+package org.lsmr.selfcheckout;
+
+/**
+ * Signals that an illegal character has been used where a digit (0-9) was
+ * expected.
+ */
+public class IllegalDigitException extends IllegalArgumentException {
+	private static final long serialVersionUID = 3352152121776245096L;
+
+	/**
+	 * Constructs an exception with an error message.
+	 * 
+	 * @param message
+	 *            The error message to display.
+	 */
+	public IllegalDigitException(String message) {
+		super(message);
+	}
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/InvalidPINException.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/InvalidPINException.java
new file mode 100644
index 0000000..2d0b327
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/InvalidPINException.java	
@@ -0,0 +1,15 @@
+package org.lsmr.selfcheckout;
+
+import java.io.IOException;
+
+/**
+ * Represents exceptions arising from entry of an invalid PIN.
+ */
+public class InvalidPINException extends IOException {
+	private static final long serialVersionUID = 5461848339919309513L;
+
+	/**
+	 * Create an exception.
+	 */
+	public InvalidPINException() {}
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/Item.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/Item.java
new file mode 100644
index 0000000..3279604
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/Item.java	
@@ -0,0 +1,35 @@
+package org.lsmr.selfcheckout;
+
+import org.lsmr.selfcheckout.devices.SimulationException;
+import org.lsmr.selfcheckout.products.Product;
+
+/**
+ * Abstract base class of items for sale, each with a particular weight.
+ */
+public abstract class Item {
+	private double weightInGrams;
+
+	/**
+	 * Constructs an item with the indicated weight.
+	 * 
+	 * @param weightInGrams
+	 *            The weight of the item.
+	 * @throws SimulationException
+	 *             If the weight is &le;0.
+	 */
+	protected Item(double weightInGrams) {
+		if(weightInGrams <= 0.0)
+			throw new SimulationException(new IllegalArgumentException("The weight has to be positive."));
+
+		this.weightInGrams = weightInGrams;
+	}
+
+	/**
+	 * The weight of the item, in grams.
+	 * 
+	 * @return The weight in grams.
+	 */
+	public double getWeight() {
+		return weightInGrams;
+	}
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/MagneticStripeFailureException.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/MagneticStripeFailureException.java
new file mode 100644
index 0000000..ba6fb5e
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/MagneticStripeFailureException.java	
@@ -0,0 +1,15 @@
+package org.lsmr.selfcheckout;
+
+import java.io.IOException;
+
+/**
+ * Represents exceptions arising from failures of the magnetic stripe.
+ */
+public class MagneticStripeFailureException extends IOException {
+	private static final long serialVersionUID = -4703845851722394414L;
+
+	/**
+	 * Create an exception.
+	 */
+	public MagneticStripeFailureException() {}
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/Numeral.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/Numeral.java
new file mode 100644
index 0000000..3ba954f
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/Numeral.java	
@@ -0,0 +1,59 @@
+package org.lsmr.selfcheckout;
+
+/**
+ * Represents numerals (i.e., number characters) referred to as "Arabic numbers"
+ * in English.
+ */
+public enum Numeral {
+	one((byte)1), two((byte)2), three((byte)3), four((byte)4), five((byte)5), six((byte)6), seven((byte)7),
+	eight((byte)8), nine((byte)9), zero((byte)0);
+
+	private byte value;
+
+	private Numeral(byte value) {
+		this.value = value;
+	}
+
+	/**
+	 * Obtains the numeric value of the numeral.
+	 * 
+	 * @return The numeric value of the numeral.
+	 */
+	public byte getValue() {
+		return value;
+	}
+
+	/**
+	 * Converts a number between 0 and 9 into the corresponding numeral.
+	 * 
+	 * @param number
+	 *            The number to convert. It must be between 0 and 9, inclusive.
+	 * @return {@link IllegalDigitException} If the number is less than 0 or greater than 9.
+	 */
+	public static Numeral valueOf(byte number) {
+		switch(number) {
+		case 0:
+			return zero;
+		case 1:
+			return one;
+		case 2:
+			return two;
+		case 3:
+			return three;
+		case 4:
+			return four;
+		case 5:
+			return five;
+		case 6:
+			return six;
+		case 7:
+			return seven;
+		case 8:
+			return eight;
+		case 9:
+			return nine;
+		default:
+			throw new IllegalDigitException("The number " + number + " does not correspond to a numeral.");
+		}
+	}
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/PLUCodedItem.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/PLUCodedItem.java
new file mode 100644
index 0000000..a74dbdf
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/PLUCodedItem.java	
@@ -0,0 +1,37 @@
+package org.lsmr.selfcheckout;
+
+import org.lsmr.selfcheckout.devices.SimulationException;
+import org.lsmr.selfcheckout.products.Product;
+
+/**
+ * Represents items for sale, each with a particular barcode and weight.
+ */
+public class PLUCodedItem extends Item {
+	private PriceLookupCode pluCode;
+
+	/**
+	 * Basic constructor.
+	 * 
+	 * @param kind
+	 *            The kind of product that this item is.
+	 * @param weightInGrams
+	 *            The actual weight of the item.
+	 */
+	public PLUCodedItem(PriceLookupCode pluCode, double weightInGrams) {
+		super(weightInGrams);
+		
+		if(pluCode == null)
+			throw new SimulationException(new NullPointerException("pluCode is null"));
+		
+		this.pluCode = pluCode;
+	}
+
+	/**
+	 * Gets the PLU code of this item.
+	 * 
+	 * @return The PLU code.
+	 */
+	public PriceLookupCode getPLUCode() {
+		return pluCode;
+	}
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/PriceLookupCode.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/PriceLookupCode.java
new file mode 100644
index 0000000..d44590d
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/PriceLookupCode.java	
@@ -0,0 +1,114 @@
+package org.lsmr.selfcheckout;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+
+import org.lsmr.selfcheckout.devices.SimulationException;
+
+/**
+ * Represents a PLU value, a sequence of digits that, in principle, could lie
+ * anywhere in the range 0000-99999. Specific subranges are reserved for specific
+ * purposes in the real world, but we will not worry about that here.
+ */
+public class PriceLookupCode {
+	private Numeral[] numerals;
+
+	/**
+	 * Constructs a PLU code from a string of numerals. There must be at least 4
+	 * digits and at most 5.
+	 * 
+	 * @param code
+	 *            A string of digits.
+	 * @throws SimulationException
+	 *             If any character in the input is not a digit between 0 and 9,
+	 *             inclusive.
+	 * @throws SimulationException
+	 *             If the code contains less than 4 digits or more than 5 digits.
+	 * @throws NullPointerException
+	 *             If code is null.
+	 */
+	public PriceLookupCode(String code) {
+		if(code == null)
+			throw new SimulationException(new NullPointerException("code is null"));
+
+		char[] charArray = code.toCharArray();
+		numerals = new Numeral[charArray.length];
+
+		if(code.length() > 5)
+			throw new SimulationException(
+				new IllegalArgumentException("The code cannot contain more than five digits."));
+
+		if(code.length() < 4)
+			throw new SimulationException(
+				new IllegalArgumentException("The code cannot contain less than four digits."));
+
+		for(int i = 0; i < charArray.length; i++) {
+			try {
+				numerals[i] = Numeral.valueOf((byte)Character.digit(charArray[i], 10));
+			}
+			catch(IllegalDigitException e) {
+				throw new SimulationException(e);
+			}
+		}
+	}
+
+	/**
+	 * Gets the count of numerals in this code.
+	 * 
+	 * @return The count of numerals.
+	 */
+	public int numeralCount() {
+		return numerals.length;
+	}
+
+	/**
+	 * Gets the numeral at the indicated index within the code.
+	 * 
+	 * @param index
+	 *            The index of the numeral, &ge;0 and &lt;count.
+	 * @return The numeral at the indicated index.
+	 * @throws SimulationException
+	 *             If the index is outside the legal range.
+	 */
+	public Numeral getNumeralAt(int i) {
+		try {
+			return numerals[i];
+		}
+		catch(IndexOutOfBoundsException e) {
+			throw new SimulationException(e);
+		}
+	}
+
+	@Override
+	public String toString() {
+		char[] characters = new char[numerals.length];
+
+		for(int i = 0; i < numerals.length; i++)
+			characters[i] = Character.forDigit(numerals[i].getValue(), 10);
+
+		return new String(characters);
+	}
+
+	@Override
+	public boolean equals(Object object) {
+		if(object instanceof PriceLookupCode) {
+			PriceLookupCode other = (PriceLookupCode)object;
+
+			if(other.numerals.length != numerals.length)
+				return false;
+
+			for(int i = 0; i < numerals.length; i++)
+				if(!numerals[i].equals(other.numerals[i]))
+					return false;
+
+			return true;
+		}
+
+		return false;
+	}
+
+	@Override
+	public int hashCode() {
+		return Arrays.hashCode(numerals);
+	}
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/TapFailureException.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/TapFailureException.java
new file mode 100644
index 0000000..c1a366c
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/TapFailureException.java	
@@ -0,0 +1,15 @@
+package org.lsmr.selfcheckout;
+
+import java.io.IOException;
+
+/**
+ * Represents exceptions arising from failures of taps.
+ */
+public class TapFailureException extends IOException {
+	private static final long serialVersionUID = -8812895797883270979L;
+
+	/**
+	 * Create an exception.
+	 */
+	public TapFailureException() {}
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/AbstractDevice.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/AbstractDevice.java
new file mode 100644
index 0000000..89f4880
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/AbstractDevice.java	
@@ -0,0 +1,193 @@
+package org.lsmr.selfcheckout.devices;
+
+import java.util.ArrayList;
+
+import org.lsmr.selfcheckout.devices.observers.AbstractDeviceObserver;
+
+/**
+ * The abstract base class for all devices involved in the simulator.
+ * <p>
+ * This class utilizes the Observer design pattern. Subclasses inherit the
+ * attach method, but each must define its own notifyXXX methods.
+ * </p>
+ * <p>
+ * Each device must be coupled to an appropriate observer interface, which
+ * extends AbstractDeviceObserver; the type parameter T represents this
+ * observer.
+ * <p>
+ * <p>
+ * Any individual device can be disabled, which means it will not permit
+ * physical movements to be caused by the software. Any method that could cause
+ * a physical movement will declare that it throws DisabledException.
+ * </p>
+ * 
+ * @param <T>
+ *            The type of observers used for this device. For a device whose
+ *            class is X, its corresponding observer interface would typically
+ *            be XObserver.
+ */
+public abstract class AbstractDevice<T extends AbstractDeviceObserver> {
+	/**
+	 * Used to represent the operation phase of this device.
+	 */
+	protected enum Phase {
+		/**
+		 * The device is being configured.
+		 */
+		CONFIGURATION,
+		/**
+		 * The device is in normal operation.
+		 */
+		NORMAL,
+		/**
+		 * The device has undergone a fatal error requiring physical repair and reset.
+		 */
+		ERROR
+	}
+
+	/**
+	 * The current operation phase of this device.
+	 */
+	protected Phase phase = Phase.CONFIGURATION;
+
+	/**
+	 * Many devices require configuration before their use. Before configuration is
+	 * complete, the device should not operate. Once configuration is complete, any
+	 * further configuration attempts should cause exceptions.
+	 */
+	public void endConfigurationPhase() {
+		phase = Phase.NORMAL;
+	}
+
+	/**
+	 * For testing purposes only. Forces this device into an erroneous state.
+	 */
+	public void forceErrorPhase() {
+		phase = Phase.ERROR;
+	}
+
+	/**
+	 * A list of the registered observers on this device.
+	 */
+	protected ArrayList<T> observers = new ArrayList<>();
+
+	/**
+	 * Locates the indicated observer and removes it such that it will no longer be
+	 * informed of events from this device. If the observer is not currently
+	 * registered with this device, calls to this method will return false, but
+	 * otherwise have no effect.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 * 
+	 * @param observer
+	 *            The observer to remove.
+	 * @return true if the observer was found and removed, false otherwise.
+	 */
+	public final boolean detach(T observer) {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+
+		return observers.remove(observer);
+	}
+
+	/**
+	 * All observers registered with this device are removed. If there are none,
+	 * calls to this method have no effect.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 */
+	public final void detachAll() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+
+		observers.clear();
+	}
+
+	/**
+	 * Registers the indicated observer to receive event notifications from this
+	 * device.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 * 
+	 * @param observer
+	 *            The observer to be added.
+	 */
+	public final void attach(T observer) {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+
+		if(observer == null)
+			throw new SimulationException(new IllegalArgumentException(
+				"This method may not receive null, as it has no analogue in the real world."));
+
+		observers.add(observer);
+	}
+
+	private boolean disabled = false;
+
+	/**
+	 * Disables this device from receiving input and producing output.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 */
+	public final void disable() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		disabled = true;
+		notifyDisabled();
+	}
+
+	private void notifyDisabled() {
+		for(T observer : observers)
+			observer.disabled(this);
+	}
+
+	/**
+	 * Enables this device for receiving input and producing output.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 */
+	public final void enable() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		disabled = false;
+		notifyEnabled();
+	}
+
+	private void notifyEnabled() {
+		for(T observer : observers)
+			observer.enabled(this);
+	}
+
+	/**
+	 * Returns whether this device is currently disabled from receiving input and
+	 * producing output.
+	 * <p>
+	 * This operation is illegal during the configuration phase.
+	 * 
+	 * @return true if the device is disabled; false if the device is enabled.
+	 */
+	public final boolean isDisabled() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		return disabled;
+	}
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/Acceptor.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/Acceptor.java
new file mode 100644
index 0000000..4534b94
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/Acceptor.java	
@@ -0,0 +1,37 @@
+package org.lsmr.selfcheckout.devices;
+
+import org.lsmr.selfcheckout.Coin;
+
+/**
+ * A simple interface for devices that accept things.
+ * 
+ * @param <T>
+ *            The type of the things to accept.
+ */
+public interface Acceptor<T> {
+	/**
+	 * Instructs the device to take the thing as input.
+	 * <p>
+	 * This operation may not be called during the configuration phase.
+	 * 
+	 * @param thing
+	 *            The thing to be taken as input.
+	 * @throws OverloadException
+	 *             If the device does not have enough space for the thing.
+	 * @throws DisabledException
+	 *             If the device is disabled.
+	 */
+	public void accept(T thing) throws OverloadException, DisabledException;
+
+	/**
+	 * Checks whether the device has enough space to expect one more thing. If this
+	 * method returns true, an immediate call to accept should not throw
+	 * CapacityExceededException, unless an asynchronous addition has occurred in
+	 * the meantime.
+	 * <p>
+	 * This operation may not be called during the configuration phase.
+	 * 
+	 * @return true If there is space; otherwise, false.
+	 */
+	public boolean hasSpace();
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/BanknoteDispenser.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/BanknoteDispenser.java
new file mode 100644
index 0000000..de25f9c
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/BanknoteDispenser.java	
@@ -0,0 +1,213 @@
+package org.lsmr.selfcheckout.devices;
+
+import java.util.ArrayList;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Queue;
+
+import org.lsmr.selfcheckout.Banknote;
+import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
+import org.lsmr.selfcheckout.devices.observers.BanknoteDispenserObserver;
+
+/**
+ * Represents a device that stores banknotes (as known as bills, paper money,
+ * etc.) of a particular denomination to dispense them as change.
+ * <p>
+ * Banknote dispensers can receive banknotes from other sources. To simplify the
+ * simulation, no check is performed on the value of each banknote.
+ * </p>
+ */
+public final class BanknoteDispenser extends AbstractDevice<BanknoteDispenserObserver>
+	implements FromStorageEmitter<Banknote> {
+	private int maxCapacity;
+	private Queue<Banknote> queue = new LinkedList<Banknote>();
+	private UnidirectionalChannel<Banknote> sink;
+
+	/**
+	 * Creates a banknote dispenser with the indicated maximum capacity.
+	 * 
+	 * @param capacity
+	 *            The maximum number of banknotes that can be stored in the
+	 *            dispenser. Must be positive.
+	 * @throws SimulationException
+	 *             If capacity is not positive.
+	 */
+	public BanknoteDispenser(int capacity) {
+		if(capacity <= 0)
+			throw new SimulationException(new IllegalArgumentException("Capacity must be positive: " + capacity));
+
+		this.maxCapacity = capacity;
+	}
+
+	/**
+	 * Accesses the current number of banknotes in the dispenser.
+	 * <p>
+	 * This operation is illegal during the configuration phase.
+	 * 
+	 * @return The number of banknotes currently in the dispenser.
+	 */
+	public int size() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		return queue.size();
+	}
+
+	/**
+	 * Allows a set of banknotes to be loaded into the dispenser directly. Existing
+	 * banknotes in the dispenser are not removed.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 * 
+	 * @param banknotes
+	 *            A sequence of banknotes to be added. Each may not be null.
+	 * @throws OverloadException
+	 *             if the number of banknotes to be loaded exceeds the capacity of
+	 *             the dispenser.
+	 * @throws SimulationException
+	 *             If any banknote is null.
+	 */
+	public void load(Banknote... banknotes) throws SimulationException, OverloadException {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+
+		if(maxCapacity < queue.size() + banknotes.length)
+			throw new OverloadException("Capacity of dispenser is exceeded by load");
+
+		for(Banknote banknote : banknotes)
+			if(banknote == null)
+				throw new SimulationException(new NullPointerException("A banknote is null."));
+			else
+				queue.add(banknote);
+
+		notifyBanknotesLoaded(banknotes);
+	}
+
+	/**
+	 * Unloads banknotes from the dispenser directly. Causes a "banknotesUnloaded"
+	 * event to be announced.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 * 
+	 * @return A list of the banknotes unloaded. May be empty. Will never be null.
+	 */
+	public List<Banknote> unload() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+
+		List<Banknote> result = new ArrayList<>(queue);
+		queue.clear();
+
+		notifyBanknotesUnoaded(result.toArray(new Banknote[result.size()]));
+
+		return result;
+	}
+
+	/**
+	 * Connects an output channel to this banknote dispenser. Any existing output
+	 * channels are disconnected. Causes no events to be announced.
+	 * <p>
+	 * This operation is permissible only during the configuration phase.
+	 * 
+	 * @param sink
+	 *            The new output device to act as output. Can be null, which leaves
+	 *            the channel without an output.
+	 */
+	public void connect(UnidirectionalChannel<Banknote> sink) {
+		if(phase != Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may only be called during the configuration phase."));
+
+		this.sink = sink;
+	}
+
+	/**
+	 * Returns the maximum capacity of this banknote dispenser.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 * 
+	 * @return The capacity. Will be positive.
+	 */
+	public int getCapacity() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+
+		return maxCapacity;
+	}
+
+	/**
+	 * Emits a single banknote from this banknote dispenser. If successful, a
+	 * "banknoteRemoved" event is announced to its observers. If a successful
+	 * banknote removal causes the dispenser to become empty, a "banknotesEmpty"
+	 * event is instead announced to its observers.
+	 * <p>
+	 * This operation is illegal during the configuration phase.
+	 * 
+	 * @throws OverloadException
+	 *             if the output channel is unable to accept another banknote.
+	 * @throws EmptyException
+	 *             if no banknotes are present in the dispenser to release.
+	 * @throws DisabledException
+	 *             if the dispenser is currently disabled.
+	 */
+	public void emit() throws EmptyException, DisabledException, OverloadException {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		if(isDisabled())
+			throw new DisabledException();
+
+		if(queue.size() == 0)
+			throw new EmptyException();
+
+		Banknote banknote = queue.remove();
+
+		if(sink.hasSpace())
+			try {
+				sink.deliver(banknote);
+			}
+			catch(OverloadException e) {
+				// Should never happen
+				phase = Phase.ERROR;
+				throw new SimulationException(e);
+			}
+		else
+			throw new OverloadException("The sink is full.");
+
+		if(queue.isEmpty())
+			notifyBanknotesEmpty();
+		else
+			notifyBanknoteRemoved(banknote);
+	}
+
+	private void notifyBanknoteRemoved(Banknote banknote) {
+		for(BanknoteDispenserObserver observer : observers)
+			observer.banknoteRemoved(this, banknote);
+	}
+
+	private void notifyBanknotesEmpty() {
+		for(BanknoteDispenserObserver observer : observers)
+			observer.banknotesEmpty(this);
+	}
+
+	private void notifyBanknotesLoaded(Banknote[] banknotes) {
+		for(BanknoteDispenserObserver observer : observers)
+			observer.banknotesLoaded(this, banknotes);
+	}
+
+	private void notifyBanknotesUnoaded(Banknote[] banknotes) {
+		for(BanknoteDispenserObserver observer : observers)
+			observer.banknotesUnloaded(this, banknotes);
+	}
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/BanknoteSlot.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/BanknoteSlot.java
new file mode 100644
index 0000000..9037e26
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/BanknoteSlot.java	
@@ -0,0 +1,191 @@
+package org.lsmr.selfcheckout.devices;
+
+import org.lsmr.selfcheckout.Banknote;
+import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
+import org.lsmr.selfcheckout.devices.observers.BanknoteSlotObserver;
+
+/**
+ * Represents a simple banknote slot device that can either accept a banknote or
+ * eject the most recently inserted banknote, leaving it dangling until the
+ * customer removes it, via {@link #removeDanglingBanknote()}.
+ */
+public class BanknoteSlot extends AbstractDevice<BanknoteSlotObserver>
+	implements Acceptor<Banknote>, FlowThroughEmitter<Banknote> {
+	private BidirectionalChannel<Banknote> sink;
+	private boolean invert;
+
+	/**
+	 * Creates a banknote slot.
+	 * 
+	 * @param invert
+	 *            If the slot is to be inverted.
+	 */
+	public BanknoteSlot(boolean invert) {
+		this.invert = invert;
+	}
+
+	/**
+	 * Connects an output channel to the banknote slot. Causes no events.
+	 * <p>
+	 * This operation is permissible only during the configuration phase.
+	 * 
+	 * @param sink
+	 *            Where banknotes are passed into the machine.
+	 */
+	public void connect(BidirectionalChannel<Banknote> sink) {
+		if(phase != Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may only be called during the configuration phase."));
+
+		this.sink = sink;
+	}
+
+	/**
+	 * Tells the banknote slot that the indicated banknote is being inserted. If the
+	 * sink can accept the banknote, the banknote is passed to the sink and a
+	 * "banknoteInserted" event is announced to the slot's observers; otherwise, a
+	 * "banknoteEjected" event is announced to the slot's observers, meaning that
+	 * the banknote is returned to the user.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @param banknote
+	 *            The banknote to be added. Cannot be null.
+	 * @throws DisabledException
+	 *             if the banknote slot is currently disabled.
+	 * @throws SimulationException
+	 *             If the banknote is null.
+	 * @throws OverloadException
+	 *             If a banknote is dangling from the slot.
+	 */
+	public void accept(Banknote banknote) throws DisabledException, OverloadException {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		if(isDisabled())
+			throw new DisabledException();
+
+		if(danglingEjectedBanknote != null)
+			throw new OverloadException("A banknote is dangling from the slot. Remove that before adding another.");
+
+		notifyBanknoteInserted();
+
+		if(!invert && sink.hasSpace()) {
+			try {
+				sink.deliver(banknote);
+			}
+			catch(OverloadException e) {
+				// Should never happen
+				phase = Phase.ERROR;
+				throw new SimulationException(e);
+			}
+		}
+		else {
+			danglingEjectedBanknote = banknote;
+			notifyBanknoteEjected();
+		}
+	}
+
+	private Banknote danglingEjectedBanknote = null;
+
+	/**
+	 * Ejects the indicated banknote, leaving it dangling until the customer grabs
+	 * it.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @param banknote
+	 *            The banknote to be ejected.
+	 * @throws DisabledException
+	 *             If the device is disabled.
+	 * @throws SimulationException
+	 *             If the argument is null.
+	 * @throws SimulationException
+	 *             If a banknote is already dangling from the slot.
+	 */
+	public void emit(Banknote banknote) throws DisabledException, SimulationException {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		if(isDisabled())
+			throw new DisabledException();
+
+		if(banknote == null)
+			throw new SimulationException(new NullPointerException("banknote is null"));
+
+		if(danglingEjectedBanknote != null)
+			throw new SimulationException(
+				"A banknote is already dangling from the slot. Remove that before ejecting another.");
+
+		danglingEjectedBanknote = banknote;
+
+		notifyBanknoteEjected();
+	}
+
+	/**
+	 * Simulates the user removing a banknote that is dangling from the slot.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @return The formerly dangling banknote.
+	 */
+	public Banknote removeDanglingBanknote() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		if(danglingEjectedBanknote == null)
+			throw new SimulationException("A banknote that does not exist cannot be removed.");
+
+		Banknote b = danglingEjectedBanknote;
+		danglingEjectedBanknote = null;
+		notifyBanknoteRemoved();
+
+		return b;
+	}
+
+	/**
+	 * Tests whether a banknote can be accepted by or ejected from this slot.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @return True if the slot is not occupied by a dangling banknote; otherwise,
+	 *             false.
+	 */
+	public boolean hasSpace() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		return danglingEjectedBanknote == null;
+	}
+
+	private void notifyBanknoteInserted() {
+		for(BanknoteSlotObserver observer : observers)
+			observer.banknoteInserted(this);
+	}
+
+	private void notifyBanknoteEjected() {
+		for(BanknoteSlotObserver observer : observers)
+			observer.banknoteEjected(this);
+	}
+
+	private void notifyBanknoteRemoved() {
+		for(BanknoteSlotObserver observer : observers)
+			observer.banknoteRemoved(this);
+	}
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/BanknoteStorageUnit.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/BanknoteStorageUnit.java
new file mode 100644
index 0000000..34e6a81
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/BanknoteStorageUnit.java	
@@ -0,0 +1,199 @@
+package org.lsmr.selfcheckout.devices;
+
+import java.util.Arrays;
+import java.util.List;
+
+import org.lsmr.selfcheckout.Banknote;
+import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
+import org.lsmr.selfcheckout.devices.observers.BanknoteStorageUnitObserver;
+
+/**
+ * Represents devices that store banknotes. They only receive banknotes, not
+ * dispense them. To access the banknotes inside, a human operator needs to
+ * physically remove the banknotes, simulated with the {@link #unload()} method.
+ * A {@link #load(Banknote...)} method is provided for symmetry.
+ */
+public class BanknoteStorageUnit extends AbstractDevice<BanknoteStorageUnitObserver> implements Acceptor<Banknote> {
+	private Banknote[] storage;
+	private int nextIndex = 0;
+
+	/**
+	 * Creates a banknote storage unit that can hold the indicated number of
+	 * banknotes.
+	 * 
+	 * @param capacity
+	 *            The maximum number of banknotes that the unit can hold.
+	 * @throws SimulationException
+	 *             If the capacity is not positive.
+	 */
+	public BanknoteStorageUnit(int capacity) {
+		if(capacity <= 0)
+			throw new SimulationException(new IllegalArgumentException("The capacity must be positive."));
+
+		storage = new Banknote[capacity];
+	}
+
+	/**
+	 * Gets the maximum number of banknotes that this storage unit can hold.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 * 
+	 * @return The capacity.
+	 */
+	public int getCapacity() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+
+		return storage.length;
+	}
+
+	/**
+	 * Gets the current count of banknotes contained in this storage unit.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 * 
+	 * @return The current count.
+	 */
+	public int getBanknoteCount() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+
+		return nextIndex;
+	}
+
+	/**
+	 * Allows a set of banknotes to be loaded into the storage unit directly.
+	 * Existing banknotes in the dispenser are not removed. Causes a
+	 * "banknotesLoaded" event to be announced. Disabling has no effect on
+	 * loading/unloading.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 * 
+	 * @param banknotes
+	 *            A sequence of banknotes to be added. Each cannot be null.
+	 * @throws SimulationException
+	 *             if the number of banknotes to be loaded exceeds the capacity of
+	 *             the unit.
+	 * @throws SimulationException
+	 *             If the banknotes argument is null.
+	 * @throws SimulationException
+	 *             If any banknote is null.
+	 * @throws OverloadException
+	 *             If too many banknotes are stuffed in the unit.
+	 */
+	public void load(Banknote... banknotes) throws SimulationException, OverloadException {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+
+		if(banknotes == null)
+			throw new SimulationException(
+				new NullPointerException("banknotes is null which has no analogue in the real world"));
+
+		if(banknotes.length + nextIndex > storage.length)
+			throw new OverloadException("You tried to stuff too many banknotes in the storage unit.");
+
+		for(Banknote banknote : banknotes)
+			if(banknote == null)
+				throw new SimulationException(
+					new NullPointerException("No banknote may be null, which has no analogue in the real world."));
+
+		System.arraycopy(banknotes, 0, storage, nextIndex, banknotes.length);
+		nextIndex += banknotes.length;
+
+		notifyBanknotesLoaded();
+	}
+
+	/**
+	 * Unloads banknotes from the storage unit directly. Causes a
+	 * "banknotesUnloaded" event to be announced.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 * 
+	 * @return A list of the banknotes unloaded. May be empty. Will never be null.
+	 */
+	public List<Banknote> unload() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+
+		List<Banknote> banknotes = Arrays.asList(storage);
+
+		storage = new Banknote[storage.length];
+		nextIndex = 0;
+		notifyBanknotesUnloaded();
+
+		return banknotes;
+	}
+
+	/**
+	 * Causes the indicated banknote to be added to the storage unit. If successful,
+	 * a "banknoteAdded" event is announced to its observers. If a successful
+	 * banknote addition causes the unit to become full, a "banknotesFull" event is
+	 * instead announced to its observers.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @param banknote
+	 *            The banknote to add.
+	 * @throws DisabledException
+	 *             If the unit is currently disabled.
+	 * @throws SimulationException
+	 *             If banknote is null.
+	 * @throws OverloadException
+	 *             If the unit is already full.
+	 */
+	public void accept(Banknote banknote) throws DisabledException, OverloadException {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		if(isDisabled())
+			throw new DisabledException();
+
+		if(banknote == null)
+			throw new SimulationException(
+				new NullPointerException("banknote is null, which has no analogue in the real world."));
+
+		if(nextIndex < storage.length) {
+			storage[nextIndex++] = banknote;
+
+			if(nextIndex == storage.length)
+				notifyBanknotesFull();
+			else
+				notifyBanknoteAdded();
+		}
+		else
+			throw new OverloadException();
+	}
+
+	@Override
+	public boolean hasSpace() {
+		return nextIndex < storage.length;
+	}
+
+	private void notifyBanknotesLoaded() {
+		for(BanknoteStorageUnitObserver l : observers)
+			l.banknotesLoaded(this);
+	}
+
+	private void notifyBanknotesUnloaded() {
+		for(BanknoteStorageUnitObserver l : observers)
+			l.banknotesUnloaded(this);
+	}
+
+	private void notifyBanknotesFull() {
+		for(BanknoteStorageUnitObserver l : observers)
+			l.banknotesFull(this);
+	}
+
+	private void notifyBanknoteAdded() {
+		for(BanknoteStorageUnitObserver l : observers)
+			l.banknoteAdded(this);
+	}
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/BanknoteValidator.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/BanknoteValidator.java
new file mode 100644
index 0000000..e014ea9
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/BanknoteValidator.java	
@@ -0,0 +1,201 @@
+package org.lsmr.selfcheckout.devices;
+
+import java.util.Arrays;
+import java.util.Currency;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Random;
+
+import org.lsmr.selfcheckout.Banknote;
+import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
+import org.lsmr.selfcheckout.devices.observers.BanknoteValidatorObserver;
+
+/**
+ * Represents a device for optically and/or magnetically validating banknotes.
+ * Banknotes deemed valid are moved to storage; banknotes deemed invalid are
+ * ejected.
+ */
+public final class BanknoteValidator extends AbstractDevice<BanknoteValidatorObserver>
+	implements Acceptor<Banknote>, Emitter<Banknote> {
+	private final Currency currency;
+	private final int[] denominations;
+	private BidirectionalChannel<Banknote> source;
+	private UnidirectionalChannel<Banknote> sink;
+
+	/**
+	 * Creates a banknote validator that recognizes banknotes of the specified
+	 * denominations (i.e., values) and currency.
+	 * 
+	 * @param currency
+	 *            The kind of currency to accept.
+	 * @param denominations
+	 *            An array of the valid banknote denominations (like $5, $10, etc.)
+	 *            to accept. Each value must be &gt;0 and unique in this array.
+	 * @throws SimulationException
+	 *             If either argument is null.
+	 * @throws SimulationException
+	 *             If the denominations array does not contain at least one value.
+	 * @throws SimulationException
+	 *             If any value in the denominations array is non-positive.
+	 * @throws SimulationException
+	 *             If any value in the denominations array is non-unique.
+	 */
+	public BanknoteValidator(Currency currency, int[] denominations) {
+		if(currency == null)
+			throw new SimulationException(
+				new NullPointerException("currency is null, which has no analogue in the real world."));
+
+		if(denominations == null)
+			throw new SimulationException(
+				new NullPointerException("denominations is null, which has no analogue in the real world."));
+
+		if(denominations.length < 1)
+			throw new SimulationException(new IllegalArgumentException("There must be at least one denomination."));
+
+		this.currency = currency;
+		Arrays.sort(denominations);
+
+		HashSet<Integer> set = new HashSet<>();
+
+		for(int denomination : denominations) {
+			if(denomination <= 0)
+				throw new SimulationException(
+					new IllegalArgumentException("Non-positive denomination detected: " + denomination + "."));
+
+			if(set.contains(denomination))
+				throw new SimulationException(new IllegalArgumentException(
+					"Each denomination must be unique, but " + denomination + " is repeated."));
+
+			set.add(denomination);
+		}
+
+		this.denominations = denominations;
+	}
+
+	/**
+	 * Connects input and output channels to the banknote validator. Causes no events.
+	 * <p>
+	 * This operation is permissible only during the configuration phase.
+	 * 
+	 * @param source
+	 *            The channel from which banknotes normally arrive for validation,
+	 *            and to which invalid banknotes will be ejected.
+	 * @param sink
+	 *            The channel to which all valid banknotes are routed.
+	 */
+	public void connect(BidirectionalChannel<Banknote> source, UnidirectionalChannel<Banknote> sink) {
+		if(phase != Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may only be called during the configuration phase."));
+
+		this.source = source;
+		this.sink = sink;
+	}
+
+	private final Random pseudoRandomNumberGenerator = new Random();
+	private static final int PROBABILITY_OF_FALSE_REJECTION = 1; /* out of 100 */
+
+	private boolean isValid(Banknote banknote) {
+		if(currency.equals(banknote.getCurrency()))
+			for(int denomination : denominations)
+				if(denomination == banknote.getValue())
+					return pseudoRandomNumberGenerator.nextInt(100) >= PROBABILITY_OF_FALSE_REJECTION;
+
+		return false;
+	}
+
+	/**
+	 * Tells the banknote validator that the indicated banknote is being inserted.
+	 * If the banknote is valid, a "validBanknoteDetected" event is announced to its
+	 * observers; otherwise, an "invalidBanknoteDetected" event is announced to its
+	 * observers.
+	 * <p>
+	 * If there is space in the machine to store a valid banknote, it is passed to
+	 * the sink channel.
+	 * </p>
+	 * <p>
+	 * If there is no space in the machine to store it or the banknote is invalid,
+	 * the banknote is ejected to the source.
+	 * </p>
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @param banknote
+	 *            The banknote to be added. Cannot be null.
+	 * @throws DisabledException
+	 *             if the banknote validator is currently disabled.
+	 * @throws SimulationException
+	 *             If the banknote is null.
+	 */
+	@Override
+	public void accept(Banknote banknote) throws DisabledException {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		if(isDisabled())
+			throw new DisabledException();
+
+		if(banknote == null)
+			throw new SimulationException(new NullPointerException("banknote is null"));
+
+		if(isValid(banknote)) {
+			notifyValidBanknoteDetected(banknote);
+
+			if(sink.hasSpace()) {
+				try {
+					sink.deliver(banknote);
+				}
+				catch(OverloadException e) {
+					// Should never happen
+					phase = Phase.ERROR;
+					throw new SimulationException(e);
+				}
+			}
+			else {
+				try {
+					source.eject(banknote);
+				}
+				catch(OverloadException e) {
+					// Should never happen
+					phase = Phase.ERROR;
+					throw new SimulationException(e);
+				}
+			}
+		}
+		else {
+			notifyInvalidBanknoteDetected();
+
+			try {
+				source.eject(banknote);
+			}
+			catch(OverloadException e) {
+				// Should never happen
+				phase = Phase.ERROR;
+				throw new SimulationException("Unable to route banknote: sink is full");
+			}
+		}
+	}
+
+	@Override
+	public boolean hasSpace() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+
+		return true;
+	}
+
+	private void notifyValidBanknoteDetected(Banknote banknote) {
+		for(BanknoteValidatorObserver observer : observers)
+			observer.validBanknoteDetected(this, banknote.getCurrency(), banknote.getValue());
+	}
+
+	private void notifyInvalidBanknoteDetected() {
+		for(BanknoteValidatorObserver observer : observers)
+			observer.invalidBanknoteDetected(this);
+	}
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/BarcodeScanner.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/BarcodeScanner.java
new file mode 100644
index 0000000..872da0e
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/BarcodeScanner.java	
@@ -0,0 +1,60 @@
+package org.lsmr.selfcheckout.devices;
+
+import java.util.Random;
+
+import org.lsmr.selfcheckout.BarcodedItem;
+import org.lsmr.selfcheckout.Item;
+import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
+import org.lsmr.selfcheckout.devices.observers.BarcodeScannerObserver;
+
+/**
+ * A complex device hidden behind a simple simulation. They can scan and that is
+ * about all.
+ */
+public class BarcodeScanner extends AbstractDevice<BarcodeScannerObserver> {
+	/**
+	 * Create a barcode scanner.
+	 */
+	public BarcodeScanner() {}
+
+	private Random random = new Random();
+	private static final int PROBABILITY_OF_FAILED_SCAN = 10; /* out of 100 */
+
+	/**
+	 * Simulates the customer's action of scanning an item. The result of the scan
+	 * is only announced to any registered observers.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @param item
+	 *            The item to scan. Of course, it will only work if the item has a
+	 *            barcode, and maybe not even then.
+	 * @throws SimulationException
+	 *             If item is null.
+	 */
+	public void scan(Item item) {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		if(isDisabled())
+			return; // silently ignore it
+
+		if(item == null)
+			throw new SimulationException(
+				new NullPointerException("item is null, which has no analogue in the real world."));
+
+		if(item instanceof BarcodedItem && random.nextInt(100) >= PROBABILITY_OF_FAILED_SCAN)
+			notifyBarcodeScanned((BarcodedItem)item);
+
+		// otherwise, silently ignore it
+	}
+
+	private void notifyBarcodeScanned(BarcodedItem item) {
+		for(BarcodeScannerObserver l : observers)
+			l.barcodeScanned(this, item.getBarcode());
+	}
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/BidirectionalChannel.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/BidirectionalChannel.java
new file mode 100644
index 0000000..4d67894
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/BidirectionalChannel.java	
@@ -0,0 +1,69 @@
+package org.lsmr.selfcheckout.devices;
+
+import org.lsmr.selfcheckout.Banknote;
+import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
+
+/**
+ * Represents a simple device (like, say, a tube or just a physical connection)
+ * that moves things between other devices. This channel is bidirectional.
+ * 
+ * @param <T>
+ *            The type of the things to move.
+ */
+public final class BidirectionalChannel<T> {
+	private FlowThroughEmitter<T> source;
+	private Acceptor<T> sink;
+
+	/**
+	 * Constructs a new channel whose input is connected to the indicated source and
+	 * whose output is connected to the indicated sink.
+	 * 
+	 * @param source
+	 *            The device at the output end of the channel.
+	 * @param sink
+	 *            The device at the output end of the channel.
+	 */
+	public BidirectionalChannel(FlowThroughEmitter<T> source, Acceptor<T> sink) {
+		this.source = source;
+		this.sink = sink;
+	}
+
+	/**
+	 * Moves the indicated thing to the source. This method should be called by
+	 * the sink device, and not by an external application.
+	 * 
+	 * @param thing
+	 *            The thing to transport via the channel.
+	 * @throws OverloadException
+	 *             if the sink has no space for the banknote.
+	 * @throws DisabledException
+	 *             if the sink is currently disabled.
+	 */
+	public void eject(T thing) throws OverloadException, DisabledException {
+		source.emit(thing);
+	}
+
+	/**
+	 * Moves the indicated banknote to the sink. This method should be called by the
+	 * source device, and not by an external application.
+	 * 
+	 * @param banknote
+	 *            The banknote to transport via the channel.
+	 * @throws OverloadException
+	 *             if the sink has no space for the banknote.
+	 * @throws DisabledException
+	 *             if the sink is currently disabled.
+	 */
+	public void deliver(T banknote) throws OverloadException, DisabledException {
+		sink.accept(banknote);
+	}
+
+	/**
+	 * Returns whether the sink has space for at least one more banknote.
+	 * 
+	 * @return true if the sink can accept a banknote; false otherwise.
+	 */
+	public boolean hasSpace() {
+		return sink.hasSpace();
+	}
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/CardReader.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/CardReader.java
new file mode 100644
index 0000000..de592f1
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/CardReader.java	
@@ -0,0 +1,185 @@
+package org.lsmr.selfcheckout.devices;
+
+import java.awt.image.BufferedImage;
+import java.io.IOException;
+import java.util.concurrent.ThreadLocalRandom;
+
+import org.lsmr.selfcheckout.Card;
+import org.lsmr.selfcheckout.Card.CardData;
+import org.lsmr.selfcheckout.ChipFailureException;
+import org.lsmr.selfcheckout.MagneticStripeFailureException;
+import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
+import org.lsmr.selfcheckout.devices.observers.CardReaderObserver;
+
+/**
+ * Represents the card reader, capable of tap, chip insert, and swipe. Either
+ * the reader or the card may fail, or the data read in can be corrupted, with
+ * varying probabilities.
+ */
+public class CardReader extends AbstractDevice<CardReaderObserver> {
+	private boolean cardIsInserted = false;
+
+	/**
+	 * Create a card reader.
+	 */
+	public CardReader() {}
+
+	private final static ThreadLocalRandom random = ThreadLocalRandom.current();
+	private final static double PROBABILITY_OF_TAP_FAILURE = 0.01;
+	private final static double PROBABILITY_OF_INSERT_FAILURE = 0.01;
+	private final static double PROBABILITY_OF_SWIPE_FAILURE = 0.1;
+
+	/**
+	 * Tap the card.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @param card
+	 *            The card to tap.
+	 * @return The card's (possibly corrupted) data, or null if the card is not tap
+	 *             enabled.
+	 * @throws IOException
+	 *             If the tap failed (lack of failure does not mean that the data is
+	 *             not corrupted).
+	 */
+	public CardData tap(Card card) throws IOException {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		if(card.isTapEnabled) {
+			notifyCardTapped();
+
+			if(random.nextDouble(0.0, 1.0) > PROBABILITY_OF_TAP_FAILURE) {
+				CardData data = card.tap();
+
+				notifyCardDataRead(data);
+
+				return data;
+			}
+			else
+				throw new ChipFailureException();
+		}
+
+		// else ignore
+		return null;
+	}
+
+	/**
+	 * Swipe the card.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @param card
+	 *            The card to swipe.
+	 * @return The card data.
+	 * @throws IOException
+	 *             If the swipe failed.
+	 */
+	public CardData swipe(Card card) throws IOException {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		notifyCardSwiped();
+
+		if(random.nextDouble(0.0, 1.0) > PROBABILITY_OF_SWIPE_FAILURE) {
+			CardData data = card.swipe();
+
+			notifyCardDataRead(data);
+
+			return data;
+		}
+
+		throw new MagneticStripeFailureException();
+	}
+
+	/**
+	 * Insert the card.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @param card
+	 *            The card to insert.
+	 * @param pin
+	 *            The customer's PIN.
+	 * @return The card data.
+	 * @throws SimulationException
+	 *             If there is already a card in the slot.
+	 * @throws IOException
+	 *             The insertion failed.
+	 */
+	public CardData insert(Card card, String pin) throws IOException {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		if(cardIsInserted)
+			throw new IllegalStateException("There is already a card in the slot");
+
+		cardIsInserted = true;
+
+		notifyCardInserted();
+
+		if(card.hasChip && random.nextDouble(0.0, 1.0) > PROBABILITY_OF_INSERT_FAILURE) {
+			CardData data = card.insert(pin);
+
+			notifyCardDataRead(data);
+
+			return data;
+		}
+
+		throw new ChipFailureException();
+	}
+
+	/**
+	 * Remove the card from the slot.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 */
+	public void remove() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		cardIsInserted = false;
+		notifyCardRemoved();
+	}
+
+	private void notifyCardTapped() {
+		for(CardReaderObserver l : observers)
+			l.cardTapped(this);
+	}
+
+	private void notifyCardInserted() {
+		for(CardReaderObserver l : observers)
+			l.cardInserted(this);
+	}
+
+	private void notifyCardSwiped() {
+		for(CardReaderObserver l : observers)
+			l.cardSwiped(this);
+	}
+
+	private void notifyCardDataRead(CardData data) {
+		for(CardReaderObserver l : observers)
+			l.cardDataRead(this, data);
+	}
+
+	private void notifyCardRemoved() {
+		for(CardReaderObserver l : observers)
+			l.cardRemoved(this);
+	}
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/CoinDispenser.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/CoinDispenser.java
new file mode 100644
index 0000000..e6cdc73
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/CoinDispenser.java	
@@ -0,0 +1,262 @@
+package org.lsmr.selfcheckout.devices;
+
+import java.util.ArrayList;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Queue;
+
+import org.lsmr.selfcheckout.Coin;
+import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
+import org.lsmr.selfcheckout.devices.observers.CoinDispenserObserver;
+
+/**
+ * Represents a device that stores coins of a particular denomination to
+ * dispense them as change.
+ * <p>
+ * Coin dispensers can receive coins from other sources. To simplify the
+ * simulation, no check is performed on the value of each coin, meaning it is an
+ * external responsibility to ensure the correct routing of coins.
+ * </p>
+ */
+public final class CoinDispenser extends AbstractDevice<CoinDispenserObserver>
+	implements Acceptor<Coin>, FromStorageEmitter<Coin> {
+	private int maxCapacity;
+	private Queue<Coin> queue = new LinkedList<Coin>();
+	private UnidirectionalChannel<Coin> sink;
+
+	/**
+	 * Creates a coin dispenser with the indicated maximum capacity.
+	 * 
+	 * @param capacity
+	 *            The maximum number of coins that can be stored in the dispenser.
+	 *            Must be positive.
+	 * @throws SimulationException
+	 *             if capacity is not positive.
+	 */
+	public CoinDispenser(int capacity) {
+		if(capacity <= 0)
+			throw new SimulationException(new IllegalArgumentException("Capacity must be positive: " + capacity));
+
+		this.maxCapacity = capacity;
+	}
+
+	/**
+	 * Accesses the current number of coins in the dispenser.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 * 
+	 * @return The number of coins currently in the dispenser.
+	 */
+	public int size() {
+		return queue.size();
+	}
+
+	/**
+	 * Allows a set of coins to be loaded into the dispenser directly. Existing
+	 * coins in the dispenser are not removed. Causes a "coinsLoaded" event to be
+	 * announced.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 * 
+	 * @param coins
+	 *            A sequence of coins to be added. Each cannot be null.
+	 * @throws OverloadException
+	 *             if the number of coins to be loaded exceeds the capacity of the
+	 *             dispenser.
+	 * @throws SimulationException
+	 *             If any coin is null.
+	 */
+	public void load(Coin... coins) throws SimulationException, OverloadException {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+
+		if(maxCapacity < queue.size() + coins.length)
+			throw new OverloadException("Capacity of dispenser is exceeded by load");
+
+		for(Coin coin : coins)
+			if(coin == null)
+				throw new SimulationException(new NullPointerException("A coin is null"));
+			else
+				queue.add(coin);
+
+		notifyLoad(coins);
+	}
+
+	private void notifyLoad(Coin[] coins) {
+		for(CoinDispenserObserver observer : observers)
+			observer.coinsLoaded(this, coins);
+	}
+
+	/**
+	 * Unloads coins from the dispenser directly. Causes a "coinsUnloaded" event to
+	 * be announced.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 * 
+	 * @return A list of the coins unloaded. May be empty. Will never be null.
+	 */
+	public List<Coin> unload() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+
+		List<Coin> result = new ArrayList<>(queue);
+		queue.clear();
+
+		notifyUnload(result.toArray(new Coin[result.size()]));
+
+		return result;
+	}
+
+	private void notifyUnload(Coin[] coins) {
+		for(CoinDispenserObserver observer : observers)
+			observer.coinsUnloaded(this, coins);
+	}
+
+	/**
+	 * Connects an output channel to this coin dispenser. Any existing output
+	 * channels are disconnected. Causes no events to be announced.
+	 * <p>
+	 * This operation is only permissible during the configuration phase.
+	 * 
+	 * @param sink
+	 *            The new output device to act as output. Can be null, which leaves
+	 *            the channel without an output.
+	 */
+	public void connect(UnidirectionalChannel<Coin> sink) {
+		if(phase != Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may only be called during the configuration phase."));
+
+		this.sink = sink;
+	}
+
+	/**
+	 * Returns the maximum capacity of this coin dispenser.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 * 
+	 * @return The capacity. Will be positive.
+	 */
+	public int getCapacity() {
+		return maxCapacity;
+	}
+
+	/**
+	 * Causes the indicated coin to be added into the dispenser. If successful, a
+	 * "coinAdded" event is announced to its observers. If a successful coin
+	 * addition causes the dispenser to become full, a "coinsFull" event is
+	 * announced to its observers.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @throws DisabledException
+	 *             If the coin dispenser is currently disabled.
+	 * @throws SimulationException
+	 *             If coin is null.
+	 * @throws OverloadException
+	 *             If the coin dispenser is already full.
+	 */
+	@Override
+	public void accept(Coin coin) throws OverloadException, DisabledException {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		if(isDisabled())
+			throw new DisabledException();
+
+		if(coin == null)
+			throw new SimulationException(
+				new NullPointerException("coin is null, which has no analogue in the real world."));
+
+		if(queue.size() >= maxCapacity)
+			throw new OverloadException();
+
+		queue.add(coin);
+		notifyCoinAdded(coin);
+
+		if(queue.size() >= maxCapacity)
+			notifyCoinsFull();
+	}
+
+	/**
+	 * Releases a single coin from this coin dispenser. If successful, a
+	 * "coinRemoved" event is announced to its observers. If a successful coin
+	 * removal causes the dispenser to become empty, a "coinsEmpty" event is
+	 * announced to its observers.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @throws OverloadException
+	 *             If the output channel is unable to accept another coin.
+	 * @throws EmptyException
+	 *             If no coins are present in the dispenser to release.
+	 * @throws DisabledException
+	 *             If the dispenser is currently disabled.
+	 */
+	public void emit() throws OverloadException, EmptyException, DisabledException {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		if(isDisabled())
+			throw new DisabledException();
+
+		if(queue.size() == 0)
+			throw new EmptyException();
+
+		Coin coin = queue.remove();
+
+		notifyCoinRemoved(coin);
+		sink.deliver(coin);
+
+		if(queue.isEmpty())
+			notifyCoinsEmpty();
+	}
+
+	/**
+	 * Returns whether this coin dispenser has enough space to accept at least one
+	 * more coin. Announces no events.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 */
+	@Override
+	public boolean hasSpace() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		return queue.size() < maxCapacity;
+	}
+
+	private void notifyCoinAdded(Coin coin) {
+		for(CoinDispenserObserver observer : observers)
+			observer.coinAdded(this, coin);
+	}
+
+	private void notifyCoinRemoved(Coin coin) {
+		for(CoinDispenserObserver observer : observers)
+			observer.coinRemoved(this, coin);
+	}
+
+	private void notifyCoinsFull() {
+		for(CoinDispenserObserver observer : observers)
+			observer.coinsFull(this);
+	}
+
+	private void notifyCoinsEmpty() {
+		for(CoinDispenserObserver observer : observers)
+			observer.coinsEmpty(this);
+	}
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/CoinSlot.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/CoinSlot.java
new file mode 100644
index 0000000..514af14
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/CoinSlot.java	
@@ -0,0 +1,97 @@
+package org.lsmr.selfcheckout.devices;
+
+import org.lsmr.selfcheckout.Coin;
+import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
+import org.lsmr.selfcheckout.devices.observers.CoinSlotObserver;
+
+/**
+ * Represents a simple coin slot device that has one output channel. The slot is
+ * stupid: it has no functionality other than being enabled/disabled, and cannot
+ * determine the value and currency of the coin.
+ */
+public final class CoinSlot extends AbstractDevice<CoinSlotObserver> implements Acceptor<Coin> {
+	private UnidirectionalChannel<Coin> sink;
+
+	/**
+	 * Creates a coin slot.
+	 */
+	public CoinSlot() {}
+
+	/**
+	 * Connects channels to the coin slot. Causes no events.
+	 * <p>
+	 * This operation is permissible only during the configuration phase.
+	 * 
+	 * @param sink
+	 *            Where coins will always be passed.
+	 */
+	public void connect(UnidirectionalChannel<Coin> sink) {
+		if(phase != Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may only be called during the configuration phase."));
+
+		this.sink = sink;
+	}
+
+	/**
+	 * Tells the coin slot that the indicated coin is being inserted. If the slot is
+	 * enabled, this causes a "coinInserted" event to be announced to its observers.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @param coin
+	 *            The coin to be added. Cannot be null.
+	 * @throws DisabledException
+	 *             If the coin slot is currently disabled.
+	 * @throws SimulationException
+	 *             If coin is null.
+	 * @throws NullPointerException
+	 *             If the coin is null.
+	 */
+	public void accept(Coin coin) throws DisabledException {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		if(isDisabled())
+			throw new DisabledException();
+
+		if(coin == null)
+			throw new SimulationException(new NullPointerException("coin is null"));
+
+		notifyCoinInserted();
+
+		if(sink.hasSpace()) {
+			try {
+				sink.deliver(coin);
+			}
+			catch(OverloadException e) {
+				// Should never happen
+				phase = Phase.ERROR;
+				throw new SimulationException(e);
+			}
+		}
+		else
+			throw new SimulationException("Unable to route coin: Output channel is full");
+	}
+
+	@Override
+	public boolean hasSpace() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		return sink.hasSpace();
+	}
+
+	private void notifyCoinInserted() {
+		for(CoinSlotObserver observer : observers)
+			observer.coinInserted(this);
+	}
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/CoinStorageUnit.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/CoinStorageUnit.java
new file mode 100644
index 0000000..6fc0059
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/CoinStorageUnit.java	
@@ -0,0 +1,186 @@
+package org.lsmr.selfcheckout.devices;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+
+import org.lsmr.selfcheckout.Coin;
+import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
+import org.lsmr.selfcheckout.devices.observers.CoinStorageUnitObserver;
+
+/**
+ * Represents devices that store coins. They only receive coins, not dispense
+ * them. To access the coins inside, a human operator needs to physically remove
+ * the coins, simulated with the {@link #unload()} method. A
+ * {@link #load(Coin...)} method is provided for symmetry.
+ */
+public class CoinStorageUnit extends AbstractDevice<CoinStorageUnitObserver> implements Acceptor<Coin> {
+	private Coin[] storage;
+	private int nextIndex = 0;
+
+	/**
+	 * Creates a coin storage unit that can hold the indicated number of coins.
+	 * 
+	 * @param capacity
+	 *            The maximum number of coins that the unit can hold.
+	 * @throws SimulationException
+	 *             If the capacity is not positive.
+	 */
+	public CoinStorageUnit(int capacity) {
+		if(capacity <= 0)
+			throw new SimulationException(new IllegalArgumentException("The capacity must be positive."));
+
+		storage = new Coin[capacity];
+	}
+
+	/**
+	 * Gets the maximum number of coins that this storage unit can hold.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 * 
+	 * @return The capacity.
+	 */
+	public int getCapacity() {
+		return storage.length;
+	}
+
+	/**
+	 * Gets the current count of coins contained in this storage unit.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 * 
+	 * @return The current count.
+	 */
+	public int getCoinCount() {
+		return nextIndex;
+	}
+
+	/**
+	 * Allows a set of coins to be loaded into the storage unit directly. Existing
+	 * coins in the dispenser are not removed. Causes a "coinsLoaded" event to be
+	 * announced. Disabling has no effect on loading/unloading.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @param coins
+	 *            A sequence of coins to be added. Each cannot be null.
+	 * @throws SimulationException
+	 *             if the number of coins to be loaded exceeds the capacity of the
+	 *             unit.
+	 * @throws SimulationException
+	 *             If coins is null.
+	 * @throws SimulationException
+	 *             If any coin is null.
+	 * @throws OverloadException
+	 *             If too many coins are loaded.
+	 */
+	public void load(Coin... coins) throws SimulationException, OverloadException {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+
+		if(coins == null)
+			throw new SimulationException(
+				new NullPointerException("coins is null, which has no analogue in the real world."));
+
+		if(coins.length + nextIndex > storage.length)
+			throw new OverloadException("You tried to stuff too many coins in the storage unit.");
+
+		for(Coin coin : coins)
+			if(coin == null)
+				throw new SimulationException(new NullPointerException("No coin may be null"));
+
+		System.arraycopy(coins, 0, storage, nextIndex, coins.length);
+		nextIndex += coins.length;
+
+		notifyCoinsLoaded();
+	}
+
+	/**
+	 * Unloads coins from the storage unit directly. Causes a "coinsUnloaded" event
+	 * to be announced.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 * 
+	 * @return A list of the coins unloaded. May be empty. Will never be null.
+	 */
+	public List<Coin> unload() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+
+		List<Coin> coins = Arrays.asList(storage);
+
+		storage = new Coin[storage.length];
+		nextIndex = 0;
+		notifyCoinsUnloaded();
+
+		return coins;
+	}
+
+	/**
+	 * Causes the indicated coin to be added to the storage unit. If successful, a
+	 * "coinAdded" event is announced to its observers. If a successful coin
+	 * addition instead causes the unit to become full, a "coinsFull" event is
+	 * announced to its observers.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @throws DisabledException
+	 *             If the unit is currently disabled.
+	 * @throws SimulationException
+	 *             If coin is null.
+	 * @throws OverloadException
+	 *             If the unit is already full.
+	 */
+	public void accept(Coin coin) throws DisabledException, OverloadException {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		if(isDisabled())
+			throw new DisabledException();
+
+		if(coin == null)
+			throw new SimulationException(new NullPointerException("coin is null"));
+
+		if(nextIndex < storage.length) {
+			storage[nextIndex++] = coin;
+
+			if(nextIndex == storage.length)
+				notifyCoinsFull();
+			else
+				notifyCoinAdded();
+		}
+		else
+			throw new OverloadException();
+	}
+
+	@Override
+	public boolean hasSpace() {
+		return nextIndex < storage.length;
+	}
+
+	private void notifyCoinsLoaded() {
+		for(CoinStorageUnitObserver l : observers)
+			l.coinsLoaded(this);
+	}
+
+	private void notifyCoinsUnloaded() {
+		for(CoinStorageUnitObserver l : observers)
+			l.coinsUnloaded(this);
+	}
+
+	private void notifyCoinsFull() {
+		for(CoinStorageUnitObserver l : observers)
+			l.coinsFull(this);
+	}
+
+	private void notifyCoinAdded() {
+		for(CoinStorageUnitObserver l : observers)
+			l.coinAdded(this);
+	}
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/CoinTray.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/CoinTray.java
new file mode 100644
index 0000000..dabc9c3
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/CoinTray.java	
@@ -0,0 +1,102 @@
+package org.lsmr.selfcheckout.devices;
+
+import java.util.Arrays;
+import java.util.List;
+
+import org.lsmr.selfcheckout.Coin;
+import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
+import org.lsmr.selfcheckout.devices.observers.CoinTrayObserver;
+
+/**
+ * Simulates the tray where dispensed coins go for the user to collect them.
+ */
+public class CoinTray extends AbstractDevice<CoinTrayObserver> implements Acceptor<Coin> {
+	private Coin[] coins;
+	private int nextIndex = 0;
+
+	/**
+	 * Creates a coin tray.
+	 * 
+	 * @param capacity
+	 *            The maximum number of coins that this tray can hold without
+	 *            overflowing.
+	 * @throws SimulationException
+	 *             If the capacity is &le;0.
+	 */
+	public CoinTray(int capacity) {
+		if(capacity <= 0)
+			throw new SimulationException(new IllegalArgumentException("capacity must be positive."));
+
+		coins = new Coin[capacity];
+	}
+
+	/**
+	 * Causes the indicated coin to be added to the tray. A "coinAdded" event is
+	 * announced to observers.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @param coin
+	 *            The coin to add.
+	 * @throws SimulationException
+	 *             If coin is null.
+	 * @throws OverloadException
+	 *             If the tray overflows.
+	 */
+	public void accept(Coin coin) throws OverloadException, DisabledException {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		if(coin == null)
+			throw new SimulationException(
+				new NullPointerException("coin is null, which has no analogue in the real world."));
+
+		if(nextIndex < coins.length) {
+			coins[nextIndex++] = coin;
+			notifyCoinAdded();
+		}
+		else
+			throw new OverloadException("The tray has overflowed.");
+	}
+
+	/**
+	 * Simulates the act of physically removing coins from the try by a user.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @return The list of coins collected. May not be null. May be empty.
+	 */
+	public List<Coin> collectCoins() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		List<Coin> result = Arrays.asList(coins);
+
+		coins = new Coin[coins.length];
+		nextIndex = 0;
+
+		return result;
+	}
+
+	/**
+	 * Returns whether this coin receptacle has enough space to accept at least one
+	 * more coin: always true. Causes no events.
+	 */
+	@Override
+	public boolean hasSpace() {
+		return nextIndex < coins.length;
+	}
+
+	private void notifyCoinAdded() {
+		for(CoinTrayObserver l : observers)
+			l.coinAdded(this);
+	}
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/CoinValidator.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/CoinValidator.java
new file mode 100644
index 0000000..faf47e3
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/CoinValidator.java	
@@ -0,0 +1,268 @@
+package org.lsmr.selfcheckout.devices;
+
+import java.math.BigDecimal;
+import java.util.Collections;
+import java.util.Currency;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Random;
+
+import org.lsmr.selfcheckout.Coin;
+import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
+import org.lsmr.selfcheckout.devices.observers.CoinValidatorObserver;
+
+/**
+ * Represents a device for optically and/or physically validating coins. Coins
+ * deemed valid are moved to storage; coins deemed invalid are ejected.
+ */
+public final class CoinValidator extends AbstractDevice<CoinValidatorObserver> implements Acceptor<Coin> {
+	public final Currency currency;
+	private List<BigDecimal> denominations;
+	private UnidirectionalChannel<Coin> rejectionSink, overflowSink;
+	private Map<BigDecimal, UnidirectionalChannel<Coin>> standardSinks = null;
+
+	/**
+	 * Creates a coin validator that recognizes coins of the specified denominations
+	 * (i.e., values) and currency.
+	 * 
+	 * @param currency
+	 *            The kind of currency to accept.
+	 * @param denominations
+	 *            An array of the valid coin denominations (like $0.05, $0.10, etc.)
+	 *            to accept. Each value must be &gt;0 and unique in this array.
+	 * @throws SimulationException
+	 *             If either argument is null.
+	 * @throws SimulationException
+	 *             If the denominations array does not contain at least one value.
+	 * @throws SimulationException
+	 *             If any value in the denominations array is non-positive.
+	 * @throws SimulationException
+	 *             If any value in the denominations array is non-unique.
+	 */
+	public CoinValidator(Currency currency, List<BigDecimal> denominations) {
+		if(currency == null)
+			throw new SimulationException(
+				new NullPointerException("currency is null, which has no analogue in the real world."));
+
+		if(denominations == null)
+			throw new SimulationException(
+				new NullPointerException("denominations is null, which has no analogue in the real world."));
+
+		if(denominations.size() < 1)
+			throw new SimulationException(new IllegalArgumentException("There must be at least one denomination."));
+
+		this.currency = currency;
+		Collections.sort(denominations);
+
+		standardSinks = new HashMap<>();
+
+		for(BigDecimal denomination : denominations) {
+			if(denomination == null)
+				throw new SimulationException(new NullPointerException("A denomination is null"));
+
+			if(denomination.compareTo(BigDecimal.ZERO) <= 0)
+				throw new SimulationException(
+					new IllegalArgumentException("Non-positive denomination detected: " + denomination + "."));
+
+			if(standardSinks.containsKey(denomination))
+				throw new SimulationException(new IllegalArgumentException(
+					"Each denomination must be unique, but " + denomination + " is repeated."));
+
+			standardSinks.put(denomination, null);
+		}
+
+		this.denominations = denominations;
+	}
+
+	/**
+	 * Connects input and output channels to the coin slot. Causes no events.
+	 * <p>
+	 * This operation is permissible only during the configuration phase.
+	 * 
+	 * @param rejectionSink
+	 *            The channel to which rejected coins are routed.
+	 * @param overflowSink
+	 *            The channel to which valid coins are routed when the normal sink
+	 *            is full.
+	 * @param standardSinks
+	 *            The channels to which valid coins are normally routed. There must
+	 *            be one sink to correspond to each valid currency denomination, and
+	 *            they must be in the same order as the valid denominations.
+	 * @throws SimulationException
+	 *             If any argument is null.
+	 * @throws SimulationException
+	 *             If any standard sink is null.
+	 * @throws SimulationException
+	 *             If the number of standard sinks differs from the number of
+	 *             denominations.
+	 * @throws SimulationException
+	 *             If any sink is used in more than one position.
+	 */
+	public void connect(UnidirectionalChannel<Coin> rejectionSink,
+		Map<BigDecimal, UnidirectionalChannel<Coin>> standardSinks, UnidirectionalChannel<Coin> overflowSink) {
+		if(phase != Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may only be called during the configuration phase."));
+
+		if(rejectionSink == null)
+			throw new SimulationException(
+				new NullPointerException("rejectionSink is null, which has no analogue in the real world."));
+
+		if(overflowSink == null)
+			throw new SimulationException(
+				new NullPointerException("overflowSink is null, which has no analogue in the real world."));
+
+		if(standardSinks == null)
+			throw new SimulationException(
+				new NullPointerException("standardSinks is null, which has no analogue in the real world."));
+
+		if(standardSinks.keySet().size() != denominations.size())
+			throw new SimulationException(
+				new IllegalArgumentException("The number of standard sinks must equal the number of denominations."));
+
+		this.rejectionSink = rejectionSink;
+		this.overflowSink = overflowSink;
+
+		HashSet<UnidirectionalChannel<Coin>> set = new HashSet<>();
+
+		for(BigDecimal denomination : standardSinks.keySet()) {
+			UnidirectionalChannel<Coin> sink = standardSinks.get(denomination);
+			if(sink == null)
+				throw new SimulationException(
+					new NullPointerException("The sink for denomination " + denomination + " is null."));
+			else {
+				if(set.contains(sink))
+					throw new SimulationException(new IllegalArgumentException("Each channel must be unique."));
+
+				set.add(sink);
+			}
+		}
+
+		this.standardSinks = standardSinks;
+
+		if(set.contains(rejectionSink))
+			throw new SimulationException(new IllegalArgumentException("Each channel must be unique."));
+		else
+			set.add(rejectionSink);
+
+		if(set.contains(overflowSink))
+			throw new SimulationException(new IllegalArgumentException("Each channel must be unique."));
+
+		this.overflowSink = overflowSink;
+	}
+
+	private final Random pseudoRandomNumberGenerator = new Random();
+	private static final int PROBABILITY_OF_FALSE_REJECTION = 1; /* out of 100 */
+
+	private boolean isValid(Coin coin) {
+		if(currency.equals(coin.getCurrency()))
+			for(BigDecimal denomination : denominations)
+				if(denomination.equals(coin.getValue()))
+					return pseudoRandomNumberGenerator.nextInt(100) >= PROBABILITY_OF_FALSE_REJECTION;
+
+		return false;
+	}
+
+	/**
+	 * Tells the coin validator that the indicated coin is being inserted. If the
+	 * coin is valid, a "validCoinDetected" event is announced to its observers;
+	 * otherwise, an "invalidCoinDetected" event is announced to its observers.
+	 * <p>
+	 * If there is space in the machine to store a valid coin, it is passed to the
+	 * sink channel corresponding to the denomination of the coin.
+	 * </p>
+	 * <p>
+	 * If there is no space in the machine to store it or the coin is invalid, the
+	 * coin is ejected to the source.
+	 * </p>
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @param coin
+	 *            The coin to be added. Cannot be null.
+	 * @throws DisabledException
+	 *             if the coin validator is currently disabled.
+	 * @throws SimulationException
+	 *             If the coin is null.
+	 * @throws SimulationException
+	 *             If the coin cannot be delivered.
+	 */
+	public void accept(Coin coin) throws DisabledException {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		if(isDisabled())
+			throw new DisabledException();
+
+		if(coin == null)
+			throw new SimulationException(
+				new NullPointerException("coin is null, which has no analogue in the real world."));
+
+		if(isValid(coin)) {
+			notifyValidCoinDetected(coin);
+
+			UnidirectionalChannel<Coin> sink = standardSinks.get(coin.getValue());
+
+			if(sink.hasSpace()) {
+				try {
+					sink.deliver(coin);
+				}
+				catch(OverloadException e) {
+					// Should never happen
+					phase = Phase.ERROR;
+					throw new SimulationException(e);
+				}
+			}
+			else {
+				try {
+					rejectionSink.deliver(coin);
+				}
+				catch(OverloadException e) {
+					// Should never happen
+					phase = Phase.ERROR;
+					throw new SimulationException(e);
+				}
+			}
+		}
+		else {
+			notifyInvalidCoinDetected(coin);
+
+			try {
+				rejectionSink.deliver(coin);
+			}
+			catch(OverloadException e) {
+				// Should never happen
+				phase = Phase.ERROR;
+				throw new SimulationException(e);
+			}
+		}
+	}
+
+	@Override
+	public boolean hasSpace() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		return true; // Since we cannot know yet where a coin will route, assume that it is OK.
+	}
+
+	private void notifyValidCoinDetected(Coin coin) {
+		for(CoinValidatorObserver observer : observers)
+			observer.validCoinDetected(this, coin.getValue());
+	}
+
+	private void notifyInvalidCoinDetected(Coin coin) {
+		for(CoinValidatorObserver observer : observers)
+			observer.invalidCoinDetected(this);
+	}
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/DisabledException.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/DisabledException.java
new file mode 100644
index 0000000..6f1690f
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/DisabledException.java	
@@ -0,0 +1,8 @@
+package org.lsmr.selfcheckout.devices;
+
+/**
+ * Issued when a device cannot perform its usual functions because it has been
+ * disabled.
+ */
+@SuppressWarnings("serial")
+public class DisabledException extends Exception {}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/ElectronicScale.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/ElectronicScale.java
new file mode 100644
index 0000000..ffdc112
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/ElectronicScale.java	
@@ -0,0 +1,171 @@
+package org.lsmr.selfcheckout.devices;
+
+import java.util.ArrayList;
+
+import org.lsmr.selfcheckout.Item;
+import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
+import org.lsmr.selfcheckout.devices.observers.ElectronicScaleObserver;
+
+public class ElectronicScale extends AbstractDevice<ElectronicScaleObserver> {
+	private ArrayList<Item> items = new ArrayList<>();
+
+	private double weightLimitInGrams;
+	private double currentWeightInGrams = 0;
+	private double weightAtLastEvent = 0;
+	private double sensitivity;
+
+	/**
+	 * Constructs an electronic scale with the indicated maximum weight that it can
+	 * handle before going into overload.
+	 * 
+	 * @param weightLimitInGrams
+	 *            The weight threshold beyond which the scale will overload.
+	 * @param sensitivity
+	 *            The number of grams that can be added or removed since the last
+	 *            change event, without causing a new change event.
+	 * @throws SimulationException
+	 *             If either argument is &le;0.
+	 */
+	public ElectronicScale(int weightLimitInGrams, int sensitivity) {
+		if(weightLimitInGrams <= 0)
+			throw new SimulationException(new IllegalArgumentException("The maximum weight cannot be zero or less."));
+
+		if(sensitivity <= 0)
+			throw new SimulationException(new IllegalArgumentException("The sensitivity cannot be zero or less."));
+
+		this.weightLimitInGrams = weightLimitInGrams;
+		this.sensitivity = sensitivity;
+	}
+
+	/**
+	 * Gets the weight limit for the scale.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 * 
+	 * @return The weight limit.
+	 */
+	public double getWeightLimit() {
+		return weightLimitInGrams;
+	}
+
+	/**
+	 * Gets the current weight on the scale.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @return The current weight.
+	 * @throws OverloadException
+	 *             If the weight has overloaded the scale.
+	 */
+	public double getCurrentWeight() throws OverloadException {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		if(currentWeightInGrams <= weightLimitInGrams)
+			return currentWeightInGrams;
+
+		throw new OverloadException();
+	}
+
+	/**
+	 * Gets the sensitivity of the scale. Changes smaller than this limit are not
+	 * noticed or announced.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 * 
+	 * @return The sensitivity.
+	 */
+	public double getSensitivity() {
+		return sensitivity;
+	}
+
+	/**
+	 * Adds an item to the scale.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @param item
+	 *            The item to add.
+	 * @throws SimulationException
+	 *             If the same item is added more than once.
+	 */
+	public void add(Item item) {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		if(items.contains(item))
+			throw new SimulationException("The same item cannot be added more than once to the scale.");
+
+		currentWeightInGrams += item.getWeight();
+
+		items.add(item);
+
+		if(currentWeightInGrams > weightLimitInGrams)
+			notifyOverload();
+		else if(currentWeightInGrams - weightAtLastEvent > sensitivity)
+			notifyWeightChanged();
+	}
+
+	/**
+	 * Removes an item from the scale.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @param item
+	 *            The item to remove.
+	 * @throws SimulationException
+	 *             If the item is not on the scale.
+	 */
+	public void remove(Item item) {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		if(!items.remove(item))
+			throw new SimulationException("The item was not found amongst those on the scale.");
+
+		// To avoid drift in the sum due to round-off error, recalculate the weight.
+		double newWeightInGrams = 0.0;
+		for(Item itemOnScale : items)
+			newWeightInGrams += itemOnScale.getWeight();
+
+		double original = currentWeightInGrams;
+		currentWeightInGrams = newWeightInGrams;
+
+		if(original > weightLimitInGrams && newWeightInGrams <= weightLimitInGrams)
+			notifyOutOfOverload();
+
+		if(currentWeightInGrams <= weightLimitInGrams && weightAtLastEvent - currentWeightInGrams >= sensitivity)
+			notifyWeightChanged();
+	}
+
+	private void notifyOverload() {
+		for(ElectronicScaleObserver l : observers)
+			l.overload(this);
+	}
+
+	private void notifyOutOfOverload() {
+		weightAtLastEvent = currentWeightInGrams;
+
+		for(ElectronicScaleObserver l : observers)
+			l.outOfOverload(this);
+	}
+
+	private void notifyWeightChanged() {
+		weightAtLastEvent = currentWeightInGrams;
+
+		for(ElectronicScaleObserver l : observers)
+			l.weightChanged(this, currentWeightInGrams);
+	}
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/Emitter.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/Emitter.java
new file mode 100644
index 0000000..a8ab600
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/Emitter.java	
@@ -0,0 +1,12 @@
+package org.lsmr.selfcheckout.devices;
+
+import org.lsmr.selfcheckout.Coin;
+
+/**
+ * A simple base interface for devices that emit things.
+ * 
+ * @param <T>
+ *            The type of the things to emit.
+ */
+public interface Emitter<T> {
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/EmptyException.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/EmptyException.java
new file mode 100644
index 0000000..b726903
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/EmptyException.java	
@@ -0,0 +1,9 @@
+package org.lsmr.selfcheckout.devices;
+
+/**
+ * Represents the situation when a device is emptied but an attempt is made to
+ * remove something from it.
+ */
+public class EmptyException extends Exception {
+	private static final long serialVersionUID = 3566954386000387724L;
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/FlowThroughEmitter.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/FlowThroughEmitter.java
new file mode 100644
index 0000000..ff60458
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/FlowThroughEmitter.java	
@@ -0,0 +1,26 @@
+package org.lsmr.selfcheckout.devices;
+
+import org.lsmr.selfcheckout.Coin;
+
+/**
+ * A simple interface for devices that emit things.
+ * 
+ * @param <T>
+ *            The type of the things to emit.
+ */
+public interface FlowThroughEmitter<T> {
+	/**
+	 * Instructs the device to emit a specific thing, meaning that the device is
+	 * being handed this thing to pass onwards.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @param thing
+	 *            The thing to emit.
+	 * @throws DisabledException
+	 *             If the device is disabled.
+	 * @throws OverloadException
+	 *             If the receiving device is already full.
+	 */
+	public void emit(T thing) throws DisabledException, OverloadException;
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/FromStorageEmitter.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/FromStorageEmitter.java
new file mode 100644
index 0000000..ddb964a
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/FromStorageEmitter.java	
@@ -0,0 +1,26 @@
+package org.lsmr.selfcheckout.devices;
+
+import org.lsmr.selfcheckout.Coin;
+
+/**
+ * A simple interface for devices that emit things.
+ * 
+ * @param <T>
+ *            The type of the things to emit.
+ */
+public interface FromStorageEmitter<T> {
+	/**
+	 * Instructs the device to emit one thing, meaning that the device stores a set
+	 * of things and one of them is to be emitted.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @throws DisabledException
+	 *             If the device is disabled.
+	 * @throws EmptyException
+	 *             If the device is empty and cannot emit.
+	 * @throws OverloadException
+	 *             If the receiving device is already full.
+	 */
+	public void emit() throws DisabledException, EmptyException, OverloadException;
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/OverloadException.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/OverloadException.java
new file mode 100644
index 0000000..ee5e927
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/OverloadException.java	
@@ -0,0 +1,24 @@
+package org.lsmr.selfcheckout.devices;
+
+/**
+ * Represents situations where a device has been overloaded, in terms of weight,
+ * quantity of items, etc.
+ */
+public class OverloadException extends Exception {
+	private static final long serialVersionUID = 7813659161520664284L;
+
+	/**
+	 * Create an exception without an error message.
+	 */
+	public OverloadException() {}
+
+	/**
+	 * Create an exception with an error message.
+	 * 
+	 * @param message
+	 *            The error message to use.
+	 */
+	public OverloadException(String message) {
+		super(message);
+	}
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/ReceiptPrinter.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/ReceiptPrinter.java
new file mode 100644
index 0000000..9f2abe6
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/ReceiptPrinter.java	
@@ -0,0 +1,204 @@
+package org.lsmr.selfcheckout.devices;
+
+import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
+import org.lsmr.selfcheckout.devices.observers.ReceiptPrinterObserver;
+
+/**
+ * Represents printers used for printing receipts. A printer has a finite amount
+ * of paper (measured in lines that can be printed) and ink (measured in
+ * characters that can be printed).
+ * <p>
+ * Since this is a simulation, each character is assumed to require the same
+ * amount of ink (except blanks and newlines) and the font size is fixed.
+ * </p>
+ */
+public class ReceiptPrinter extends AbstractDevice<ReceiptPrinterObserver> {
+	public static final int MAXIMUM_INK = 1 << 20;
+	public static final int MAXIMUM_PAPER = 1 << 10;
+	private int charactersOfInkRemaining = 0;
+	private int linesOfPaperRemaining = 0;
+	private StringBuilder sb = new StringBuilder();
+	private int charactersOnCurrentLine = 0;
+
+	/**
+	 * Represents the maximum number of characters that can fit on one line of the
+	 * receipt. This is a simulation, so the font is assumed monospaced and of fixed
+	 * size.
+	 */
+	public final static int CHARACTERS_PER_LINE = 60;
+
+	/**
+	 * Creates a receipt printer.
+	 */
+	public ReceiptPrinter() {}
+
+	/**
+	 * Prints a single character to the receipt. Whitespace characters are ignored,
+	 * with the exception of ' ' (blank) and '\n', which signals to move to the
+	 * start of the next line.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @param c
+	 *            The character to print.
+	 * @throws SimulationException
+	 *             If there is no ink or no paper in the printer.
+	 * @throws SimulationException
+	 *             If the extra character would spill off the end of the line.
+	 */
+	public void print(char c) {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		if(c == '\n') {
+			--linesOfPaperRemaining;
+			charactersOnCurrentLine = 0;
+		}
+		else if(c != ' ' && Character.isWhitespace(c))
+			return;
+		else if(charactersOnCurrentLine == CHARACTERS_PER_LINE)
+			throw new SimulationException("The line is too long. Add a newline");
+		else if(linesOfPaperRemaining == 0)
+			throw new SimulationException("There is no paper in the printer.");
+		else
+			charactersOnCurrentLine++;
+
+		if(!Character.isWhitespace(c)) {
+			if(charactersOfInkRemaining == 0)
+				throw new SimulationException("There is no ink in the printer");
+
+			charactersOfInkRemaining--;
+		}
+
+		sb.append(c);
+
+		if(charactersOfInkRemaining == 0)
+			notifyOutOfInk();
+
+		if(linesOfPaperRemaining == 0)
+			notifyOutOfPaper();
+	}
+
+	/**
+	 * The receipt is finished printing, so cut it so that the customer can easily
+	 * remove it. Failure to cut the paper means that the receipt will not be
+	 * retrievable by the customer.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 */
+	public void cutPaper() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		lastReceipt = sb.toString();
+	}
+
+	private String lastReceipt = null;
+
+	/**
+	 * Simulates the customer removing the receipt. Failure to cut the receipt
+	 * first, or to always remove the receipt means that the customer will end up
+	 * with other customers' receipts too!
+	 * 
+	 * @return The receipt if it has been cut; otherwise, null.
+	 */
+	public String removeReceipt() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		String receipt = lastReceipt;
+
+		if(lastReceipt != null) {
+			lastReceipt = null;
+			sb = new StringBuilder();
+		}
+		else
+			throw new SimulationException("A non-existent receipt cannot be removed.");
+
+		return receipt;
+	}
+
+	/**
+	 * Adds ink to the printer. Simulates a human doing the adding.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 * 
+	 * @param quantity
+	 *            The quantity of characters-worth of ink to add.
+	 * @throws SimulationException
+	 *             If the quantity is negative.
+	 * @throws SimulationException
+	 *             If the total of the existing ink plus the added quantity is
+	 *             greater than the printer's capacity.
+	 */
+	public void addInk(int quantity) {
+		if(quantity < 0)
+			throw new SimulationException("Are you trying to remove ink?");
+
+		if(charactersOfInkRemaining + quantity > MAXIMUM_INK)
+			throw new SimulationException("You spilled a bunch of ink!");
+
+		if(quantity > 0) {
+			charactersOfInkRemaining += quantity;
+			notifyInkAdded();
+		}
+	}
+
+	/**
+	 * Adds paper to the printer. Simulates a human doing the adding.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 * 
+	 * @param quantity
+	 *            The quantity of lines-worth of paper to add.
+	 * @throws SimulationException
+	 *             If the quantity is negative.
+	 * @throws SimulationException
+	 *             If the total of the existing paper plus the added quantity is
+	 *             greater than the printer's capacity.
+	 */
+	public void addPaper(int units) {
+		if(units < 0)
+			throw new SimulationException("Are you trying to remove paper?");
+
+		if(linesOfPaperRemaining + units > MAXIMUM_PAPER)
+			throw new SimulationException("You may have broken the printer, jamming so much in there!");
+
+		if(units > 0) {
+			linesOfPaperRemaining += units;
+			notifyPaperAdded();
+		}
+	}
+
+	private void notifyOutOfInk() {
+		for(ReceiptPrinterObserver l : observers)
+			l.outOfInk(this);
+	}
+
+	private void notifyInkAdded() {
+		for(ReceiptPrinterObserver l : observers)
+			l.inkAdded(this);
+	}
+
+	private void notifyOutOfPaper() {
+		for(ReceiptPrinterObserver l : observers)
+			l.outOfPaper(this);
+	}
+
+	private void notifyPaperAdded() {
+		for(ReceiptPrinterObserver l : observers)
+			l.paperAdded(this);
+	}
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/SelfCheckoutStation.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/SelfCheckoutStation.java
new file mode 100644
index 0000000..edb9a0c
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/SelfCheckoutStation.java	
@@ -0,0 +1,257 @@
+package org.lsmr.selfcheckout.devices;
+
+import java.math.BigDecimal;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Currency;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+import javax.sound.sampled.AudioSystem;
+
+import org.lsmr.selfcheckout.Banknote;
+import org.lsmr.selfcheckout.Coin;
+
+/**
+ * Simulates the overall self-checkout station.
+ * <p>
+ * A self-checkout possesses the following units of hardware that the customer
+ * can see and interact with:
+ * <ul>
+ * <li>one electronic scale, with a configurable maximum weight before it
+ * overloads;</li>
+ * <li>one receipt printer;</li>
+ * <li>one card reader;</li>
+ * <li>one scanner;</li>
+ * <li>one input slot for banknotes;</li>
+ * <li>one output slot for banknotes;</li>
+ * <li>one input slot for coins;</li>
+ * <li>one output tray for coins; and,</li>
+ * <li>one speaker for audio output (note: you should directly use the
+ * {@link AudioSystem} class, if you want to produce sounds).</li>
+ * </ul>
+ * </p>
+ * <p>
+ * In addition, these units of hardware are accessible to personnel with a key
+ * to unlock the front of the station:
+ * <li>one banknote storage unit, with configurable capacity;</li>
+ * <li>one or more banknote dispensers, one for each supported denomination of
+ * banknote, as configured;</li>
+ * <li>one coin storage unit, with configurable capacity; and,</li>
+ * <li>one or more coin dispensers, one for each supported denomination of coin,
+ * as configured.</li>
+ * </ul>
+ * </p>
+ * <p>
+ * And finally, there are certain, additional units of hardware that would only
+ * be accessible to someone with the appropriate tools (like a screwdriver,
+ * crowbar, or sledge hammer):
+ * <ul>
+ * <li>one banknote validator; and</li>
+ * <li>one coin validator.</li>
+ * </ul>
+ * </p>
+ * <p>
+ * Many of these devices are interconnected, to permit coins or banknotes to
+ * pass between them. Specifically:
+ * <ul>
+ * <li>the coin slot is connected to the coin validator (this is a
+ * one-directional chain of devices);</li>
+ * <li>the coin validator is connected to each of the coin dispensers (i.e., the
+ * coin dispensers can be replenished with coins entered by customers), to the
+ * coin storage unit (for any overflow coins that do not fit in the dispensers),
+ * and to the coin tray for any rejected coins either because the coins are
+ * invalid or because even the overflow storage unit is full (this is a
+ * one-directional chain of devices);
+ * <li>each coin dispenser is connected to the coin tray, to provide change
+ * (this is a one-directional chain of devices);</li>
+ * <li>the banknote input slot is connected to the banknote validator (this is a
+ * <b>two</b>-directional chain of devices as an entered banknotes that are
+ * rejected by the validator can be returned to the customer);</li>
+ * <li>the banknote validator is connected to the banknote storage unit (this is
+ * a one-directional chain of devices); and,</li>
+ * <li>each banknote dispenser is connected to the output banknote slot; these
+ * dispensers cannot be replenished by banknotes provided by customers (this is
+ * a one-directional chain of devices).</li>
+ * </ul>
+ * </p>
+ * <p>
+ * All other functionality of the system must be performed in software,
+ * installed on the self-checkout station through custom observer classes
+ * implementing the various observer interfaces provided.
+ * </p>
+ * <p>
+ * Note that banknote denominations are required to be positive integers, while
+ * coin denominations are positive decimal values ({@link BigDecimal} is used
+ * for the latter to avoid roundoff problems arising from floating-point
+ * operations).
+ */
+public class SelfCheckoutStation {
+	public final ElectronicScale scale;
+	public final ReceiptPrinter printer;
+	public final CardReader cardReader;
+	public final BarcodeScanner scanner;
+
+	public final BanknoteSlot banknoteInput, banknoteOutput;
+	public final BanknoteValidator banknoteValidator;
+	public final BanknoteStorageUnit banknoteStorage;
+	public final static int BANKNOTE_STORAGE_CAPACITY = 1000;
+	public final int[] banknoteDenominations;
+	public final Map<Integer, BanknoteDispenser> banknoteDispensers;
+	public final static int BANKNOTE_DISPENSER_CAPACITY = 100;
+
+	public final CoinSlot coinSlot;
+	public final CoinValidator coinValidator;
+	public final CoinStorageUnit coinStorage;
+	public static final int COIN_STORAGE_CAPACITY = 1000;
+	public final List<BigDecimal> coinDenominations;
+	public final Map<BigDecimal, CoinDispenser> coinDispensers;
+	public static final int COIN_DISPENSER_CAPACITY = 200;
+	public final CoinTray coinTray;
+	public static final int COIN_TRAY_CAPACITY = 20;
+
+	/**
+	 * Creates a self-checkout station.
+	 * 
+	 * @param currency
+	 *            The kind of currency permitted.
+	 * @param banknoteDenominations
+	 *            The set of denominations (i.e., $5, $10, etc.) to accept.
+	 * @param coinDenominations
+	 *            The set of denominations (i.e., $0.05, $0.10, etc.) to accept.
+	 * @param scaleMaximumWeight
+	 *            The most weight that can be placed on the scale before it
+	 *            overloads.
+	 * @param scaleSensitivity
+	 *            Any weight changes smaller than this will not be detected or
+	 *            announced.
+	 * @throws SimulationException
+	 *             If any argument is null or negative.
+	 * @throws SimulationException
+	 *             If the number of banknote or coin denominations is &lt;1.
+	 */
+	public SelfCheckoutStation(Currency currency, int[] banknoteDenominations, BigDecimal[] coinDenominations,
+		int scaleMaximumWeight, int scaleSensitivity) {
+		if(currency == null || banknoteDenominations == null || coinDenominations == null)
+			throw new SimulationException(new NullPointerException("No argument may be null."));
+
+		if(scaleMaximumWeight <= 0)
+			throw new SimulationException(new IllegalArgumentException("The scale's maximum weight must be positive."));
+
+		if(scaleSensitivity <= 0)
+			throw new SimulationException(new IllegalArgumentException("The scale's sensitivity must be positive."));
+
+		if(banknoteDenominations.length == 0)
+			throw new SimulationException(
+				new IllegalArgumentException("There must be at least one allowable banknote denomination defined."));
+
+		if(coinDenominations.length == 0)
+			throw new SimulationException(
+				new IllegalArgumentException("There must be at least one allowable coin denomination defined."));
+
+		// Create the devices.
+		scale = new ElectronicScale(scaleMaximumWeight, scaleSensitivity);
+		printer = new ReceiptPrinter();
+		cardReader = new CardReader();
+		scanner = new BarcodeScanner();
+
+		this.banknoteDenominations = banknoteDenominations;
+		banknoteInput = new BanknoteSlot(false);
+		banknoteValidator = new BanknoteValidator(currency, banknoteDenominations);
+		banknoteStorage = new BanknoteStorageUnit(BANKNOTE_STORAGE_CAPACITY);
+		banknoteOutput = new BanknoteSlot(true);
+
+		banknoteDispensers = new HashMap<>();
+
+		for(int i = 0; i < banknoteDenominations.length; i++)
+			banknoteDispensers.put(banknoteDenominations[i], new BanknoteDispenser(BANKNOTE_DISPENSER_CAPACITY));
+
+		this.coinDenominations = Arrays.asList(coinDenominations);
+		coinSlot = new CoinSlot();
+		coinValidator = new CoinValidator(currency, this.coinDenominations);
+		coinStorage = new CoinStorageUnit(COIN_STORAGE_CAPACITY);
+		coinTray = new CoinTray(COIN_TRAY_CAPACITY);
+
+		coinDispensers = new HashMap<>();
+
+		for(int i = 0; i < coinDenominations.length; i++)
+			coinDispensers.put(coinDenominations[i], new CoinDispenser(COIN_DISPENSER_CAPACITY));
+
+		// Hook up everything.
+		interconnect(banknoteInput, banknoteValidator);
+		interconnect(banknoteValidator, banknoteStorage);
+
+		for(BanknoteDispenser dispenser : banknoteDispensers.values())
+			interconnect(dispenser, banknoteOutput);
+
+		interconnect(coinSlot, coinValidator);
+		interconnect(coinValidator, coinTray, coinDispensers, coinStorage);
+
+		for(CoinDispenser coinDispenser : coinDispensers.values())
+			interconnect(coinDispenser, coinTray);
+
+		scale.endConfigurationPhase();
+		printer.endConfigurationPhase();
+		cardReader.endConfigurationPhase();
+		scanner.endConfigurationPhase();
+
+		banknoteInput.endConfigurationPhase();
+		banknoteValidator.endConfigurationPhase();
+		banknoteStorage.endConfigurationPhase();
+		banknoteOutput.endConfigurationPhase();
+
+		for(BanknoteDispenser bd : banknoteDispensers.values())
+			bd.endConfigurationPhase();
+
+		coinSlot.endConfigurationPhase();
+		coinValidator.endConfigurationPhase();
+		coinStorage.endConfigurationPhase();
+		coinTray.endConfigurationPhase();
+
+		for(CoinDispenser cd : coinDispensers.values())
+			cd.endConfigurationPhase();
+	}
+
+	private BidirectionalChannel<Banknote> validatorSource;
+
+	private void interconnect(BanknoteSlot slot, BanknoteValidator validator) {
+		validatorSource = new BidirectionalChannel<Banknote>(slot, validator);
+		slot.connect(validatorSource);
+	}
+
+	private void interconnect(BanknoteValidator validator, BanknoteStorageUnit storage) {
+		UnidirectionalChannel<Banknote> bc = new UnidirectionalChannel<Banknote>(storage);
+		validator.connect(validatorSource, bc);
+	}
+
+	private void interconnect(BanknoteDispenser dispenser, BanknoteSlot slot) {
+		UnidirectionalChannel<Banknote> bc = new UnidirectionalChannel<Banknote>(slot);
+		dispenser.connect(bc);
+	}
+
+	private void interconnect(CoinSlot slot, CoinValidator validator) {
+		UnidirectionalChannel<Coin> cc = new UnidirectionalChannel<Coin>(validator);
+		slot.connect(cc);
+	}
+
+	private void interconnect(CoinValidator validator, CoinTray tray, Map<BigDecimal, CoinDispenser> dispensers,
+		CoinStorageUnit storage) {
+		UnidirectionalChannel<Coin> rejectChannel = new UnidirectionalChannel<Coin>(tray);
+		Map<BigDecimal, UnidirectionalChannel<Coin>> dispenserChannels = new HashMap<BigDecimal, UnidirectionalChannel<Coin>>();
+
+		for(BigDecimal denomination : dispensers.keySet()) {
+			CoinDispenser dispenser = dispensers.get(denomination);
+			dispenserChannels.put(denomination, new UnidirectionalChannel<Coin>(dispenser));
+		}
+
+		UnidirectionalChannel<Coin> overflowChannel = new UnidirectionalChannel<Coin>(storage);
+
+		validator.connect(rejectChannel, dispenserChannels, overflowChannel);
+	}
+
+	private void interconnect(CoinDispenser dispenser, CoinTray tray) {
+		UnidirectionalChannel<Coin> cc = new UnidirectionalChannel<Coin>(tray);
+		dispenser.connect(cc);
+	}
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/SimulationException.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/SimulationException.java
new file mode 100644
index 0000000..5ef08ac
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/SimulationException.java	
@@ -0,0 +1,32 @@
+package org.lsmr.selfcheckout.devices;
+
+/**
+ * An exception that can be raised when the behaviour within the simulator makes
+ * no sense, typically when it has not been configured correctly. This is
+ * different from an exception being raised because the preconditions of a
+ * component are violated, but that would make sense in the real world.
+ */
+@SuppressWarnings("serial")
+public class SimulationException extends RuntimeException {
+	private String nested;
+
+	/**
+	 * Constructor used to nest other exceptions.
+	 * 
+	 * @param nested
+	 *            An underlying exception that is to be wrapped.
+	 */
+	public SimulationException(Exception nested) {
+		this.nested = nested.toString();
+	}
+
+	/**
+	 * Basic constructor.
+	 * 
+	 * @param message
+	 *            An explanatory message of the problem.
+	 */
+	public SimulationException(String message) {
+		nested = message;
+	}
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/UnidirectionalChannel.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/UnidirectionalChannel.java
new file mode 100644
index 0000000..0174032
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/UnidirectionalChannel.java	
@@ -0,0 +1,49 @@
+package org.lsmr.selfcheckout.devices;
+
+import org.lsmr.selfcheckout.Coin;
+
+/**
+ * Represents a simple device (like, say, a tube) that allows things to move in
+ * one direction between other devices.
+ * 
+ * @param <T>
+ *            The type of the things to be transported.
+ */
+public class UnidirectionalChannel<T> {
+	private Acceptor<T> sink;
+
+	/**
+	 * Constructs a new coin channel whose output is connected to the indicated
+	 * sink.
+	 * 
+	 * @param sink
+	 *            The device at the output end of the channel.
+	 */
+	public UnidirectionalChannel(Acceptor<T> sink) {
+		this.sink = sink;
+	}
+
+	/**
+	 * Moves the indicated thing to the sink. This method should be called by the
+	 * source device, and not by an external application.
+	 * 
+	 * @param thing
+	 *            The thing to transport via the channel.
+	 * @throws OverloadException
+	 *             If the sink has no space for the thing.
+	 * @throws DisabledException
+	 *             If the sink is currently disabled.
+	 */
+	public void deliver(T thing) throws OverloadException, DisabledException {
+		sink.accept(thing);
+	}
+
+	/**
+	 * Returns whether the sink has space for at least one more thing.
+	 * 
+	 * @return true if the channel can accept a thing; false otherwise.
+	 */
+	public boolean hasSpace() {
+		return sink.hasSpace();
+	}
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/AbstractDeviceObserver.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/AbstractDeviceObserver.java
new file mode 100644
index 0000000..ced7820
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/AbstractDeviceObserver.java	
@@ -0,0 +1,26 @@
+package org.lsmr.selfcheckout.devices.observers;
+
+import org.lsmr.selfcheckout.devices.AbstractDevice;
+
+/**
+ * This class represents the abstract interface for all device observers. All
+ * subclasses should add their own event notification methods, the first
+ * parameter of which should always be the device affected.
+ */
+public interface AbstractDeviceObserver {
+	/**
+	 * Announces that the indicated device has been enabled.
+	 * 
+	 * @param device
+	 *                 The device that has been enabled.
+	 */
+	public void enabled(AbstractDevice<? extends AbstractDeviceObserver> device);
+
+	/**
+	 * Announces that the indicated device has been disabled.
+	 * 
+	 * @param device
+	 *                 The device that has been enabled.
+	 */
+	public void disabled(AbstractDevice<? extends AbstractDeviceObserver> device);
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/BanknoteDispenserObserver.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/BanknoteDispenserObserver.java
new file mode 100644
index 0000000..d4363bf
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/BanknoteDispenserObserver.java	
@@ -0,0 +1,71 @@
+package org.lsmr.selfcheckout.devices.observers;
+
+import org.lsmr.selfcheckout.Banknote;
+import org.lsmr.selfcheckout.devices.BanknoteDispenser;
+
+/**
+ * Observes events emanating from a banknote dispenser.
+ */
+public interface BanknoteDispenserObserver extends AbstractDeviceObserver {
+	/**
+	 * Announces that the indicated banknote dispenser is full of banknotes.
+	 * 
+	 * @param dispenser
+	 *            The dispenser where the event occurred.
+	 */
+	void moneyFull(BanknoteDispenser dispenser);
+
+	/**
+	 * Announces that the indicated banknote dispenser is empty of banknotes.
+	 * 
+	 * @param dispenser
+	 *            The dispenser where the event occurred.
+	 */
+	void banknotesEmpty(BanknoteDispenser dispenser);
+
+	/**
+	 * Announces that the indicated banknote has been added to the indicated
+	 * banknote dispenser.
+	 * 
+	 * @param dispenser
+	 *            The dispenser where the event occurred.
+	 * @param banknote
+	 *            The banknote that was added.
+	 */
+	void billAdded(BanknoteDispenser dispenser, Banknote banknote);
+
+	/**
+	 * Announces that the indicated banknote has been added to the indicated
+	 * banknote dispenser.
+	 * 
+	 * @param dispenser
+	 *            The dispenser where the event occurred.
+	 * @param banknote
+	 *            The banknote that was removed.
+	 */
+	void banknoteRemoved(BanknoteDispenser dispenser, Banknote banknote);
+
+	/**
+	 * Announces that the indicated sequence of banknotes has been added to the
+	 * indicated banknote dispenser. Used to simulate direct, physical loading of
+	 * the dispenser.
+	 * 
+	 * @param dispenser
+	 *            The dispenser where the event occurred.
+	 * @param banknotes
+	 *            The banknotes that were loaded.
+	 */
+	void banknotesLoaded(BanknoteDispenser dispenser, Banknote... banknotes);
+
+	/**
+	 * Announces that the indicated sequence of banknotes has been removed to the
+	 * indicated banknote dispenser. Used to simulate direct, physical unloading of
+	 * the dispenser.
+	 * 
+	 * @param dispenser
+	 *            The dispenser where the event occurred.
+	 * @param banknotes
+	 *            The banknotes that were unloaded.
+	 */
+	void banknotesUnloaded(BanknoteDispenser dispenser, Banknote... banknotes);
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/BanknoteSlotObserver.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/BanknoteSlotObserver.java
new file mode 100644
index 0000000..20ced82
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/BanknoteSlotObserver.java	
@@ -0,0 +1,34 @@
+package org.lsmr.selfcheckout.devices.observers;
+
+import org.lsmr.selfcheckout.Banknote;
+import org.lsmr.selfcheckout.devices.BanknoteSlot;
+
+/**
+ * Observes events emanating from a banknote slot.
+ */
+public interface BanknoteSlotObserver extends AbstractDeviceObserver {
+	/**
+	 * An event announcing that a banknote has been inserted.
+	 * 
+	 * @param slot
+	 *            The device on which the event occurred.
+	 */
+	void banknoteInserted(BanknoteSlot slot);
+
+	/**
+	 * An event announcing that a banknote has been returned to the user, dangling
+	 * from the slot.
+	 * 
+	 * @param slot
+	 *            The device on which the event occurred.
+	 */
+	void banknoteEjected(BanknoteSlot slot);
+
+	/**
+	 * An event announcing that a dangling banknote has been removed by the user.
+	 * 
+	 * @param slot
+	 *            The device on which the event occurred.
+	 */
+	void banknoteRemoved(BanknoteSlot slot);
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/BanknoteStorageUnitObserver.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/BanknoteStorageUnitObserver.java
new file mode 100644
index 0000000..9f17942
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/BanknoteStorageUnitObserver.java	
@@ -0,0 +1,43 @@
+package org.lsmr.selfcheckout.devices.observers;
+
+import org.lsmr.selfcheckout.Banknote;
+import org.lsmr.selfcheckout.devices.BanknoteStorageUnit;
+
+/**
+ * Observes events emanating from a banknote storage unit.
+ */
+public interface BanknoteStorageUnitObserver extends AbstractDeviceObserver {
+	/**
+	 * Announces that the indicated banknote storage unit is full of banknotes.
+	 * 
+	 * @param unit
+	 *            The storage unit where the event occurred.
+	 */
+	void banknotesFull(BanknoteStorageUnit unit);
+
+	/**
+	 * Announces that a banknote has been added to the indicated storage unit.
+	 * 
+	 * @param unit
+	 *            The storage unit where the event occurred.
+	 */
+	void banknoteAdded(BanknoteStorageUnit unit);
+
+	/**
+	 * Announces that the indicated storage unit has been loaded with banknotes.
+	 * Used to simulate direct, physical loading of the unit.
+	 * 
+	 * @param unit
+	 *            The storage unit where the event occurred.
+	 */
+	void banknotesLoaded(BanknoteStorageUnit unit);
+
+	/**
+	 * Announces that the storage unit has been emptied of banknotes. Used to
+	 * simulate direct, physical unloading of the unit.
+	 * 
+	 * @param unit
+	 *            The storage unit where the event occurred.
+	 */
+	void banknotesUnloaded(BanknoteStorageUnit unit);
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/BanknoteValidatorObserver.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/BanknoteValidatorObserver.java
new file mode 100644
index 0000000..583fa9d
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/BanknoteValidatorObserver.java	
@@ -0,0 +1,33 @@
+package org.lsmr.selfcheckout.devices.observers;
+
+import java.util.Currency;
+
+import org.lsmr.selfcheckout.Banknote;
+import org.lsmr.selfcheckout.devices.BanknoteValidator;
+
+/**
+ * Observes events emanating from a banknote validator.
+ */
+public interface BanknoteValidatorObserver extends AbstractDeviceObserver {
+	/**
+	 * An event announcing that the indicated banknote has been detected and
+	 * determined to be valid.
+	 * 
+	 * @param validator
+	 *            The device on which the event occurred.
+	 * @param currency
+	 *            The kind of currency of the inserted banknote.
+	 * @param value
+	 *            The value of the inserted banknote.
+	 */
+	void validBanknoteDetected(BanknoteValidator validator, Currency currency, int value);
+
+	/**
+	 * An event announcing that the indicated banknote has been detected and
+	 * determined to be invalid.
+	 * 
+	 * @param validator
+	 *            The device on which the event occurred.
+	 */
+	void invalidBanknoteDetected(BanknoteValidator validator);
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/BarcodeScannerObserver.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/BarcodeScannerObserver.java
new file mode 100644
index 0000000..5a73307
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/BarcodeScannerObserver.java	
@@ -0,0 +1,20 @@
+package org.lsmr.selfcheckout.devices.observers;
+
+import org.lsmr.selfcheckout.Barcode;
+import org.lsmr.selfcheckout.devices.BarcodeScanner;
+
+/**
+ * Observes events emanating from a barcode scanner.
+ */
+public interface BarcodeScannerObserver extends AbstractDeviceObserver {
+	/**
+	 * An event announcing that the indicated barcode has been successfully scanned.
+	 * 
+	 * @param barcodeScanner
+	 *            The device on which the event occurred.
+	 * @param barcode
+	 *            The barcode that was read by the scanner.
+	 */
+	void barcodeScanned(BarcodeScanner barcodeScanner, Barcode barcode);
+
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/CardReaderObserver.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/CardReaderObserver.java
new file mode 100644
index 0000000..9256e3a
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/CardReaderObserver.java	
@@ -0,0 +1,52 @@
+package org.lsmr.selfcheckout.devices.observers;
+
+import org.lsmr.selfcheckout.Card.CardData;
+import org.lsmr.selfcheckout.devices.CardReader;
+
+/**
+ * Observes events emanating from a coin dispenser.
+ */
+public interface CardReaderObserver extends AbstractDeviceObserver {
+	/**
+	 * Announces that a card has been inserted in the indicated card reader.
+	 * 
+	 * @param reader
+	 *            The reader where the event occurred.
+	 */
+	void cardInserted(CardReader reader);
+
+	/**
+	 * Announces that a card has been removed from the indicated card reader.
+	 * 
+	 * @param reader
+	 *            The reader where the event occurred.
+	 */
+	void cardRemoved(CardReader reader);
+
+	/**
+	 * Announces that a (tap-enabled) card has been tapped on the indicated card
+	 * reader.
+	 * 
+	 * @param reader
+	 *            The reader where the event occurred.
+	 */
+	void cardTapped(CardReader reader);
+
+	/**
+	 * Announces that a card has swiped on the indicated card reader.
+	 * 
+	 * @param reader
+	 *            The reader where the event occurred.
+	 */
+	void cardSwiped(CardReader reader);
+
+	/**
+	 * Announces that the data has been read from a card.
+	 * 
+	 * @param reader
+	 *            The reader where the event occurred.
+	 * @param data
+	 *            The data that was read. Note that this data may be corrupted.
+	 */
+	void cardDataRead(CardReader reader, CardData data);
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/CoinDispenserObserver.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/CoinDispenserObserver.java
new file mode 100644
index 0000000..d388e06
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/CoinDispenserObserver.java	
@@ -0,0 +1,67 @@
+package org.lsmr.selfcheckout.devices.observers;
+
+import org.lsmr.selfcheckout.Coin;
+import org.lsmr.selfcheckout.devices.CoinDispenser;
+
+/**
+ * Observes events emanating from a coin dispenser.
+ */
+public interface CoinDispenserObserver extends AbstractDeviceObserver {
+	/**
+	 * Announces that the indicated coin dispenser is full of coins.
+	 * 
+	 * @param dispenser
+	 *             The dispenser where the event occurred.
+	 */
+	void coinsFull(CoinDispenser dispenser);
+
+	/**
+	 * Announces that the indicated coin dispenser is empty of coins.
+	 * 
+	 * @param dispenser
+	 *             The dispenser where the event occurred.
+	 */
+	void coinsEmpty(CoinDispenser dispenser);
+
+	/**
+	 * Announces that the indicated coin has been added to the indicated coin dispenser.
+	 * 
+	 * @param dispenser
+	 *             The dispenser where the event occurred.
+	 * @param coin
+	 *             The coin that was added.
+	 */
+	void coinAdded(CoinDispenser dispenser, Coin coin);
+
+	/**
+	 * Announces that the indicated coin has been added to the indicated coin dispenser.
+	 * 
+	 * @param dispenser
+	 *             The dispenser where the event occurred.
+	 * @param coin
+	 *             The coin that was removed.
+	 */
+	void coinRemoved(CoinDispenser dispenser, Coin coin);
+
+	/**
+	 * Announces that the indicated sequence of coins has been added to the
+	 * indicated coin dispenser. Used to simulate direct, physical loading of the dispenser.
+	 * 
+	 * @param dispenser
+	 *              The dispenser where the event occurred.
+	 * @param coins
+	 *              The coins that were loaded.
+	 */
+	void coinsLoaded(CoinDispenser dispenser, Coin... coins);
+
+	/**
+	 * Announces that the indicated sequence of coins has been removed to the
+	 * indicated coin dispenser. Used to simulate direct, physical unloading of the dispenser.
+	 * 
+	 * @param dispenser
+	 *              The dispenser where the event occurred.
+	 * @param coins
+	 *              The coins that were unloaded.
+	 */
+	void coinsUnloaded(CoinDispenser dispenser, Coin... coins);
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/CoinSlotObserver.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/CoinSlotObserver.java
new file mode 100644
index 0000000..a091cb2
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/CoinSlotObserver.java	
@@ -0,0 +1,17 @@
+package org.lsmr.selfcheckout.devices.observers;
+
+import org.lsmr.selfcheckout.Coin;
+import org.lsmr.selfcheckout.devices.CoinSlot;
+
+/**
+ * Observes events emanating from a coin slot.
+ */
+public interface CoinSlotObserver extends AbstractDeviceObserver {
+	/**
+	 * An event announcing that a coin has been inserted.
+	 * 
+	 * @param slot
+	 *             The device on which the event occurred.
+	 */
+	void coinInserted(CoinSlot slot);
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/CoinStorageUnitObserver.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/CoinStorageUnitObserver.java
new file mode 100644
index 0000000..6049c36
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/CoinStorageUnitObserver.java	
@@ -0,0 +1,43 @@
+package org.lsmr.selfcheckout.devices.observers;
+
+import org.lsmr.selfcheckout.Coin;
+import org.lsmr.selfcheckout.devices.CoinStorageUnit;
+
+/**
+ * Observes events emanating from a coin storage unit.
+ */
+public interface CoinStorageUnitObserver extends AbstractDeviceObserver {
+	/**
+	 * Announces that the indicated coin storage unit is full of coins.
+	 * 
+	 * @param unit
+	 *            The storage unit where the event occurred.
+	 */
+	void coinsFull(CoinStorageUnit unit);
+
+	/**
+	 * Announces that a coin has been added to the indicated storage unit.
+	 * 
+	 * @param unit
+	 *            The storage unit where the event occurred.
+	 */
+	void coinAdded(CoinStorageUnit unit);
+
+	/**
+	 * Announces that the indicated storage unit has been loaded with coins.
+	 * Used to simulate direct, physical loading of the unit.
+	 * 
+	 * @param unit
+	 *            The storage unit where the event occurred.
+	 */
+	void coinsLoaded(CoinStorageUnit unit);
+
+	/**
+	 * Announces that the storage unit has been emptied of coins. Used to
+	 * simulate direct, physical unloading of the unit.
+	 * 
+	 * @param unit
+	 *            The storage unit where the event occurred.
+	 */
+	void coinsUnloaded(CoinStorageUnit unit);
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/CoinTrayObserver.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/CoinTrayObserver.java
new file mode 100644
index 0000000..f5be6ea
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/CoinTrayObserver.java	
@@ -0,0 +1,18 @@
+package org.lsmr.selfcheckout.devices.observers;
+
+import org.lsmr.selfcheckout.Coin;
+import org.lsmr.selfcheckout.devices.CoinTray;
+
+/**
+ * Observes events emanating from a coin tray. Coin trays are dumb devices so
+ * very few kinds of events can be announced by them.
+ */
+public interface CoinTrayObserver extends AbstractDeviceObserver {
+	/**
+	 * Announces that a coin has been added to the indicated tray.
+	 * 
+	 * @param tray
+	 *            The tray where the event occurred.
+	 */
+	void coinAdded(CoinTray tray);
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/CoinValidatorObserver.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/CoinValidatorObserver.java
new file mode 100644
index 0000000..f0660b0
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/CoinValidatorObserver.java	
@@ -0,0 +1,32 @@
+package org.lsmr.selfcheckout.devices.observers;
+
+import java.math.BigDecimal;
+
+import org.lsmr.selfcheckout.Banknote;
+import org.lsmr.selfcheckout.Coin;
+import org.lsmr.selfcheckout.devices.CoinValidator;
+
+/**
+ * Observes events emanating from a coin validator.
+ */
+public interface CoinValidatorObserver extends AbstractDeviceObserver {
+	/**
+	 * An event announcing that the indicated coin has been detected and determined
+	 * to be valid.
+	 * 
+	 * @param validator
+	 *            The device on which the event occurred.
+	 * @param value
+	 *            The value of the coin.
+	 */
+	void validCoinDetected(CoinValidator validator, BigDecimal value);
+
+	/**
+	 * An event announcing that a coin has been detected and determined to be
+	 * invalid.
+	 * 
+	 * @param validator
+	 *            The device on which the event occurred.
+	 */
+	void invalidCoinDetected(CoinValidator validator);
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/ElectronicScaleObserver.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/ElectronicScaleObserver.java
new file mode 100644
index 0000000..1d20b50
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/ElectronicScaleObserver.java	
@@ -0,0 +1,36 @@
+package org.lsmr.selfcheckout.devices.observers;
+
+import org.lsmr.selfcheckout.Coin;
+import org.lsmr.selfcheckout.devices.ElectronicScale;
+
+/**
+ * Observes events emanating from an electronic scale.
+ */
+public interface ElectronicScaleObserver extends AbstractDeviceObserver {
+	/**
+	 * Announces that the weight on the indicated scale has changed.
+	 * 
+	 * @param scale
+	 *            The scale where the event occurred.
+	 * @param weightInGrams
+	 *            The new weight.
+	 */
+	void weightChanged(ElectronicScale scale, double weightInGrams);
+
+	/**
+	 * Announces that excessive weight has been placed on the indicated scale.
+	 * 
+	 * @param scale
+	 *            The scale where the event occurred.
+	 */
+	void overload(ElectronicScale scale);
+
+	/**
+	 * Announces that the former excessive weight has been removed from the
+	 * indicated scale, and it is again able to measure weight.
+	 * 
+	 * @param scale
+	 *            The scale where the event occurred.
+	 */
+	void outOfOverload(ElectronicScale scale);
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/ReceiptPrinterObserver.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/ReceiptPrinterObserver.java
new file mode 100644
index 0000000..dc31b99
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/ReceiptPrinterObserver.java	
@@ -0,0 +1,40 @@
+package org.lsmr.selfcheckout.devices.observers;
+
+import org.lsmr.selfcheckout.devices.ReceiptPrinter;
+
+/**
+ * Observes events emanating from a receipt printer.
+ */
+public interface ReceiptPrinterObserver extends AbstractDeviceObserver {
+	/**
+	 * Announces that the indicated printer is out of paper.
+	 * 
+	 * @param printer
+	 *            The device from which the event emanated.
+	 */
+	void outOfPaper(ReceiptPrinter printer);
+
+	/**
+	 * Announces that the indicated printer is out of ink.
+	 * 
+	 * @param printer
+	 *            The device from which the event emanated.
+	 */
+	void outOfInk(ReceiptPrinter printer);
+
+	/**
+	 * Announces that paper has been added to the indicated printer.
+	 * 
+	 * @param printer
+	 *            The device from which the event emanated.
+	 */
+	void paperAdded(ReceiptPrinter printer);
+
+	/**
+	 * Announces that ink has been added to the indicated printer.
+	 * 
+	 * @param printer
+	 *            The device from which the event emanated.
+	 */
+	void inkAdded(ReceiptPrinter printer);
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/TouchScreenObserver.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/TouchScreenObserver.java
new file mode 100644
index 0000000..e6ea7ad
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/TouchScreenObserver.java	
@@ -0,0 +1,9 @@
+package org.lsmr.selfcheckout.devices.observers;
+
+import org.lsmr.selfcheckout.devices.AbstractDevice;
+
+/**
+ * Represents observers that respond only to enable/disable events on touch screens.
+ */
+public interface TouchScreenObserver extends AbstractDeviceObserver {
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/products/BarcodedProduct.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/products/BarcodedProduct.java
new file mode 100644
index 0000000..4559cba
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/products/BarcodedProduct.java	
@@ -0,0 +1,59 @@
+package org.lsmr.selfcheckout.products;
+
+import java.math.BigDecimal;
+
+import org.lsmr.selfcheckout.Barcode;
+import org.lsmr.selfcheckout.devices.SimulationException;
+
+/**
+ * Represents products with barcodes. Such products always have prices per-unit.
+ */
+public class BarcodedProduct extends Product {
+	private final Barcode barcode;
+	private final String description;
+
+	/**
+	 * Create a product.
+	 * 
+	 * @param barcode
+	 *            The barcode of the product.
+	 * @param description
+	 *            The description of the product.
+	 * @param price
+	 *            The price per-unit of the product.
+	 * @throws SimulationException
+	 *             If any argument is null.
+	 * @throws SimulationException
+	 *             If the price is &le;0.
+	 */
+	public BarcodedProduct(Barcode barcode, String description, BigDecimal price) {
+		super(price, true);
+
+		if(barcode == null)
+			throw new SimulationException(new NullPointerException("barcode is null"));
+
+		if(description == null)
+			throw new SimulationException(new NullPointerException("description is null"));
+
+		this.barcode = barcode;
+		this.description = description;
+	}
+
+	/**
+	 * Get the barcode.
+	 * 
+	 * @return The barcode. Cannot be null.
+	 */
+	public Barcode getBarcode() {
+		return barcode;
+	}
+
+	/**
+	 * Get the description.
+	 * 
+	 * @return The description. Cannot be null.
+	 */
+	public String getDescription() {
+		return description;
+	}
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/products/PLUCodedProduct.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/products/PLUCodedProduct.java
new file mode 100644
index 0000000..c3bab30
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/products/PLUCodedProduct.java	
@@ -0,0 +1,57 @@
+package org.lsmr.selfcheckout.products;
+
+import java.math.BigDecimal;
+
+import org.lsmr.selfcheckout.Barcode;
+import org.lsmr.selfcheckout.PriceLookupCode;
+import org.lsmr.selfcheckout.devices.SimulationException;
+
+/**
+ * Represents products with price-lookup (PLU) codes. Such products always have
+ * prices per-kilogram.
+ */
+public class PLUCodedProduct extends Product {
+	private final PriceLookupCode pluCode;
+	private final String description;
+
+	/**
+	 * Create a product.
+	 * 
+	 * @param pluCode
+	 *            The PLU code of the product.
+	 * @param description
+	 *            The description of the product.
+	 * @param price
+	 *            The price per-kilogram of the product.
+	 */
+	public PLUCodedProduct(PriceLookupCode pluCode, String description, BigDecimal price) {
+		super(price, false);
+
+		if(pluCode == null)
+			throw new SimulationException(new NullPointerException("barcode is null"));
+
+		if(description == null)
+			throw new SimulationException(new NullPointerException("description is null"));
+
+		this.pluCode = pluCode;
+		this.description = description;
+	}
+
+	/**
+	 * Get the PLU code.
+	 * 
+	 * @return The PLU code. Cannot be null.
+	 */
+	public PriceLookupCode getPLUCode() {
+		return pluCode;
+	}
+
+	/**
+	 * Get the description.
+	 * 
+	 * @return The description. Cannot be null.
+	 */
+	public String getDescription() {
+		return description;
+	}
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/products/Product.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/products/Product.java
new file mode 100644
index 0000000..d47e70e
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/products/Product.java	
@@ -0,0 +1,55 @@
+package org.lsmr.selfcheckout.products;
+
+import java.math.BigDecimal;
+
+import org.lsmr.selfcheckout.devices.SimulationException;
+
+/**
+ * Abstract base class for products. Note that a "product" is the <b>kind</> of
+ * item (e.g., 2 litre container of Dairyland brand 2% milk) and not an
+ * individual item, which would be the specific physical object (e.g.,
+ * <b>that</b> bottle of milk and not <b>this</b> one).
+ */
+public abstract class Product {
+	private final BigDecimal price;
+	private final boolean isPerUnit;
+
+	/**
+	 * Create a product instance.
+	 * 
+	 * @param price
+	 *            The price per unit or per kilogram.
+	 * @param isPerUnit
+	 *            True if the price is per unit; false if it is per kilogram.
+	 * @throws SimulationException
+	 *             If the price is null or &le;0.
+	 */
+	protected Product(BigDecimal price, boolean isPerUnit) {
+		if(price == null)
+			throw new SimulationException(new NullPointerException("price is null"));
+
+		if(price.compareTo(BigDecimal.ZERO) <= 0)
+			throw new SimulationException(new IllegalArgumentException("A product's price can only be positive."));
+
+		this.price = price;
+		this.isPerUnit = isPerUnit;
+	}
+
+	/**
+	 * Gets the price of the product.
+	 * 
+	 * @return The price. Cannot be null. Must be &gt;0.
+	 */
+	public BigDecimal getPrice() {
+		return price;
+	}
+
+	/**
+	 * Tests whether the price is per-unit, as opposed to per-kilogram.
+	 * 
+	 * @return true if the price is per-unit; otherwise, false.
+	 */
+	public boolean isPerUnit() {
+		return isPerUnit;
+	}
+}
diff --git a/bin/BanknoteController.class b/bin/BanknoteController.class
new file mode 100644
index 0000000..7ff8015
Binary files /dev/null and b/bin/BanknoteController.class differ
diff --git a/bin/org/lsmr/selfcheckout/Banknote.class b/bin/org/lsmr/selfcheckout/Banknote.class
new file mode 100644
index 0000000..0416eb6
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/Banknote.class differ
diff --git a/bin/org/lsmr/selfcheckout/Barcode.class b/bin/org/lsmr/selfcheckout/Barcode.class
new file mode 100644
index 0000000..464a475
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/Barcode.class differ
diff --git a/bin/org/lsmr/selfcheckout/BarcodedItem.class b/bin/org/lsmr/selfcheckout/BarcodedItem.class
new file mode 100644
index 0000000..de7368f
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/BarcodedItem.class differ
diff --git a/bin/org/lsmr/selfcheckout/BlockedCardException.class b/bin/org/lsmr/selfcheckout/BlockedCardException.class
new file mode 100644
index 0000000..0342831
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/BlockedCardException.class differ
diff --git a/bin/org/lsmr/selfcheckout/Card$CardData.class b/bin/org/lsmr/selfcheckout/Card$CardData.class
new file mode 100644
index 0000000..3a5a24b
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/Card$CardData.class differ
diff --git a/bin/org/lsmr/selfcheckout/Card$CardInsertData.class b/bin/org/lsmr/selfcheckout/Card$CardInsertData.class
new file mode 100644
index 0000000..b1844b6
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/Card$CardInsertData.class differ
diff --git a/bin/org/lsmr/selfcheckout/Card$CardSwipeData.class b/bin/org/lsmr/selfcheckout/Card$CardSwipeData.class
new file mode 100644
index 0000000..38d5704
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/Card$CardSwipeData.class differ
diff --git a/bin/org/lsmr/selfcheckout/Card$CardTapData.class b/bin/org/lsmr/selfcheckout/Card$CardTapData.class
new file mode 100644
index 0000000..c51bac1
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/Card$CardTapData.class differ
diff --git a/bin/org/lsmr/selfcheckout/Card.class b/bin/org/lsmr/selfcheckout/Card.class
new file mode 100644
index 0000000..7ca0563
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/Card.class differ
diff --git a/bin/org/lsmr/selfcheckout/ChipFailureException.class b/bin/org/lsmr/selfcheckout/ChipFailureException.class
new file mode 100644
index 0000000..f4aaf48
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/ChipFailureException.class differ
diff --git a/bin/org/lsmr/selfcheckout/Coin.class b/bin/org/lsmr/selfcheckout/Coin.class
new file mode 100644
index 0000000..55e3cde
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/Coin.class differ
diff --git a/bin/org/lsmr/selfcheckout/IllegalDigitException.class b/bin/org/lsmr/selfcheckout/IllegalDigitException.class
new file mode 100644
index 0000000..ecf0201
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/IllegalDigitException.class differ
diff --git a/bin/org/lsmr/selfcheckout/InvalidPINException.class b/bin/org/lsmr/selfcheckout/InvalidPINException.class
new file mode 100644
index 0000000..9a7fdaa
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/InvalidPINException.class differ
diff --git a/bin/org/lsmr/selfcheckout/Item.class b/bin/org/lsmr/selfcheckout/Item.class
new file mode 100644
index 0000000..a3468c5
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/Item.class differ
diff --git a/bin/org/lsmr/selfcheckout/MagneticStripeFailureException.class b/bin/org/lsmr/selfcheckout/MagneticStripeFailureException.class
new file mode 100644
index 0000000..f3ef20e
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/MagneticStripeFailureException.class differ
diff --git a/bin/org/lsmr/selfcheckout/Numeral.class b/bin/org/lsmr/selfcheckout/Numeral.class
new file mode 100644
index 0000000..fa00a27
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/Numeral.class differ
diff --git a/bin/org/lsmr/selfcheckout/PLUCodedItem.class b/bin/org/lsmr/selfcheckout/PLUCodedItem.class
new file mode 100644
index 0000000..eec7e69
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/PLUCodedItem.class differ
diff --git a/bin/org/lsmr/selfcheckout/PriceLookupCode.class b/bin/org/lsmr/selfcheckout/PriceLookupCode.class
new file mode 100644
index 0000000..22ee588
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/PriceLookupCode.class differ
diff --git a/bin/org/lsmr/selfcheckout/TapFailureException.class b/bin/org/lsmr/selfcheckout/TapFailureException.class
new file mode 100644
index 0000000..b22f856
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/TapFailureException.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/AbstractDevice$Phase.class b/bin/org/lsmr/selfcheckout/devices/AbstractDevice$Phase.class
new file mode 100644
index 0000000..f66cc1a
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/AbstractDevice$Phase.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/AbstractDevice.class b/bin/org/lsmr/selfcheckout/devices/AbstractDevice.class
new file mode 100644
index 0000000..7135fa4
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/AbstractDevice.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/Acceptor.class b/bin/org/lsmr/selfcheckout/devices/Acceptor.class
new file mode 100644
index 0000000..45c016e
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/Acceptor.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/BanknoteDispenser.class b/bin/org/lsmr/selfcheckout/devices/BanknoteDispenser.class
new file mode 100644
index 0000000..34485ac
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/BanknoteDispenser.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/BanknoteSlot.class b/bin/org/lsmr/selfcheckout/devices/BanknoteSlot.class
new file mode 100644
index 0000000..79a1500
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/BanknoteSlot.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/BanknoteStorageUnit.class b/bin/org/lsmr/selfcheckout/devices/BanknoteStorageUnit.class
new file mode 100644
index 0000000..9af0ff3
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/BanknoteStorageUnit.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/BanknoteValidator.class b/bin/org/lsmr/selfcheckout/devices/BanknoteValidator.class
new file mode 100644
index 0000000..c008572
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/BanknoteValidator.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/BarcodeScanner.class b/bin/org/lsmr/selfcheckout/devices/BarcodeScanner.class
new file mode 100644
index 0000000..1b0049f
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/BarcodeScanner.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/BidirectionalChannel.class b/bin/org/lsmr/selfcheckout/devices/BidirectionalChannel.class
new file mode 100644
index 0000000..adfe35a
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/BidirectionalChannel.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/CardReader.class b/bin/org/lsmr/selfcheckout/devices/CardReader.class
new file mode 100644
index 0000000..bc75481
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/CardReader.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/CoinDispenser.class b/bin/org/lsmr/selfcheckout/devices/CoinDispenser.class
new file mode 100644
index 0000000..e949320
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/CoinDispenser.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/CoinSlot.class b/bin/org/lsmr/selfcheckout/devices/CoinSlot.class
new file mode 100644
index 0000000..b06c85d
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/CoinSlot.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/CoinStorageUnit.class b/bin/org/lsmr/selfcheckout/devices/CoinStorageUnit.class
new file mode 100644
index 0000000..4fa1b4f
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/CoinStorageUnit.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/CoinTray.class b/bin/org/lsmr/selfcheckout/devices/CoinTray.class
new file mode 100644
index 0000000..91f3706
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/CoinTray.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/CoinValidator.class b/bin/org/lsmr/selfcheckout/devices/CoinValidator.class
new file mode 100644
index 0000000..f87b5f2
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/CoinValidator.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/DisabledException.class b/bin/org/lsmr/selfcheckout/devices/DisabledException.class
new file mode 100644
index 0000000..160c02e
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/DisabledException.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/ElectronicScale.class b/bin/org/lsmr/selfcheckout/devices/ElectronicScale.class
new file mode 100644
index 0000000..23e2f9c
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/ElectronicScale.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/Emitter.class b/bin/org/lsmr/selfcheckout/devices/Emitter.class
new file mode 100644
index 0000000..7a295ba
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/Emitter.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/EmptyException.class b/bin/org/lsmr/selfcheckout/devices/EmptyException.class
new file mode 100644
index 0000000..877ad17
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/EmptyException.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/FlowThroughEmitter.class b/bin/org/lsmr/selfcheckout/devices/FlowThroughEmitter.class
new file mode 100644
index 0000000..c8cb670
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/FlowThroughEmitter.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/FromStorageEmitter.class b/bin/org/lsmr/selfcheckout/devices/FromStorageEmitter.class
new file mode 100644
index 0000000..962fb88
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/FromStorageEmitter.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/OverloadException.class b/bin/org/lsmr/selfcheckout/devices/OverloadException.class
new file mode 100644
index 0000000..026d948
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/OverloadException.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/ReceiptPrinter.class b/bin/org/lsmr/selfcheckout/devices/ReceiptPrinter.class
new file mode 100644
index 0000000..a3cbbad
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/ReceiptPrinter.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/SelfCheckoutStation.class b/bin/org/lsmr/selfcheckout/devices/SelfCheckoutStation.class
new file mode 100644
index 0000000..d8362c2
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/SelfCheckoutStation.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/SimulationException.class b/bin/org/lsmr/selfcheckout/devices/SimulationException.class
new file mode 100644
index 0000000..4f0bdb9
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/SimulationException.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/UnidirectionalChannel.class b/bin/org/lsmr/selfcheckout/devices/UnidirectionalChannel.class
new file mode 100644
index 0000000..4dc61ad
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/UnidirectionalChannel.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/AbstractDeviceObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/AbstractDeviceObserver.class
new file mode 100644
index 0000000..185b861
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/observers/AbstractDeviceObserver.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/BanknoteDispenserObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/BanknoteDispenserObserver.class
new file mode 100644
index 0000000..dcb2f02
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/observers/BanknoteDispenserObserver.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/BanknoteSlotObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/BanknoteSlotObserver.class
new file mode 100644
index 0000000..a89eead
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/observers/BanknoteSlotObserver.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/BanknoteStorageUnitObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/BanknoteStorageUnitObserver.class
new file mode 100644
index 0000000..2671b9f
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/observers/BanknoteStorageUnitObserver.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/BanknoteValidatorObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/BanknoteValidatorObserver.class
new file mode 100644
index 0000000..2f6bb87
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/observers/BanknoteValidatorObserver.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/BarcodeScannerObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/BarcodeScannerObserver.class
new file mode 100644
index 0000000..7c4bb1e
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/observers/BarcodeScannerObserver.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/CardReaderObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/CardReaderObserver.class
new file mode 100644
index 0000000..1718764
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/observers/CardReaderObserver.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/CoinDispenserObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/CoinDispenserObserver.class
new file mode 100644
index 0000000..9283409
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/observers/CoinDispenserObserver.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/CoinSlotObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/CoinSlotObserver.class
new file mode 100644
index 0000000..3b00362
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/observers/CoinSlotObserver.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/CoinStorageUnitObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/CoinStorageUnitObserver.class
new file mode 100644
index 0000000..da91d12
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/observers/CoinStorageUnitObserver.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/CoinTrayObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/CoinTrayObserver.class
new file mode 100644
index 0000000..bf26991
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/observers/CoinTrayObserver.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/CoinValidatorObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/CoinValidatorObserver.class
new file mode 100644
index 0000000..817e5dc
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/observers/CoinValidatorObserver.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/ElectronicScaleObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/ElectronicScaleObserver.class
new file mode 100644
index 0000000..cfcc4eb
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/observers/ElectronicScaleObserver.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/ReceiptPrinterObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/ReceiptPrinterObserver.class
new file mode 100644
index 0000000..f4d748e
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/observers/ReceiptPrinterObserver.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/TouchScreenObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/TouchScreenObserver.class
new file mode 100644
index 0000000..9e96845
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/observers/TouchScreenObserver.class differ
diff --git a/bin/org/lsmr/selfcheckout/products/BarcodedProduct.class b/bin/org/lsmr/selfcheckout/products/BarcodedProduct.class
new file mode 100644
index 0000000..5d971c7
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/products/BarcodedProduct.class differ
diff --git a/bin/org/lsmr/selfcheckout/products/PLUCodedProduct.class b/bin/org/lsmr/selfcheckout/products/PLUCodedProduct.class
new file mode 100644
index 0000000..2c232ee
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/products/PLUCodedProduct.class differ
diff --git a/bin/org/lsmr/selfcheckout/products/Product.class b/bin/org/lsmr/selfcheckout/products/Product.class
new file mode 100644
index 0000000..e0f34c2
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/products/Product.class differ
diff --git a/src/BanknoteController.java b/src/BanknoteController.java
new file mode 100644
index 0000000..7c00f37
--- /dev/null
+++ b/src/BanknoteController.java
@@ -0,0 +1,68 @@
+import java.math.BigDecimal;
+import java.util.Currency;
+
+import org.lsmr.selfcheckout.devices.AbstractDevice;
+import org.lsmr.selfcheckout.devices.BanknoteStorageUnit;
+import org.lsmr.selfcheckout.devices.BanknoteValidator;
+import org.lsmr.selfcheckout.devices.SelfCheckoutStation;
+import org.lsmr.selfcheckout.devices.observers.AbstractDeviceObserver;
+import org.lsmr.selfcheckout.devices.observers.BanknoteStorageUnitObserver;
+import org.lsmr.selfcheckout.devices.observers.BanknoteValidatorObserver;
+
+public class BanknoteController implements BanknoteValidatorObserver, BanknoteStorageUnitObserver{
+
+	private int availableFunds;
+	private int validBanknotes = 0;
+	private boolean isFull = false;
+	
+	public BanknoteController(SelfCheckoutStation s) {
+		s.banknoteValidator.attach(this);
+		availableFunds = 0;
+	}
+
+	@Override
+	public void enabled(AbstractDevice<? extends AbstractDeviceObserver> device) {}
+
+	@Override
+	public void disabled(AbstractDevice<? extends AbstractDeviceObserver> device) {}
+
+	@Override
+	public void validBanknoteDetected(BanknoteValidator validator, Currency currency, int value) {
+		if(!isFull) {
+			availableFunds+=value;
+		}
+		
+	}
+
+	@Override
+	public void invalidBanknoteDetected(BanknoteValidator validator) {
+		
+	}
+
+	@Override
+	public void banknotesFull(BanknoteStorageUnit unit) {
+		isFull = true;
+		
+	}
+
+	@Override
+	public void banknoteAdded(BanknoteStorageUnit unit) {}
+
+	@Override
+	public void banknotesLoaded(BanknoteStorageUnit unit) {}
+
+	@Override
+	public void banknotesUnloaded(BanknoteStorageUnit unit) {
+		isFull = false;
+	}
+	
+	public boolean hasSufficientFunds(float price) {
+		return availableFunds>price;
+	}
+	
+	public int getCurrentFunds() {
+		return availableFunds;
+	}
+	
+	
+}

commit a2b51c53f336fe7620559a685607fbbcb0ca54b1
Author: Manbir Sandhu <mana24129@hotmail.com>
Date:   Fri Mar 18 17:42:16 2022 -0600

    fixing main branch

diff --git a/.classpath b/.classpath
new file mode 100644
index 0000000..8cf4aa1
--- /dev/null
+++ b/.classpath
@@ -0,0 +1,11 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<classpath>
+	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/JavaSE-17">
+		<attributes>
+			<attribute name="module" value="true"/>
+		</attributes>
+	</classpathentry>
+	<classpathentry kind="src" path="src"/>
+	<classpathentry kind="src" path="SCS - Hardware - v1.0/src"/>
+	<classpathentry kind="output" path="bin"/>
+</classpath>
diff --git a/.project b/.project
new file mode 100644
index 0000000..711bba8
--- /dev/null
+++ b/.project
@@ -0,0 +1,17 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>SCS - Software</name>
+	<comment></comment>
+	<projects>
+	</projects>
+	<buildSpec>
+		<buildCommand>
+			<name>org.eclipse.jdt.core.javabuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+	</buildSpec>
+	<natures>
+		<nature>org.eclipse.jdt.core.javanature</nature>
+	</natures>
+</projectDescription>
diff --git a/.settings/org.eclipse.jdt.core.prefs b/.settings/org.eclipse.jdt.core.prefs
new file mode 100644
index 0000000..8c9943d
--- /dev/null
+++ b/.settings/org.eclipse.jdt.core.prefs
@@ -0,0 +1,14 @@
+eclipse.preferences.version=1
+org.eclipse.jdt.core.compiler.codegen.inlineJsrBytecode=enabled
+org.eclipse.jdt.core.compiler.codegen.targetPlatform=17
+org.eclipse.jdt.core.compiler.codegen.unusedLocal=preserve
+org.eclipse.jdt.core.compiler.compliance=17
+org.eclipse.jdt.core.compiler.debug.lineNumber=generate
+org.eclipse.jdt.core.compiler.debug.localVariable=generate
+org.eclipse.jdt.core.compiler.debug.sourceFile=generate
+org.eclipse.jdt.core.compiler.problem.assertIdentifier=error
+org.eclipse.jdt.core.compiler.problem.enablePreviewFeatures=disabled
+org.eclipse.jdt.core.compiler.problem.enumIdentifier=error
+org.eclipse.jdt.core.compiler.problem.reportPreviewFeatures=warning
+org.eclipse.jdt.core.compiler.release=enabled
+org.eclipse.jdt.core.compiler.source=17
diff --git a/SCS - Hardware - v1.0/.classpath b/SCS - Hardware - v1.0/.classpath
new file mode 100644
index 0000000..6a189c4
--- /dev/null
+++ b/SCS - Hardware - v1.0/.classpath	
@@ -0,0 +1,7 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<classpath>
+	<classpathentry kind="src" path="src"/>
+	<classpathentry kind="con" path="org.eclipse.jdt.junit.JUNIT_CONTAINER/4"/>
+	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER"/>
+	<classpathentry kind="output" path="bin"/>
+</classpath>
diff --git a/SCS - Hardware - v1.0/.project b/SCS - Hardware - v1.0/.project
new file mode 100644
index 0000000..57573c6
--- /dev/null
+++ b/SCS - Hardware - v1.0/.project	
@@ -0,0 +1,17 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>SCS - Hardware - v1.0</name>
+	<comment></comment>
+	<projects>
+	</projects>
+	<buildSpec>
+		<buildCommand>
+			<name>org.eclipse.jdt.core.javabuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+	</buildSpec>
+	<natures>
+		<nature>org.eclipse.jdt.core.javanature</nature>
+	</natures>
+</projectDescription>
diff --git a/SCS - Hardware - v1.0/.settings/org.eclipse.jdt.core.prefs b/SCS - Hardware - v1.0/.settings/org.eclipse.jdt.core.prefs
new file mode 100644
index 0000000..bb35fa0
--- /dev/null
+++ b/SCS - Hardware - v1.0/.settings/org.eclipse.jdt.core.prefs	
@@ -0,0 +1,11 @@
+eclipse.preferences.version=1
+org.eclipse.jdt.core.compiler.codegen.inlineJsrBytecode=enabled
+org.eclipse.jdt.core.compiler.codegen.targetPlatform=1.8
+org.eclipse.jdt.core.compiler.codegen.unusedLocal=preserve
+org.eclipse.jdt.core.compiler.compliance=1.8
+org.eclipse.jdt.core.compiler.debug.lineNumber=generate
+org.eclipse.jdt.core.compiler.debug.localVariable=generate
+org.eclipse.jdt.core.compiler.debug.sourceFile=generate
+org.eclipse.jdt.core.compiler.problem.assertIdentifier=error
+org.eclipse.jdt.core.compiler.problem.enumIdentifier=error
+org.eclipse.jdt.core.compiler.source=1.8
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Banknote.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Banknote.class
new file mode 100644
index 0000000..fbc21cf
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Banknote.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Barcode.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Barcode.class
new file mode 100644
index 0000000..5cea197
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Barcode.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/BarcodedItem.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/BarcodedItem.class
new file mode 100644
index 0000000..2d68447
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/BarcodedItem.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/BlockedCardException.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/BlockedCardException.class
new file mode 100644
index 0000000..536dd3d
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/BlockedCardException.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Card$CardData.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Card$CardData.class
new file mode 100644
index 0000000..795e5b4
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Card$CardData.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Card$CardInsertData.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Card$CardInsertData.class
new file mode 100644
index 0000000..a2d7141
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Card$CardInsertData.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Card$CardSwipeData.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Card$CardSwipeData.class
new file mode 100644
index 0000000..a72d8a2
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Card$CardSwipeData.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Card$CardTapData.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Card$CardTapData.class
new file mode 100644
index 0000000..8efccff
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Card$CardTapData.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Card.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Card.class
new file mode 100644
index 0000000..262b944
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Card.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/ChipFailureException.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/ChipFailureException.class
new file mode 100644
index 0000000..fa389c2
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/ChipFailureException.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Coin.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Coin.class
new file mode 100644
index 0000000..67690f1
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Coin.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/IllegalDigitException.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/IllegalDigitException.class
new file mode 100644
index 0000000..be8be69
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/IllegalDigitException.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/InvalidPINException.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/InvalidPINException.class
new file mode 100644
index 0000000..c08cda6
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/InvalidPINException.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Item.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Item.class
new file mode 100644
index 0000000..69e38c1
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Item.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/MagneticStripeFailureException.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/MagneticStripeFailureException.class
new file mode 100644
index 0000000..0f8b1e6
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/MagneticStripeFailureException.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Numeral.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Numeral.class
new file mode 100644
index 0000000..ac8cc6e
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/Numeral.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/PLUCodedItem.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/PLUCodedItem.class
new file mode 100644
index 0000000..941940c
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/PLUCodedItem.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/PriceLookupCode.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/PriceLookupCode.class
new file mode 100644
index 0000000..0884227
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/PriceLookupCode.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/TapFailureException.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/TapFailureException.class
new file mode 100644
index 0000000..8d9b145
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/TapFailureException.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/AbstractDevice$Phase.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/AbstractDevice$Phase.class
new file mode 100644
index 0000000..1dae3ed
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/AbstractDevice$Phase.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/AbstractDevice.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/AbstractDevice.class
new file mode 100644
index 0000000..aff6c5e
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/AbstractDevice.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/Acceptor.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/Acceptor.class
new file mode 100644
index 0000000..9043506
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/Acceptor.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/BanknoteDispenser.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/BanknoteDispenser.class
new file mode 100644
index 0000000..a829b5d
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/BanknoteDispenser.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/BanknoteSlot.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/BanknoteSlot.class
new file mode 100644
index 0000000..f18b4a4
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/BanknoteSlot.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/BanknoteStorageUnit.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/BanknoteStorageUnit.class
new file mode 100644
index 0000000..21d4eff
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/BanknoteStorageUnit.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/BanknoteValidator.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/BanknoteValidator.class
new file mode 100644
index 0000000..a42c54f
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/BanknoteValidator.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/BarcodeScanner.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/BarcodeScanner.class
new file mode 100644
index 0000000..093246f
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/BarcodeScanner.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/BidirectionalChannel.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/BidirectionalChannel.class
new file mode 100644
index 0000000..8ae0603
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/BidirectionalChannel.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/CardReader.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/CardReader.class
new file mode 100644
index 0000000..1a090b0
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/CardReader.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/CoinDispenser.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/CoinDispenser.class
new file mode 100644
index 0000000..d069691
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/CoinDispenser.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/CoinSlot.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/CoinSlot.class
new file mode 100644
index 0000000..db8f809
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/CoinSlot.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/CoinStorageUnit.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/CoinStorageUnit.class
new file mode 100644
index 0000000..db1e2c4
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/CoinStorageUnit.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/CoinTray.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/CoinTray.class
new file mode 100644
index 0000000..6f49c78
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/CoinTray.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/CoinValidator.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/CoinValidator.class
new file mode 100644
index 0000000..de514e7
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/CoinValidator.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/DisabledException.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/DisabledException.class
new file mode 100644
index 0000000..5c66261
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/DisabledException.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/ElectronicScale.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/ElectronicScale.class
new file mode 100644
index 0000000..a9314d0
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/ElectronicScale.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/Emitter.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/Emitter.class
new file mode 100644
index 0000000..b23e858
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/Emitter.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/EmptyException.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/EmptyException.class
new file mode 100644
index 0000000..dc98a0f
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/EmptyException.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/FlowThroughEmitter.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/FlowThroughEmitter.class
new file mode 100644
index 0000000..7db53cc
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/FlowThroughEmitter.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/FromStorageEmitter.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/FromStorageEmitter.class
new file mode 100644
index 0000000..bc15cfc
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/FromStorageEmitter.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/OverloadException.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/OverloadException.class
new file mode 100644
index 0000000..ce0e2cd
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/OverloadException.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/ReceiptPrinter.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/ReceiptPrinter.class
new file mode 100644
index 0000000..4db506b
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/ReceiptPrinter.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/SelfCheckoutStation.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/SelfCheckoutStation.class
new file mode 100644
index 0000000..4c8882f
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/SelfCheckoutStation.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/SimulationException.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/SimulationException.class
new file mode 100644
index 0000000..d616ae5
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/SimulationException.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/UnidirectionalChannel.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/UnidirectionalChannel.class
new file mode 100644
index 0000000..964485e
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/UnidirectionalChannel.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/AbstractDeviceObserver.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/AbstractDeviceObserver.class
new file mode 100644
index 0000000..3b3f3af
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/AbstractDeviceObserver.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/BanknoteDispenserObserver.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/BanknoteDispenserObserver.class
new file mode 100644
index 0000000..ef277e1
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/BanknoteDispenserObserver.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/BanknoteSlotObserver.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/BanknoteSlotObserver.class
new file mode 100644
index 0000000..8fa6c54
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/BanknoteSlotObserver.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/BanknoteStorageUnitObserver.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/BanknoteStorageUnitObserver.class
new file mode 100644
index 0000000..dbec2ad
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/BanknoteStorageUnitObserver.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/BanknoteValidatorObserver.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/BanknoteValidatorObserver.class
new file mode 100644
index 0000000..b779d7e
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/BanknoteValidatorObserver.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/BarcodeScannerObserver.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/BarcodeScannerObserver.class
new file mode 100644
index 0000000..3ef8e5f
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/BarcodeScannerObserver.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/CardReaderObserver.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/CardReaderObserver.class
new file mode 100644
index 0000000..21606de
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/CardReaderObserver.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/CoinDispenserObserver.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/CoinDispenserObserver.class
new file mode 100644
index 0000000..7910341
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/CoinDispenserObserver.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/CoinSlotObserver.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/CoinSlotObserver.class
new file mode 100644
index 0000000..bd71242
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/CoinSlotObserver.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/CoinStorageUnitObserver.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/CoinStorageUnitObserver.class
new file mode 100644
index 0000000..b922285
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/CoinStorageUnitObserver.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/CoinTrayObserver.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/CoinTrayObserver.class
new file mode 100644
index 0000000..1391af5
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/CoinTrayObserver.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/CoinValidatorObserver.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/CoinValidatorObserver.class
new file mode 100644
index 0000000..b11003b
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/CoinValidatorObserver.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/ElectronicScaleObserver.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/ElectronicScaleObserver.class
new file mode 100644
index 0000000..6bf0d70
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/ElectronicScaleObserver.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/ReceiptPrinterObserver.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/ReceiptPrinterObserver.class
new file mode 100644
index 0000000..9cd53cf
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/ReceiptPrinterObserver.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/TouchScreenObserver.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/TouchScreenObserver.class
new file mode 100644
index 0000000..ef726bb
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/devices/observers/TouchScreenObserver.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/products/BarcodedProduct.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/products/BarcodedProduct.class
new file mode 100644
index 0000000..aba29ee
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/products/BarcodedProduct.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/products/PLUCodedProduct.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/products/PLUCodedProduct.class
new file mode 100644
index 0000000..80746e5
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/products/PLUCodedProduct.class differ
diff --git a/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/products/Product.class b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/products/Product.class
new file mode 100644
index 0000000..b3888c1
Binary files /dev/null and b/SCS - Hardware - v1.0/bin/org/lsmr/selfcheckout/products/Product.class differ
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/Banknote.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/Banknote.java
new file mode 100644
index 0000000..ad0981e
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/Banknote.java	
@@ -0,0 +1,66 @@
+package org.lsmr.selfcheckout;
+
+import java.math.BigDecimal;
+import java.util.Currency;
+
+import org.lsmr.selfcheckout.devices.SimulationException;
+
+/**
+ * Instances of this class represent individual banknotes. The value of a
+ * banknote is assumed to always be a positive integer multiple of the base
+ * currency.
+ */
+public class Banknote {
+	private int value;
+	private Currency currency;
+
+	/**
+	 * Constructs a banknote.
+	 * @param currency
+	 *            The currency represented by this banknote.
+	 * @param value
+	 *            The value of the banknote, in multiples of the unit of currency.
+	 * 
+	 * @throws SimulationException
+	 *             If the value is &le;0.
+	 * @throws SimulationException
+	 *             If currency is null.
+	 */
+	public Banknote(Currency currency, int value) {
+		if(currency == null)
+			throw new SimulationException(new NullPointerException("currency is null"));
+
+		if(value <= 0)
+			throw new SimulationException(
+				new IllegalArgumentException("The value must be greater than 0: the argument passed was " + value));
+
+		this.value = value;
+		this.currency = currency;
+	}
+
+	/**
+	 * Accessor for the value.
+	 * 
+	 * @return The value of the banknote. Should always be &gt;0.
+	 */
+	public int getValue() {
+		return value;
+	}
+
+	/**
+	 * Accessor for the currency.
+	 * 
+	 * @return The currency for this banknote. Note that this is not the same as the
+	 *             "denomination" (e.g., a Canadian $10 bill is worth 10 Canadian
+	 *             dollars, so a Canadian $10 bill would have currency "Canadian
+	 *             dollars").
+	 */
+	public Currency getCurrency() {
+		return currency;
+	}
+
+	@Override
+	public String toString() {
+		return Integer.toString(value) + " " + currency;
+	}
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/Barcode.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/Barcode.java
new file mode 100644
index 0000000..b989b61
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/Barcode.java	
@@ -0,0 +1,109 @@
+package org.lsmr.selfcheckout;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+
+import org.lsmr.selfcheckout.devices.SimulationException;
+
+/**
+ * Represents a barcode value (not the graphic barcode itself). Real-world
+ * barcodes are a sequence of digits, so that is what is modelled here.
+ */
+public class Barcode {
+	private Numeral[] digits;
+
+	/**
+	 * Constructs a barcode from an array of numerals.
+	 * 
+	 * @param code
+	 *            An array of numerals.
+	 * @throws SimulationException
+	 *             If any character in the input is not a digit between 0 and 9,
+	 *             inclusive.
+	 * @throws SimulationException
+	 *             If the code is null
+	 * @throws SimulationException
+	 *             If the code's length is &lt;1 or &gt;48.
+	 */
+	public Barcode(Numeral[] code) {
+		if(code == null)
+			throw new SimulationException(new NullPointerException("code is null"));
+
+		digits = new Numeral[code.length];
+
+		if(code.length < 1)
+			throw new SimulationException(
+				new IllegalArgumentException("A barcode cannot contain less than one digit."));
+
+		if(code.length > 48)
+			throw new SimulationException(
+				new IllegalArgumentException("A barcode cannot contain more than forty-eight digits."));
+
+		for(int i = 0; i < code.length; i++) {
+			if(code[i] == null)
+				throw new SimulationException(new NullPointerException("code[" + i + "] is null"));
+
+			digits[i] = code[i];
+		}
+	}
+
+	/**
+	 * Gets the count of digits in this code.
+	 * 
+	 * @return The count of digits.
+	 */
+	public int digitCount() {
+		return digits.length;
+	}
+
+	/**
+	 * Gets the digit at the indicated index within the code.
+	 * 
+	 * @param index
+	 *            The index of the digit, &ge;0 and &lt;count.
+	 * @return The digit at the indicated index.
+	 * @throws SimulationException
+	 *             If the index is outside the legal range.
+	 */
+	public Numeral getDigitAt(int index) {
+		try {
+			return digits[index];
+		}
+		catch(IndexOutOfBoundsException e) {
+			throw new SimulationException(e);
+		}
+	}
+
+	@Override
+	public String toString() {
+		char[] characters = new char[digits.length];
+
+		for(int i = 0; i < digits.length; i++)
+			characters[i] = Character.forDigit(digits[i].getValue(), 10);
+
+		return new String(characters);
+	}
+
+	@Override
+	public boolean equals(Object object) {
+		if(object instanceof Barcode) {
+			Barcode other = (Barcode)object;
+
+			if(other.digits.length != digits.length)
+				return false;
+
+			for(int i = 0; i < digits.length; i++)
+				if(!digits[i].equals(other.digits[i]))
+					return false;
+
+			return true;
+		}
+
+		return false;
+	}
+
+	@Override
+	public int hashCode() {
+		return Arrays.hashCode(digits);
+	}
+}
\ No newline at end of file
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/BarcodedItem.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/BarcodedItem.java
new file mode 100644
index 0000000..cc57193
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/BarcodedItem.java	
@@ -0,0 +1,41 @@
+package org.lsmr.selfcheckout;
+
+import org.lsmr.selfcheckout.devices.SimulationException;
+import org.lsmr.selfcheckout.products.Product;
+
+/**
+ * Represents items for sale, each with a particular barcode and weight.
+ */
+public class BarcodedItem extends Item {
+	private Barcode barcode;
+
+	/**
+	 * Basic constructor.
+	 * 
+	 * @param kind
+	 *            The kind of product that this item is.
+	 * @param weightInGrams
+	 *            The real weight of the item.
+	 * @throws SimulationException
+	 *             If the barcode is null.
+	 * @throws SimulationException
+	 *             If the weight is &le;0.
+	 */
+	public BarcodedItem(Barcode barcode, double weightInGrams) {
+		super(weightInGrams);
+
+		if(barcode == null)
+			throw new SimulationException(new NullPointerException("barcode is null"));
+
+		this.barcode = barcode;
+	}
+
+	/**
+	 * Gets the barcode of this item.
+	 * 
+	 * @return The barcode.
+	 */
+	public Barcode getBarcode() {
+		return barcode;
+	}
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/BlockedCardException.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/BlockedCardException.java
new file mode 100644
index 0000000..63b13ba
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/BlockedCardException.java	
@@ -0,0 +1,15 @@
+package org.lsmr.selfcheckout;
+
+import java.io.IOException;
+
+/**
+ * Represents exceptions arising from a blocked card.
+ */
+public class BlockedCardException extends IOException {
+	private static final long serialVersionUID = 8824192400137175094L;
+
+	/**
+	 * Create an exception.
+	 */
+	public BlockedCardException() {}
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/Card.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/Card.java
new file mode 100644
index 0000000..e3f6fb9
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/Card.java	
@@ -0,0 +1,289 @@
+package org.lsmr.selfcheckout;
+
+import java.io.IOException;
+import java.util.Random;
+import java.util.concurrent.ThreadLocalRandom;
+
+import org.lsmr.selfcheckout.devices.SimulationException;
+
+/**
+ * Represents plastic cards (e.g., credit cards, debit cards, membership cards).
+ */
+public final class Card {
+	private final String type;
+	private final String number;
+	private final String cardholder;
+	private final String cvv;
+	private final String pin;
+	public final boolean isTapEnabled;
+	public final boolean hasChip;
+	private int failedTrials = 0;
+	private boolean isBlocked;
+
+	/**
+	 * Create a card instance.
+	 * 
+	 * @param type
+	 *            The type of the card.
+	 * @param number
+	 *            The number of the card. This has to be a string of digits.
+	 * @param cardholder
+	 *            The name of the cardholder.
+	 * @param cvv
+	 *            The card verification value (CVV), a 3- or 4-digit value often on
+	 *            the back of the card. This can be null.
+	 * @param pin
+	 *            The personal identification number (PIN) for access to the card.
+	 *            This can be null if the card has no chip.
+	 * @param isTapEnabled
+	 *            Whether this card is capable of being tapped.
+	 * @param hasChip
+	 *            Whether this card has a chip.
+	 * @throws SimulationException
+	 *             If type, number, or cardholder is null.
+	 * @throws SimulationException
+	 *             If hasChip is true but pin is null.
+	 */
+	public Card(String type, String number, String cardholder, String cvv, String pin, boolean isTapEnabled,
+		boolean hasChip) {
+		if(type == null)
+			throw new SimulationException(new NullPointerException("type is null"));
+
+		if(number == null)
+			throw new SimulationException(new NullPointerException("number is null"));
+
+		if(cardholder == null)
+			throw new SimulationException(new NullPointerException("cardholder is null"));
+
+		if(hasChip && pin == null)
+			throw new SimulationException(new NullPointerException("has chip but pin is null"));
+
+		this.type = type;
+		this.number = number;
+		this.cardholder = cardholder;
+		this.cvv = cvv;
+		this.pin = pin;
+		this.isTapEnabled = isTapEnabled;
+		this.hasChip = hasChip;
+	}
+
+	private static final Random random = new Random(0);
+	private static final double PROBABILITY_OF_MAGNETIC_STRIPE_FAILURE = 0.01;
+	private static final double PROBABILITY_OF_TAP_FAILURE = 0.005;
+	private static final double PROBABILITY_OF_INSERT_FAILURE = 0.001;
+	private static final double PROBABILITY_OF_MAGNETIC_STRIPE_CORRUPTION = 0.001;
+	private static final double PROBABILITY_OF_CHIP_CORRUPTION = 0.00001;
+
+	/**
+	 * Simulates the action of swiping the card.
+	 * 
+	 * @return The card data.
+	 * @throws IOException
+	 *             If anything went wrong with the data transfer.
+	 */
+	public final CardSwipeData swipe() throws IOException {
+		if(isBlocked)
+			throw new BlockedCardException();
+
+		if(random.nextDouble() <= PROBABILITY_OF_MAGNETIC_STRIPE_FAILURE)
+			throw new MagneticStripeFailureException();
+
+		return new CardSwipeData();
+	}
+
+	/**
+	 * Simulates the action of tapping the card.
+	 * 
+	 * @return The card data.
+	 * @throws IOException
+	 *             If anything went wrong with the data transfer.
+	 */
+	public final CardTapData tap() throws IOException {
+		if(isBlocked)
+			throw new BlockedCardException();
+
+		if(isTapEnabled) {
+			if(random.nextDouble() <= PROBABILITY_OF_TAP_FAILURE)
+				throw new TapFailureException();
+
+			return new CardTapData();
+		}
+
+		return null;
+	}
+
+	/**
+	 * Simulates the action of inserting the card.
+	 * 
+	 * @return The card data.
+	 * @throws IOException
+	 *             If anything went wrong with the data transfer.
+	 */
+	public final CardInsertData insert(String pin) throws IOException {
+		if(isBlocked)
+			throw new BlockedCardException();
+
+		if(hasChip) {
+			if(random.nextDouble() <= PROBABILITY_OF_INSERT_FAILURE)
+				throw new ChipFailureException();
+
+			return new CardInsertData(pin);
+		}
+
+		return null;
+	}
+
+	private String randomize(String original, double probability) {
+		if(random.nextDouble() <= probability) {
+			int length = original.length();
+			int index = random.nextInt(length);
+			String first;
+
+			if(index == 0)
+				first = "";
+			else
+				first = original.substring(0, index);
+
+			char second = original.charAt(index);
+			second++;
+
+			String third;
+
+			if(index == length - 1)
+				third = "";
+			else
+				third = original.substring(index + 1, length);
+
+			return first + second + third;
+		}
+
+		return original;
+	}
+
+	/**
+	 * The abstract base type of card data.
+	 */
+	public interface CardData {
+		/**
+		 * Gets the type of the card.
+		 * 
+		 * @return The type of the card.
+		 */
+		public String getType();
+
+		/**
+		 * Gets the number of the card.
+		 * 
+		 * @return The number of the card.
+		 */
+		public String getNumber();
+
+		/**
+		 * Gets the cardholder's name.
+		 * 
+		 * @return The cardholder's name.
+		 */
+		public String getCardholder();
+
+		/**
+		 * Gets the card verification value (CVV) of the card.
+		 * 
+		 * @return The CVV of the card.
+		 * @throws UnsupportedOperationException
+		 *             If this operation is unsupported by this object.
+		 */
+		public String getCVV();
+	}
+
+	/**
+	 * The data from swiping a card.
+	 */
+	public class CardSwipeData implements CardData {
+		@Override
+		public String getType() {
+			return randomize(type, PROBABILITY_OF_MAGNETIC_STRIPE_CORRUPTION);
+		}
+
+		@Override
+		public String getNumber() {
+			return randomize(number, PROBABILITY_OF_MAGNETIC_STRIPE_CORRUPTION);
+		}
+
+		@Override
+		public String getCardholder() {
+			return randomize(cardholder, PROBABILITY_OF_MAGNETIC_STRIPE_CORRUPTION);
+		}
+
+		@Override
+		public String getCVV() {
+			throw new UnsupportedOperationException();
+		}
+	}
+
+	/**
+	 * The data from tapping a card.
+	 */
+	public final class CardTapData implements CardData {
+		@Override
+		public String getType() {
+			return randomize(type, PROBABILITY_OF_CHIP_CORRUPTION);
+		}
+
+		@Override
+		public String getNumber() {
+			return randomize(number, PROBABILITY_OF_CHIP_CORRUPTION);
+		}
+
+		@Override
+		public String getCardholder() {
+			return randomize(cardholder, PROBABILITY_OF_CHIP_CORRUPTION);
+		}
+
+		@Override
+		public String getCVV() {
+			return randomize(cvv, PROBABILITY_OF_CHIP_CORRUPTION);
+		}
+	}
+
+	/**
+	 * The data from inserting a card.
+	 */
+	public final class CardInsertData implements CardData {
+		CardInsertData(String pin) throws InvalidPINException {
+			if(!testPIN(pin))
+				throw new InvalidPINException();
+		}
+
+		@Override
+		public String getType() {
+			return randomize(type, PROBABILITY_OF_CHIP_CORRUPTION);
+		}
+
+		@Override
+		public String getNumber() {
+			return randomize(number, PROBABILITY_OF_CHIP_CORRUPTION);
+		}
+
+		@Override
+		public String getCardholder() {
+			return randomize(cardholder, PROBABILITY_OF_CHIP_CORRUPTION);
+		}
+
+		@Override
+		public String getCVV() {
+			return randomize(cvv, PROBABILITY_OF_CHIP_CORRUPTION);
+		}
+
+		private boolean testPIN(String pinToTest) {
+			if(pinToTest == pin) {
+				failedTrials = 0;
+				return true;
+			}
+
+			if(++failedTrials >= 3)
+				isBlocked = true;
+
+			return false;
+		}
+	}
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/ChipFailureException.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/ChipFailureException.java
new file mode 100644
index 0000000..971cf50
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/ChipFailureException.java	
@@ -0,0 +1,15 @@
+package org.lsmr.selfcheckout;
+
+import java.io.IOException;
+
+/**
+ * Represents exceptions arising from failures of the chip.
+ */
+public class ChipFailureException extends IOException {
+	private static final long serialVersionUID = 3518203688837080092L;
+
+	/**
+	 * Create an exception.
+	 */
+	public ChipFailureException() {}
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/Coin.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/Coin.java
new file mode 100644
index 0000000..5681c26
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/Coin.java	
@@ -0,0 +1,98 @@
+package org.lsmr.selfcheckout;
+
+import java.math.BigDecimal;
+import java.util.Currency;
+
+import org.lsmr.selfcheckout.devices.SimulationException;
+
+/**
+ * Instances of this class represent individual coins.
+ */
+public class Coin {
+	private BigDecimal value;
+	private Currency currency;
+
+	/**
+	 * Rather than specifying a currency for every coin, a default currency can be
+	 * specified which will be used when the currency is not specified.
+	 */
+	public static Currency DEFAULT_CURRENCY;
+
+	/**
+	 * Constructs a coin, using the default currency.
+	 * 
+	 * @param value
+	 *            The value of the coin, in multiples of the unit of currency.
+	 * @throws SimulationException
+	 *             If the value is &le;0.
+	 * @throws SimulationException
+	 *             If the argument is null.
+	 */
+	public Coin(BigDecimal value) {
+		if(value == null)
+			throw new SimulationException(new NullPointerException("value is null"));
+
+		if(DEFAULT_CURRENCY == null)
+			throw new SimulationException(new NullPointerException("Default currency is null"));
+
+		if(value.compareTo(BigDecimal.ZERO) <= 0)
+			throw new SimulationException(
+				new IllegalArgumentException("The value must be greater than 0: the argument passed was " + value));
+
+		this.value = value;
+		this.currency = DEFAULT_CURRENCY;
+	}
+		
+	/**
+	 * Constructs a coin.
+	 * 
+	 * @param currency
+	 *            The currency represented by this coin.
+	 * @param value
+	 *            The value of the coin, in multiples of the unit of currency.
+	 * @throws SimulationException
+	 *             If the value is &le;0.
+	 * @throws SimulationException
+	 *             If either argument is null.
+	 */
+	public Coin(Currency currency, BigDecimal value) {
+		if(value == null)
+			throw new SimulationException(new NullPointerException("value is null"));
+
+		if(currency == null)
+			throw new SimulationException(new NullPointerException("currency is null"));
+
+		if(value.compareTo(BigDecimal.ZERO) <= 0)
+			throw new SimulationException(
+				new IllegalArgumentException("The value must be greater than 0: the argument passed was " + value));
+
+		this.value = value;
+		this.currency = currency;
+	}
+
+	/**
+	 * Accessor for the value.
+	 * 
+	 * @return The value of the coin. Should always be greater than 0.
+	 */
+	public BigDecimal getValue() {
+		return value;
+	}
+
+	/**
+	 * Accessor for the currency.
+	 * 
+	 * @return The currency for this coin. Note that this is not the same as the
+	 *             "denomination" (e.g., a Canadian dime is worth 0.1 Canadian
+	 *             dollars, so a Canadian dime would have currency "Canadian
+	 *             dollars").
+	 */
+	public Currency getCurrency() {
+		return currency;
+	}
+
+	@Override
+	public String toString() {
+		return value.toString() + " " + currency;
+	}
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/IllegalDigitException.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/IllegalDigitException.java
new file mode 100644
index 0000000..d93a133
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/IllegalDigitException.java	
@@ -0,0 +1,19 @@
+package org.lsmr.selfcheckout;
+
+/**
+ * Signals that an illegal character has been used where a digit (0-9) was
+ * expected.
+ */
+public class IllegalDigitException extends IllegalArgumentException {
+	private static final long serialVersionUID = 3352152121776245096L;
+
+	/**
+	 * Constructs an exception with an error message.
+	 * 
+	 * @param message
+	 *            The error message to display.
+	 */
+	public IllegalDigitException(String message) {
+		super(message);
+	}
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/InvalidPINException.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/InvalidPINException.java
new file mode 100644
index 0000000..2d0b327
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/InvalidPINException.java	
@@ -0,0 +1,15 @@
+package org.lsmr.selfcheckout;
+
+import java.io.IOException;
+
+/**
+ * Represents exceptions arising from entry of an invalid PIN.
+ */
+public class InvalidPINException extends IOException {
+	private static final long serialVersionUID = 5461848339919309513L;
+
+	/**
+	 * Create an exception.
+	 */
+	public InvalidPINException() {}
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/Item.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/Item.java
new file mode 100644
index 0000000..3279604
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/Item.java	
@@ -0,0 +1,35 @@
+package org.lsmr.selfcheckout;
+
+import org.lsmr.selfcheckout.devices.SimulationException;
+import org.lsmr.selfcheckout.products.Product;
+
+/**
+ * Abstract base class of items for sale, each with a particular weight.
+ */
+public abstract class Item {
+	private double weightInGrams;
+
+	/**
+	 * Constructs an item with the indicated weight.
+	 * 
+	 * @param weightInGrams
+	 *            The weight of the item.
+	 * @throws SimulationException
+	 *             If the weight is &le;0.
+	 */
+	protected Item(double weightInGrams) {
+		if(weightInGrams <= 0.0)
+			throw new SimulationException(new IllegalArgumentException("The weight has to be positive."));
+
+		this.weightInGrams = weightInGrams;
+	}
+
+	/**
+	 * The weight of the item, in grams.
+	 * 
+	 * @return The weight in grams.
+	 */
+	public double getWeight() {
+		return weightInGrams;
+	}
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/MagneticStripeFailureException.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/MagneticStripeFailureException.java
new file mode 100644
index 0000000..ba6fb5e
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/MagneticStripeFailureException.java	
@@ -0,0 +1,15 @@
+package org.lsmr.selfcheckout;
+
+import java.io.IOException;
+
+/**
+ * Represents exceptions arising from failures of the magnetic stripe.
+ */
+public class MagneticStripeFailureException extends IOException {
+	private static final long serialVersionUID = -4703845851722394414L;
+
+	/**
+	 * Create an exception.
+	 */
+	public MagneticStripeFailureException() {}
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/Numeral.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/Numeral.java
new file mode 100644
index 0000000..3ba954f
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/Numeral.java	
@@ -0,0 +1,59 @@
+package org.lsmr.selfcheckout;
+
+/**
+ * Represents numerals (i.e., number characters) referred to as "Arabic numbers"
+ * in English.
+ */
+public enum Numeral {
+	one((byte)1), two((byte)2), three((byte)3), four((byte)4), five((byte)5), six((byte)6), seven((byte)7),
+	eight((byte)8), nine((byte)9), zero((byte)0);
+
+	private byte value;
+
+	private Numeral(byte value) {
+		this.value = value;
+	}
+
+	/**
+	 * Obtains the numeric value of the numeral.
+	 * 
+	 * @return The numeric value of the numeral.
+	 */
+	public byte getValue() {
+		return value;
+	}
+
+	/**
+	 * Converts a number between 0 and 9 into the corresponding numeral.
+	 * 
+	 * @param number
+	 *            The number to convert. It must be between 0 and 9, inclusive.
+	 * @return {@link IllegalDigitException} If the number is less than 0 or greater than 9.
+	 */
+	public static Numeral valueOf(byte number) {
+		switch(number) {
+		case 0:
+			return zero;
+		case 1:
+			return one;
+		case 2:
+			return two;
+		case 3:
+			return three;
+		case 4:
+			return four;
+		case 5:
+			return five;
+		case 6:
+			return six;
+		case 7:
+			return seven;
+		case 8:
+			return eight;
+		case 9:
+			return nine;
+		default:
+			throw new IllegalDigitException("The number " + number + " does not correspond to a numeral.");
+		}
+	}
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/PLUCodedItem.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/PLUCodedItem.java
new file mode 100644
index 0000000..a74dbdf
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/PLUCodedItem.java	
@@ -0,0 +1,37 @@
+package org.lsmr.selfcheckout;
+
+import org.lsmr.selfcheckout.devices.SimulationException;
+import org.lsmr.selfcheckout.products.Product;
+
+/**
+ * Represents items for sale, each with a particular barcode and weight.
+ */
+public class PLUCodedItem extends Item {
+	private PriceLookupCode pluCode;
+
+	/**
+	 * Basic constructor.
+	 * 
+	 * @param kind
+	 *            The kind of product that this item is.
+	 * @param weightInGrams
+	 *            The actual weight of the item.
+	 */
+	public PLUCodedItem(PriceLookupCode pluCode, double weightInGrams) {
+		super(weightInGrams);
+		
+		if(pluCode == null)
+			throw new SimulationException(new NullPointerException("pluCode is null"));
+		
+		this.pluCode = pluCode;
+	}
+
+	/**
+	 * Gets the PLU code of this item.
+	 * 
+	 * @return The PLU code.
+	 */
+	public PriceLookupCode getPLUCode() {
+		return pluCode;
+	}
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/PriceLookupCode.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/PriceLookupCode.java
new file mode 100644
index 0000000..d44590d
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/PriceLookupCode.java	
@@ -0,0 +1,114 @@
+package org.lsmr.selfcheckout;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+
+import org.lsmr.selfcheckout.devices.SimulationException;
+
+/**
+ * Represents a PLU value, a sequence of digits that, in principle, could lie
+ * anywhere in the range 0000-99999. Specific subranges are reserved for specific
+ * purposes in the real world, but we will not worry about that here.
+ */
+public class PriceLookupCode {
+	private Numeral[] numerals;
+
+	/**
+	 * Constructs a PLU code from a string of numerals. There must be at least 4
+	 * digits and at most 5.
+	 * 
+	 * @param code
+	 *            A string of digits.
+	 * @throws SimulationException
+	 *             If any character in the input is not a digit between 0 and 9,
+	 *             inclusive.
+	 * @throws SimulationException
+	 *             If the code contains less than 4 digits or more than 5 digits.
+	 * @throws NullPointerException
+	 *             If code is null.
+	 */
+	public PriceLookupCode(String code) {
+		if(code == null)
+			throw new SimulationException(new NullPointerException("code is null"));
+
+		char[] charArray = code.toCharArray();
+		numerals = new Numeral[charArray.length];
+
+		if(code.length() > 5)
+			throw new SimulationException(
+				new IllegalArgumentException("The code cannot contain more than five digits."));
+
+		if(code.length() < 4)
+			throw new SimulationException(
+				new IllegalArgumentException("The code cannot contain less than four digits."));
+
+		for(int i = 0; i < charArray.length; i++) {
+			try {
+				numerals[i] = Numeral.valueOf((byte)Character.digit(charArray[i], 10));
+			}
+			catch(IllegalDigitException e) {
+				throw new SimulationException(e);
+			}
+		}
+	}
+
+	/**
+	 * Gets the count of numerals in this code.
+	 * 
+	 * @return The count of numerals.
+	 */
+	public int numeralCount() {
+		return numerals.length;
+	}
+
+	/**
+	 * Gets the numeral at the indicated index within the code.
+	 * 
+	 * @param index
+	 *            The index of the numeral, &ge;0 and &lt;count.
+	 * @return The numeral at the indicated index.
+	 * @throws SimulationException
+	 *             If the index is outside the legal range.
+	 */
+	public Numeral getNumeralAt(int i) {
+		try {
+			return numerals[i];
+		}
+		catch(IndexOutOfBoundsException e) {
+			throw new SimulationException(e);
+		}
+	}
+
+	@Override
+	public String toString() {
+		char[] characters = new char[numerals.length];
+
+		for(int i = 0; i < numerals.length; i++)
+			characters[i] = Character.forDigit(numerals[i].getValue(), 10);
+
+		return new String(characters);
+	}
+
+	@Override
+	public boolean equals(Object object) {
+		if(object instanceof PriceLookupCode) {
+			PriceLookupCode other = (PriceLookupCode)object;
+
+			if(other.numerals.length != numerals.length)
+				return false;
+
+			for(int i = 0; i < numerals.length; i++)
+				if(!numerals[i].equals(other.numerals[i]))
+					return false;
+
+			return true;
+		}
+
+		return false;
+	}
+
+	@Override
+	public int hashCode() {
+		return Arrays.hashCode(numerals);
+	}
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/TapFailureException.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/TapFailureException.java
new file mode 100644
index 0000000..c1a366c
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/TapFailureException.java	
@@ -0,0 +1,15 @@
+package org.lsmr.selfcheckout;
+
+import java.io.IOException;
+
+/**
+ * Represents exceptions arising from failures of taps.
+ */
+public class TapFailureException extends IOException {
+	private static final long serialVersionUID = -8812895797883270979L;
+
+	/**
+	 * Create an exception.
+	 */
+	public TapFailureException() {}
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/AbstractDevice.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/AbstractDevice.java
new file mode 100644
index 0000000..89f4880
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/AbstractDevice.java	
@@ -0,0 +1,193 @@
+package org.lsmr.selfcheckout.devices;
+
+import java.util.ArrayList;
+
+import org.lsmr.selfcheckout.devices.observers.AbstractDeviceObserver;
+
+/**
+ * The abstract base class for all devices involved in the simulator.
+ * <p>
+ * This class utilizes the Observer design pattern. Subclasses inherit the
+ * attach method, but each must define its own notifyXXX methods.
+ * </p>
+ * <p>
+ * Each device must be coupled to an appropriate observer interface, which
+ * extends AbstractDeviceObserver; the type parameter T represents this
+ * observer.
+ * <p>
+ * <p>
+ * Any individual device can be disabled, which means it will not permit
+ * physical movements to be caused by the software. Any method that could cause
+ * a physical movement will declare that it throws DisabledException.
+ * </p>
+ * 
+ * @param <T>
+ *            The type of observers used for this device. For a device whose
+ *            class is X, its corresponding observer interface would typically
+ *            be XObserver.
+ */
+public abstract class AbstractDevice<T extends AbstractDeviceObserver> {
+	/**
+	 * Used to represent the operation phase of this device.
+	 */
+	protected enum Phase {
+		/**
+		 * The device is being configured.
+		 */
+		CONFIGURATION,
+		/**
+		 * The device is in normal operation.
+		 */
+		NORMAL,
+		/**
+		 * The device has undergone a fatal error requiring physical repair and reset.
+		 */
+		ERROR
+	}
+
+	/**
+	 * The current operation phase of this device.
+	 */
+	protected Phase phase = Phase.CONFIGURATION;
+
+	/**
+	 * Many devices require configuration before their use. Before configuration is
+	 * complete, the device should not operate. Once configuration is complete, any
+	 * further configuration attempts should cause exceptions.
+	 */
+	public void endConfigurationPhase() {
+		phase = Phase.NORMAL;
+	}
+
+	/**
+	 * For testing purposes only. Forces this device into an erroneous state.
+	 */
+	public void forceErrorPhase() {
+		phase = Phase.ERROR;
+	}
+
+	/**
+	 * A list of the registered observers on this device.
+	 */
+	protected ArrayList<T> observers = new ArrayList<>();
+
+	/**
+	 * Locates the indicated observer and removes it such that it will no longer be
+	 * informed of events from this device. If the observer is not currently
+	 * registered with this device, calls to this method will return false, but
+	 * otherwise have no effect.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 * 
+	 * @param observer
+	 *            The observer to remove.
+	 * @return true if the observer was found and removed, false otherwise.
+	 */
+	public final boolean detach(T observer) {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+
+		return observers.remove(observer);
+	}
+
+	/**
+	 * All observers registered with this device are removed. If there are none,
+	 * calls to this method have no effect.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 */
+	public final void detachAll() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+
+		observers.clear();
+	}
+
+	/**
+	 * Registers the indicated observer to receive event notifications from this
+	 * device.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 * 
+	 * @param observer
+	 *            The observer to be added.
+	 */
+	public final void attach(T observer) {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+
+		if(observer == null)
+			throw new SimulationException(new IllegalArgumentException(
+				"This method may not receive null, as it has no analogue in the real world."));
+
+		observers.add(observer);
+	}
+
+	private boolean disabled = false;
+
+	/**
+	 * Disables this device from receiving input and producing output.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 */
+	public final void disable() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		disabled = true;
+		notifyDisabled();
+	}
+
+	private void notifyDisabled() {
+		for(T observer : observers)
+			observer.disabled(this);
+	}
+
+	/**
+	 * Enables this device for receiving input and producing output.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 */
+	public final void enable() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		disabled = false;
+		notifyEnabled();
+	}
+
+	private void notifyEnabled() {
+		for(T observer : observers)
+			observer.enabled(this);
+	}
+
+	/**
+	 * Returns whether this device is currently disabled from receiving input and
+	 * producing output.
+	 * <p>
+	 * This operation is illegal during the configuration phase.
+	 * 
+	 * @return true if the device is disabled; false if the device is enabled.
+	 */
+	public final boolean isDisabled() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		return disabled;
+	}
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/Acceptor.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/Acceptor.java
new file mode 100644
index 0000000..4534b94
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/Acceptor.java	
@@ -0,0 +1,37 @@
+package org.lsmr.selfcheckout.devices;
+
+import org.lsmr.selfcheckout.Coin;
+
+/**
+ * A simple interface for devices that accept things.
+ * 
+ * @param <T>
+ *            The type of the things to accept.
+ */
+public interface Acceptor<T> {
+	/**
+	 * Instructs the device to take the thing as input.
+	 * <p>
+	 * This operation may not be called during the configuration phase.
+	 * 
+	 * @param thing
+	 *            The thing to be taken as input.
+	 * @throws OverloadException
+	 *             If the device does not have enough space for the thing.
+	 * @throws DisabledException
+	 *             If the device is disabled.
+	 */
+	public void accept(T thing) throws OverloadException, DisabledException;
+
+	/**
+	 * Checks whether the device has enough space to expect one more thing. If this
+	 * method returns true, an immediate call to accept should not throw
+	 * CapacityExceededException, unless an asynchronous addition has occurred in
+	 * the meantime.
+	 * <p>
+	 * This operation may not be called during the configuration phase.
+	 * 
+	 * @return true If there is space; otherwise, false.
+	 */
+	public boolean hasSpace();
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/BanknoteDispenser.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/BanknoteDispenser.java
new file mode 100644
index 0000000..de25f9c
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/BanknoteDispenser.java	
@@ -0,0 +1,213 @@
+package org.lsmr.selfcheckout.devices;
+
+import java.util.ArrayList;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Queue;
+
+import org.lsmr.selfcheckout.Banknote;
+import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
+import org.lsmr.selfcheckout.devices.observers.BanknoteDispenserObserver;
+
+/**
+ * Represents a device that stores banknotes (as known as bills, paper money,
+ * etc.) of a particular denomination to dispense them as change.
+ * <p>
+ * Banknote dispensers can receive banknotes from other sources. To simplify the
+ * simulation, no check is performed on the value of each banknote.
+ * </p>
+ */
+public final class BanknoteDispenser extends AbstractDevice<BanknoteDispenserObserver>
+	implements FromStorageEmitter<Banknote> {
+	private int maxCapacity;
+	private Queue<Banknote> queue = new LinkedList<Banknote>();
+	private UnidirectionalChannel<Banknote> sink;
+
+	/**
+	 * Creates a banknote dispenser with the indicated maximum capacity.
+	 * 
+	 * @param capacity
+	 *            The maximum number of banknotes that can be stored in the
+	 *            dispenser. Must be positive.
+	 * @throws SimulationException
+	 *             If capacity is not positive.
+	 */
+	public BanknoteDispenser(int capacity) {
+		if(capacity <= 0)
+			throw new SimulationException(new IllegalArgumentException("Capacity must be positive: " + capacity));
+
+		this.maxCapacity = capacity;
+	}
+
+	/**
+	 * Accesses the current number of banknotes in the dispenser.
+	 * <p>
+	 * This operation is illegal during the configuration phase.
+	 * 
+	 * @return The number of banknotes currently in the dispenser.
+	 */
+	public int size() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		return queue.size();
+	}
+
+	/**
+	 * Allows a set of banknotes to be loaded into the dispenser directly. Existing
+	 * banknotes in the dispenser are not removed.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 * 
+	 * @param banknotes
+	 *            A sequence of banknotes to be added. Each may not be null.
+	 * @throws OverloadException
+	 *             if the number of banknotes to be loaded exceeds the capacity of
+	 *             the dispenser.
+	 * @throws SimulationException
+	 *             If any banknote is null.
+	 */
+	public void load(Banknote... banknotes) throws SimulationException, OverloadException {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+
+		if(maxCapacity < queue.size() + banknotes.length)
+			throw new OverloadException("Capacity of dispenser is exceeded by load");
+
+		for(Banknote banknote : banknotes)
+			if(banknote == null)
+				throw new SimulationException(new NullPointerException("A banknote is null."));
+			else
+				queue.add(banknote);
+
+		notifyBanknotesLoaded(banknotes);
+	}
+
+	/**
+	 * Unloads banknotes from the dispenser directly. Causes a "banknotesUnloaded"
+	 * event to be announced.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 * 
+	 * @return A list of the banknotes unloaded. May be empty. Will never be null.
+	 */
+	public List<Banknote> unload() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+
+		List<Banknote> result = new ArrayList<>(queue);
+		queue.clear();
+
+		notifyBanknotesUnoaded(result.toArray(new Banknote[result.size()]));
+
+		return result;
+	}
+
+	/**
+	 * Connects an output channel to this banknote dispenser. Any existing output
+	 * channels are disconnected. Causes no events to be announced.
+	 * <p>
+	 * This operation is permissible only during the configuration phase.
+	 * 
+	 * @param sink
+	 *            The new output device to act as output. Can be null, which leaves
+	 *            the channel without an output.
+	 */
+	public void connect(UnidirectionalChannel<Banknote> sink) {
+		if(phase != Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may only be called during the configuration phase."));
+
+		this.sink = sink;
+	}
+
+	/**
+	 * Returns the maximum capacity of this banknote dispenser.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 * 
+	 * @return The capacity. Will be positive.
+	 */
+	public int getCapacity() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+
+		return maxCapacity;
+	}
+
+	/**
+	 * Emits a single banknote from this banknote dispenser. If successful, a
+	 * "banknoteRemoved" event is announced to its observers. If a successful
+	 * banknote removal causes the dispenser to become empty, a "banknotesEmpty"
+	 * event is instead announced to its observers.
+	 * <p>
+	 * This operation is illegal during the configuration phase.
+	 * 
+	 * @throws OverloadException
+	 *             if the output channel is unable to accept another banknote.
+	 * @throws EmptyException
+	 *             if no banknotes are present in the dispenser to release.
+	 * @throws DisabledException
+	 *             if the dispenser is currently disabled.
+	 */
+	public void emit() throws EmptyException, DisabledException, OverloadException {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		if(isDisabled())
+			throw new DisabledException();
+
+		if(queue.size() == 0)
+			throw new EmptyException();
+
+		Banknote banknote = queue.remove();
+
+		if(sink.hasSpace())
+			try {
+				sink.deliver(banknote);
+			}
+			catch(OverloadException e) {
+				// Should never happen
+				phase = Phase.ERROR;
+				throw new SimulationException(e);
+			}
+		else
+			throw new OverloadException("The sink is full.");
+
+		if(queue.isEmpty())
+			notifyBanknotesEmpty();
+		else
+			notifyBanknoteRemoved(banknote);
+	}
+
+	private void notifyBanknoteRemoved(Banknote banknote) {
+		for(BanknoteDispenserObserver observer : observers)
+			observer.banknoteRemoved(this, banknote);
+	}
+
+	private void notifyBanknotesEmpty() {
+		for(BanknoteDispenserObserver observer : observers)
+			observer.banknotesEmpty(this);
+	}
+
+	private void notifyBanknotesLoaded(Banknote[] banknotes) {
+		for(BanknoteDispenserObserver observer : observers)
+			observer.banknotesLoaded(this, banknotes);
+	}
+
+	private void notifyBanknotesUnoaded(Banknote[] banknotes) {
+		for(BanknoteDispenserObserver observer : observers)
+			observer.banknotesUnloaded(this, banknotes);
+	}
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/BanknoteSlot.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/BanknoteSlot.java
new file mode 100644
index 0000000..9037e26
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/BanknoteSlot.java	
@@ -0,0 +1,191 @@
+package org.lsmr.selfcheckout.devices;
+
+import org.lsmr.selfcheckout.Banknote;
+import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
+import org.lsmr.selfcheckout.devices.observers.BanknoteSlotObserver;
+
+/**
+ * Represents a simple banknote slot device that can either accept a banknote or
+ * eject the most recently inserted banknote, leaving it dangling until the
+ * customer removes it, via {@link #removeDanglingBanknote()}.
+ */
+public class BanknoteSlot extends AbstractDevice<BanknoteSlotObserver>
+	implements Acceptor<Banknote>, FlowThroughEmitter<Banknote> {
+	private BidirectionalChannel<Banknote> sink;
+	private boolean invert;
+
+	/**
+	 * Creates a banknote slot.
+	 * 
+	 * @param invert
+	 *            If the slot is to be inverted.
+	 */
+	public BanknoteSlot(boolean invert) {
+		this.invert = invert;
+	}
+
+	/**
+	 * Connects an output channel to the banknote slot. Causes no events.
+	 * <p>
+	 * This operation is permissible only during the configuration phase.
+	 * 
+	 * @param sink
+	 *            Where banknotes are passed into the machine.
+	 */
+	public void connect(BidirectionalChannel<Banknote> sink) {
+		if(phase != Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may only be called during the configuration phase."));
+
+		this.sink = sink;
+	}
+
+	/**
+	 * Tells the banknote slot that the indicated banknote is being inserted. If the
+	 * sink can accept the banknote, the banknote is passed to the sink and a
+	 * "banknoteInserted" event is announced to the slot's observers; otherwise, a
+	 * "banknoteEjected" event is announced to the slot's observers, meaning that
+	 * the banknote is returned to the user.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @param banknote
+	 *            The banknote to be added. Cannot be null.
+	 * @throws DisabledException
+	 *             if the banknote slot is currently disabled.
+	 * @throws SimulationException
+	 *             If the banknote is null.
+	 * @throws OverloadException
+	 *             If a banknote is dangling from the slot.
+	 */
+	public void accept(Banknote banknote) throws DisabledException, OverloadException {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		if(isDisabled())
+			throw new DisabledException();
+
+		if(danglingEjectedBanknote != null)
+			throw new OverloadException("A banknote is dangling from the slot. Remove that before adding another.");
+
+		notifyBanknoteInserted();
+
+		if(!invert && sink.hasSpace()) {
+			try {
+				sink.deliver(banknote);
+			}
+			catch(OverloadException e) {
+				// Should never happen
+				phase = Phase.ERROR;
+				throw new SimulationException(e);
+			}
+		}
+		else {
+			danglingEjectedBanknote = banknote;
+			notifyBanknoteEjected();
+		}
+	}
+
+	private Banknote danglingEjectedBanknote = null;
+
+	/**
+	 * Ejects the indicated banknote, leaving it dangling until the customer grabs
+	 * it.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @param banknote
+	 *            The banknote to be ejected.
+	 * @throws DisabledException
+	 *             If the device is disabled.
+	 * @throws SimulationException
+	 *             If the argument is null.
+	 * @throws SimulationException
+	 *             If a banknote is already dangling from the slot.
+	 */
+	public void emit(Banknote banknote) throws DisabledException, SimulationException {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		if(isDisabled())
+			throw new DisabledException();
+
+		if(banknote == null)
+			throw new SimulationException(new NullPointerException("banknote is null"));
+
+		if(danglingEjectedBanknote != null)
+			throw new SimulationException(
+				"A banknote is already dangling from the slot. Remove that before ejecting another.");
+
+		danglingEjectedBanknote = banknote;
+
+		notifyBanknoteEjected();
+	}
+
+	/**
+	 * Simulates the user removing a banknote that is dangling from the slot.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @return The formerly dangling banknote.
+	 */
+	public Banknote removeDanglingBanknote() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		if(danglingEjectedBanknote == null)
+			throw new SimulationException("A banknote that does not exist cannot be removed.");
+
+		Banknote b = danglingEjectedBanknote;
+		danglingEjectedBanknote = null;
+		notifyBanknoteRemoved();
+
+		return b;
+	}
+
+	/**
+	 * Tests whether a banknote can be accepted by or ejected from this slot.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @return True if the slot is not occupied by a dangling banknote; otherwise,
+	 *             false.
+	 */
+	public boolean hasSpace() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		return danglingEjectedBanknote == null;
+	}
+
+	private void notifyBanknoteInserted() {
+		for(BanknoteSlotObserver observer : observers)
+			observer.banknoteInserted(this);
+	}
+
+	private void notifyBanknoteEjected() {
+		for(BanknoteSlotObserver observer : observers)
+			observer.banknoteEjected(this);
+	}
+
+	private void notifyBanknoteRemoved() {
+		for(BanknoteSlotObserver observer : observers)
+			observer.banknoteRemoved(this);
+	}
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/BanknoteStorageUnit.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/BanknoteStorageUnit.java
new file mode 100644
index 0000000..34e6a81
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/BanknoteStorageUnit.java	
@@ -0,0 +1,199 @@
+package org.lsmr.selfcheckout.devices;
+
+import java.util.Arrays;
+import java.util.List;
+
+import org.lsmr.selfcheckout.Banknote;
+import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
+import org.lsmr.selfcheckout.devices.observers.BanknoteStorageUnitObserver;
+
+/**
+ * Represents devices that store banknotes. They only receive banknotes, not
+ * dispense them. To access the banknotes inside, a human operator needs to
+ * physically remove the banknotes, simulated with the {@link #unload()} method.
+ * A {@link #load(Banknote...)} method is provided for symmetry.
+ */
+public class BanknoteStorageUnit extends AbstractDevice<BanknoteStorageUnitObserver> implements Acceptor<Banknote> {
+	private Banknote[] storage;
+	private int nextIndex = 0;
+
+	/**
+	 * Creates a banknote storage unit that can hold the indicated number of
+	 * banknotes.
+	 * 
+	 * @param capacity
+	 *            The maximum number of banknotes that the unit can hold.
+	 * @throws SimulationException
+	 *             If the capacity is not positive.
+	 */
+	public BanknoteStorageUnit(int capacity) {
+		if(capacity <= 0)
+			throw new SimulationException(new IllegalArgumentException("The capacity must be positive."));
+
+		storage = new Banknote[capacity];
+	}
+
+	/**
+	 * Gets the maximum number of banknotes that this storage unit can hold.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 * 
+	 * @return The capacity.
+	 */
+	public int getCapacity() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+
+		return storage.length;
+	}
+
+	/**
+	 * Gets the current count of banknotes contained in this storage unit.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 * 
+	 * @return The current count.
+	 */
+	public int getBanknoteCount() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+
+		return nextIndex;
+	}
+
+	/**
+	 * Allows a set of banknotes to be loaded into the storage unit directly.
+	 * Existing banknotes in the dispenser are not removed. Causes a
+	 * "banknotesLoaded" event to be announced. Disabling has no effect on
+	 * loading/unloading.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 * 
+	 * @param banknotes
+	 *            A sequence of banknotes to be added. Each cannot be null.
+	 * @throws SimulationException
+	 *             if the number of banknotes to be loaded exceeds the capacity of
+	 *             the unit.
+	 * @throws SimulationException
+	 *             If the banknotes argument is null.
+	 * @throws SimulationException
+	 *             If any banknote is null.
+	 * @throws OverloadException
+	 *             If too many banknotes are stuffed in the unit.
+	 */
+	public void load(Banknote... banknotes) throws SimulationException, OverloadException {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+
+		if(banknotes == null)
+			throw new SimulationException(
+				new NullPointerException("banknotes is null which has no analogue in the real world"));
+
+		if(banknotes.length + nextIndex > storage.length)
+			throw new OverloadException("You tried to stuff too many banknotes in the storage unit.");
+
+		for(Banknote banknote : banknotes)
+			if(banknote == null)
+				throw new SimulationException(
+					new NullPointerException("No banknote may be null, which has no analogue in the real world."));
+
+		System.arraycopy(banknotes, 0, storage, nextIndex, banknotes.length);
+		nextIndex += banknotes.length;
+
+		notifyBanknotesLoaded();
+	}
+
+	/**
+	 * Unloads banknotes from the storage unit directly. Causes a
+	 * "banknotesUnloaded" event to be announced.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 * 
+	 * @return A list of the banknotes unloaded. May be empty. Will never be null.
+	 */
+	public List<Banknote> unload() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+
+		List<Banknote> banknotes = Arrays.asList(storage);
+
+		storage = new Banknote[storage.length];
+		nextIndex = 0;
+		notifyBanknotesUnloaded();
+
+		return banknotes;
+	}
+
+	/**
+	 * Causes the indicated banknote to be added to the storage unit. If successful,
+	 * a "banknoteAdded" event is announced to its observers. If a successful
+	 * banknote addition causes the unit to become full, a "banknotesFull" event is
+	 * instead announced to its observers.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @param banknote
+	 *            The banknote to add.
+	 * @throws DisabledException
+	 *             If the unit is currently disabled.
+	 * @throws SimulationException
+	 *             If banknote is null.
+	 * @throws OverloadException
+	 *             If the unit is already full.
+	 */
+	public void accept(Banknote banknote) throws DisabledException, OverloadException {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		if(isDisabled())
+			throw new DisabledException();
+
+		if(banknote == null)
+			throw new SimulationException(
+				new NullPointerException("banknote is null, which has no analogue in the real world."));
+
+		if(nextIndex < storage.length) {
+			storage[nextIndex++] = banknote;
+
+			if(nextIndex == storage.length)
+				notifyBanknotesFull();
+			else
+				notifyBanknoteAdded();
+		}
+		else
+			throw new OverloadException();
+	}
+
+	@Override
+	public boolean hasSpace() {
+		return nextIndex < storage.length;
+	}
+
+	private void notifyBanknotesLoaded() {
+		for(BanknoteStorageUnitObserver l : observers)
+			l.banknotesLoaded(this);
+	}
+
+	private void notifyBanknotesUnloaded() {
+		for(BanknoteStorageUnitObserver l : observers)
+			l.banknotesUnloaded(this);
+	}
+
+	private void notifyBanknotesFull() {
+		for(BanknoteStorageUnitObserver l : observers)
+			l.banknotesFull(this);
+	}
+
+	private void notifyBanknoteAdded() {
+		for(BanknoteStorageUnitObserver l : observers)
+			l.banknoteAdded(this);
+	}
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/BanknoteValidator.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/BanknoteValidator.java
new file mode 100644
index 0000000..e014ea9
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/BanknoteValidator.java	
@@ -0,0 +1,201 @@
+package org.lsmr.selfcheckout.devices;
+
+import java.util.Arrays;
+import java.util.Currency;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Random;
+
+import org.lsmr.selfcheckout.Banknote;
+import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
+import org.lsmr.selfcheckout.devices.observers.BanknoteValidatorObserver;
+
+/**
+ * Represents a device for optically and/or magnetically validating banknotes.
+ * Banknotes deemed valid are moved to storage; banknotes deemed invalid are
+ * ejected.
+ */
+public final class BanknoteValidator extends AbstractDevice<BanknoteValidatorObserver>
+	implements Acceptor<Banknote>, Emitter<Banknote> {
+	private final Currency currency;
+	private final int[] denominations;
+	private BidirectionalChannel<Banknote> source;
+	private UnidirectionalChannel<Banknote> sink;
+
+	/**
+	 * Creates a banknote validator that recognizes banknotes of the specified
+	 * denominations (i.e., values) and currency.
+	 * 
+	 * @param currency
+	 *            The kind of currency to accept.
+	 * @param denominations
+	 *            An array of the valid banknote denominations (like $5, $10, etc.)
+	 *            to accept. Each value must be &gt;0 and unique in this array.
+	 * @throws SimulationException
+	 *             If either argument is null.
+	 * @throws SimulationException
+	 *             If the denominations array does not contain at least one value.
+	 * @throws SimulationException
+	 *             If any value in the denominations array is non-positive.
+	 * @throws SimulationException
+	 *             If any value in the denominations array is non-unique.
+	 */
+	public BanknoteValidator(Currency currency, int[] denominations) {
+		if(currency == null)
+			throw new SimulationException(
+				new NullPointerException("currency is null, which has no analogue in the real world."));
+
+		if(denominations == null)
+			throw new SimulationException(
+				new NullPointerException("denominations is null, which has no analogue in the real world."));
+
+		if(denominations.length < 1)
+			throw new SimulationException(new IllegalArgumentException("There must be at least one denomination."));
+
+		this.currency = currency;
+		Arrays.sort(denominations);
+
+		HashSet<Integer> set = new HashSet<>();
+
+		for(int denomination : denominations) {
+			if(denomination <= 0)
+				throw new SimulationException(
+					new IllegalArgumentException("Non-positive denomination detected: " + denomination + "."));
+
+			if(set.contains(denomination))
+				throw new SimulationException(new IllegalArgumentException(
+					"Each denomination must be unique, but " + denomination + " is repeated."));
+
+			set.add(denomination);
+		}
+
+		this.denominations = denominations;
+	}
+
+	/**
+	 * Connects input and output channels to the banknote validator. Causes no events.
+	 * <p>
+	 * This operation is permissible only during the configuration phase.
+	 * 
+	 * @param source
+	 *            The channel from which banknotes normally arrive for validation,
+	 *            and to which invalid banknotes will be ejected.
+	 * @param sink
+	 *            The channel to which all valid banknotes are routed.
+	 */
+	public void connect(BidirectionalChannel<Banknote> source, UnidirectionalChannel<Banknote> sink) {
+		if(phase != Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may only be called during the configuration phase."));
+
+		this.source = source;
+		this.sink = sink;
+	}
+
+	private final Random pseudoRandomNumberGenerator = new Random();
+	private static final int PROBABILITY_OF_FALSE_REJECTION = 1; /* out of 100 */
+
+	private boolean isValid(Banknote banknote) {
+		if(currency.equals(banknote.getCurrency()))
+			for(int denomination : denominations)
+				if(denomination == banknote.getValue())
+					return pseudoRandomNumberGenerator.nextInt(100) >= PROBABILITY_OF_FALSE_REJECTION;
+
+		return false;
+	}
+
+	/**
+	 * Tells the banknote validator that the indicated banknote is being inserted.
+	 * If the banknote is valid, a "validBanknoteDetected" event is announced to its
+	 * observers; otherwise, an "invalidBanknoteDetected" event is announced to its
+	 * observers.
+	 * <p>
+	 * If there is space in the machine to store a valid banknote, it is passed to
+	 * the sink channel.
+	 * </p>
+	 * <p>
+	 * If there is no space in the machine to store it or the banknote is invalid,
+	 * the banknote is ejected to the source.
+	 * </p>
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @param banknote
+	 *            The banknote to be added. Cannot be null.
+	 * @throws DisabledException
+	 *             if the banknote validator is currently disabled.
+	 * @throws SimulationException
+	 *             If the banknote is null.
+	 */
+	@Override
+	public void accept(Banknote banknote) throws DisabledException {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		if(isDisabled())
+			throw new DisabledException();
+
+		if(banknote == null)
+			throw new SimulationException(new NullPointerException("banknote is null"));
+
+		if(isValid(banknote)) {
+			notifyValidBanknoteDetected(banknote);
+
+			if(sink.hasSpace()) {
+				try {
+					sink.deliver(banknote);
+				}
+				catch(OverloadException e) {
+					// Should never happen
+					phase = Phase.ERROR;
+					throw new SimulationException(e);
+				}
+			}
+			else {
+				try {
+					source.eject(banknote);
+				}
+				catch(OverloadException e) {
+					// Should never happen
+					phase = Phase.ERROR;
+					throw new SimulationException(e);
+				}
+			}
+		}
+		else {
+			notifyInvalidBanknoteDetected();
+
+			try {
+				source.eject(banknote);
+			}
+			catch(OverloadException e) {
+				// Should never happen
+				phase = Phase.ERROR;
+				throw new SimulationException("Unable to route banknote: sink is full");
+			}
+		}
+	}
+
+	@Override
+	public boolean hasSpace() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+
+		return true;
+	}
+
+	private void notifyValidBanknoteDetected(Banknote banknote) {
+		for(BanknoteValidatorObserver observer : observers)
+			observer.validBanknoteDetected(this, banknote.getCurrency(), banknote.getValue());
+	}
+
+	private void notifyInvalidBanknoteDetected() {
+		for(BanknoteValidatorObserver observer : observers)
+			observer.invalidBanknoteDetected(this);
+	}
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/BarcodeScanner.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/BarcodeScanner.java
new file mode 100644
index 0000000..872da0e
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/BarcodeScanner.java	
@@ -0,0 +1,60 @@
+package org.lsmr.selfcheckout.devices;
+
+import java.util.Random;
+
+import org.lsmr.selfcheckout.BarcodedItem;
+import org.lsmr.selfcheckout.Item;
+import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
+import org.lsmr.selfcheckout.devices.observers.BarcodeScannerObserver;
+
+/**
+ * A complex device hidden behind a simple simulation. They can scan and that is
+ * about all.
+ */
+public class BarcodeScanner extends AbstractDevice<BarcodeScannerObserver> {
+	/**
+	 * Create a barcode scanner.
+	 */
+	public BarcodeScanner() {}
+
+	private Random random = new Random();
+	private static final int PROBABILITY_OF_FAILED_SCAN = 10; /* out of 100 */
+
+	/**
+	 * Simulates the customer's action of scanning an item. The result of the scan
+	 * is only announced to any registered observers.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @param item
+	 *            The item to scan. Of course, it will only work if the item has a
+	 *            barcode, and maybe not even then.
+	 * @throws SimulationException
+	 *             If item is null.
+	 */
+	public void scan(Item item) {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		if(isDisabled())
+			return; // silently ignore it
+
+		if(item == null)
+			throw new SimulationException(
+				new NullPointerException("item is null, which has no analogue in the real world."));
+
+		if(item instanceof BarcodedItem && random.nextInt(100) >= PROBABILITY_OF_FAILED_SCAN)
+			notifyBarcodeScanned((BarcodedItem)item);
+
+		// otherwise, silently ignore it
+	}
+
+	private void notifyBarcodeScanned(BarcodedItem item) {
+		for(BarcodeScannerObserver l : observers)
+			l.barcodeScanned(this, item.getBarcode());
+	}
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/BidirectionalChannel.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/BidirectionalChannel.java
new file mode 100644
index 0000000..4d67894
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/BidirectionalChannel.java	
@@ -0,0 +1,69 @@
+package org.lsmr.selfcheckout.devices;
+
+import org.lsmr.selfcheckout.Banknote;
+import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
+
+/**
+ * Represents a simple device (like, say, a tube or just a physical connection)
+ * that moves things between other devices. This channel is bidirectional.
+ * 
+ * @param <T>
+ *            The type of the things to move.
+ */
+public final class BidirectionalChannel<T> {
+	private FlowThroughEmitter<T> source;
+	private Acceptor<T> sink;
+
+	/**
+	 * Constructs a new channel whose input is connected to the indicated source and
+	 * whose output is connected to the indicated sink.
+	 * 
+	 * @param source
+	 *            The device at the output end of the channel.
+	 * @param sink
+	 *            The device at the output end of the channel.
+	 */
+	public BidirectionalChannel(FlowThroughEmitter<T> source, Acceptor<T> sink) {
+		this.source = source;
+		this.sink = sink;
+	}
+
+	/**
+	 * Moves the indicated thing to the source. This method should be called by
+	 * the sink device, and not by an external application.
+	 * 
+	 * @param thing
+	 *            The thing to transport via the channel.
+	 * @throws OverloadException
+	 *             if the sink has no space for the banknote.
+	 * @throws DisabledException
+	 *             if the sink is currently disabled.
+	 */
+	public void eject(T thing) throws OverloadException, DisabledException {
+		source.emit(thing);
+	}
+
+	/**
+	 * Moves the indicated banknote to the sink. This method should be called by the
+	 * source device, and not by an external application.
+	 * 
+	 * @param banknote
+	 *            The banknote to transport via the channel.
+	 * @throws OverloadException
+	 *             if the sink has no space for the banknote.
+	 * @throws DisabledException
+	 *             if the sink is currently disabled.
+	 */
+	public void deliver(T banknote) throws OverloadException, DisabledException {
+		sink.accept(banknote);
+	}
+
+	/**
+	 * Returns whether the sink has space for at least one more banknote.
+	 * 
+	 * @return true if the sink can accept a banknote; false otherwise.
+	 */
+	public boolean hasSpace() {
+		return sink.hasSpace();
+	}
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/CardReader.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/CardReader.java
new file mode 100644
index 0000000..de592f1
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/CardReader.java	
@@ -0,0 +1,185 @@
+package org.lsmr.selfcheckout.devices;
+
+import java.awt.image.BufferedImage;
+import java.io.IOException;
+import java.util.concurrent.ThreadLocalRandom;
+
+import org.lsmr.selfcheckout.Card;
+import org.lsmr.selfcheckout.Card.CardData;
+import org.lsmr.selfcheckout.ChipFailureException;
+import org.lsmr.selfcheckout.MagneticStripeFailureException;
+import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
+import org.lsmr.selfcheckout.devices.observers.CardReaderObserver;
+
+/**
+ * Represents the card reader, capable of tap, chip insert, and swipe. Either
+ * the reader or the card may fail, or the data read in can be corrupted, with
+ * varying probabilities.
+ */
+public class CardReader extends AbstractDevice<CardReaderObserver> {
+	private boolean cardIsInserted = false;
+
+	/**
+	 * Create a card reader.
+	 */
+	public CardReader() {}
+
+	private final static ThreadLocalRandom random = ThreadLocalRandom.current();
+	private final static double PROBABILITY_OF_TAP_FAILURE = 0.01;
+	private final static double PROBABILITY_OF_INSERT_FAILURE = 0.01;
+	private final static double PROBABILITY_OF_SWIPE_FAILURE = 0.1;
+
+	/**
+	 * Tap the card.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @param card
+	 *            The card to tap.
+	 * @return The card's (possibly corrupted) data, or null if the card is not tap
+	 *             enabled.
+	 * @throws IOException
+	 *             If the tap failed (lack of failure does not mean that the data is
+	 *             not corrupted).
+	 */
+	public CardData tap(Card card) throws IOException {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		if(card.isTapEnabled) {
+			notifyCardTapped();
+
+			if(random.nextDouble(0.0, 1.0) > PROBABILITY_OF_TAP_FAILURE) {
+				CardData data = card.tap();
+
+				notifyCardDataRead(data);
+
+				return data;
+			}
+			else
+				throw new ChipFailureException();
+		}
+
+		// else ignore
+		return null;
+	}
+
+	/**
+	 * Swipe the card.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @param card
+	 *            The card to swipe.
+	 * @return The card data.
+	 * @throws IOException
+	 *             If the swipe failed.
+	 */
+	public CardData swipe(Card card) throws IOException {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		notifyCardSwiped();
+
+		if(random.nextDouble(0.0, 1.0) > PROBABILITY_OF_SWIPE_FAILURE) {
+			CardData data = card.swipe();
+
+			notifyCardDataRead(data);
+
+			return data;
+		}
+
+		throw new MagneticStripeFailureException();
+	}
+
+	/**
+	 * Insert the card.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @param card
+	 *            The card to insert.
+	 * @param pin
+	 *            The customer's PIN.
+	 * @return The card data.
+	 * @throws SimulationException
+	 *             If there is already a card in the slot.
+	 * @throws IOException
+	 *             The insertion failed.
+	 */
+	public CardData insert(Card card, String pin) throws IOException {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		if(cardIsInserted)
+			throw new IllegalStateException("There is already a card in the slot");
+
+		cardIsInserted = true;
+
+		notifyCardInserted();
+
+		if(card.hasChip && random.nextDouble(0.0, 1.0) > PROBABILITY_OF_INSERT_FAILURE) {
+			CardData data = card.insert(pin);
+
+			notifyCardDataRead(data);
+
+			return data;
+		}
+
+		throw new ChipFailureException();
+	}
+
+	/**
+	 * Remove the card from the slot.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 */
+	public void remove() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		cardIsInserted = false;
+		notifyCardRemoved();
+	}
+
+	private void notifyCardTapped() {
+		for(CardReaderObserver l : observers)
+			l.cardTapped(this);
+	}
+
+	private void notifyCardInserted() {
+		for(CardReaderObserver l : observers)
+			l.cardInserted(this);
+	}
+
+	private void notifyCardSwiped() {
+		for(CardReaderObserver l : observers)
+			l.cardSwiped(this);
+	}
+
+	private void notifyCardDataRead(CardData data) {
+		for(CardReaderObserver l : observers)
+			l.cardDataRead(this, data);
+	}
+
+	private void notifyCardRemoved() {
+		for(CardReaderObserver l : observers)
+			l.cardRemoved(this);
+	}
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/CoinDispenser.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/CoinDispenser.java
new file mode 100644
index 0000000..e6cdc73
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/CoinDispenser.java	
@@ -0,0 +1,262 @@
+package org.lsmr.selfcheckout.devices;
+
+import java.util.ArrayList;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Queue;
+
+import org.lsmr.selfcheckout.Coin;
+import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
+import org.lsmr.selfcheckout.devices.observers.CoinDispenserObserver;
+
+/**
+ * Represents a device that stores coins of a particular denomination to
+ * dispense them as change.
+ * <p>
+ * Coin dispensers can receive coins from other sources. To simplify the
+ * simulation, no check is performed on the value of each coin, meaning it is an
+ * external responsibility to ensure the correct routing of coins.
+ * </p>
+ */
+public final class CoinDispenser extends AbstractDevice<CoinDispenserObserver>
+	implements Acceptor<Coin>, FromStorageEmitter<Coin> {
+	private int maxCapacity;
+	private Queue<Coin> queue = new LinkedList<Coin>();
+	private UnidirectionalChannel<Coin> sink;
+
+	/**
+	 * Creates a coin dispenser with the indicated maximum capacity.
+	 * 
+	 * @param capacity
+	 *            The maximum number of coins that can be stored in the dispenser.
+	 *            Must be positive.
+	 * @throws SimulationException
+	 *             if capacity is not positive.
+	 */
+	public CoinDispenser(int capacity) {
+		if(capacity <= 0)
+			throw new SimulationException(new IllegalArgumentException("Capacity must be positive: " + capacity));
+
+		this.maxCapacity = capacity;
+	}
+
+	/**
+	 * Accesses the current number of coins in the dispenser.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 * 
+	 * @return The number of coins currently in the dispenser.
+	 */
+	public int size() {
+		return queue.size();
+	}
+
+	/**
+	 * Allows a set of coins to be loaded into the dispenser directly. Existing
+	 * coins in the dispenser are not removed. Causes a "coinsLoaded" event to be
+	 * announced.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 * 
+	 * @param coins
+	 *            A sequence of coins to be added. Each cannot be null.
+	 * @throws OverloadException
+	 *             if the number of coins to be loaded exceeds the capacity of the
+	 *             dispenser.
+	 * @throws SimulationException
+	 *             If any coin is null.
+	 */
+	public void load(Coin... coins) throws SimulationException, OverloadException {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+
+		if(maxCapacity < queue.size() + coins.length)
+			throw new OverloadException("Capacity of dispenser is exceeded by load");
+
+		for(Coin coin : coins)
+			if(coin == null)
+				throw new SimulationException(new NullPointerException("A coin is null"));
+			else
+				queue.add(coin);
+
+		notifyLoad(coins);
+	}
+
+	private void notifyLoad(Coin[] coins) {
+		for(CoinDispenserObserver observer : observers)
+			observer.coinsLoaded(this, coins);
+	}
+
+	/**
+	 * Unloads coins from the dispenser directly. Causes a "coinsUnloaded" event to
+	 * be announced.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 * 
+	 * @return A list of the coins unloaded. May be empty. Will never be null.
+	 */
+	public List<Coin> unload() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+
+		List<Coin> result = new ArrayList<>(queue);
+		queue.clear();
+
+		notifyUnload(result.toArray(new Coin[result.size()]));
+
+		return result;
+	}
+
+	private void notifyUnload(Coin[] coins) {
+		for(CoinDispenserObserver observer : observers)
+			observer.coinsUnloaded(this, coins);
+	}
+
+	/**
+	 * Connects an output channel to this coin dispenser. Any existing output
+	 * channels are disconnected. Causes no events to be announced.
+	 * <p>
+	 * This operation is only permissible during the configuration phase.
+	 * 
+	 * @param sink
+	 *            The new output device to act as output. Can be null, which leaves
+	 *            the channel without an output.
+	 */
+	public void connect(UnidirectionalChannel<Coin> sink) {
+		if(phase != Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may only be called during the configuration phase."));
+
+		this.sink = sink;
+	}
+
+	/**
+	 * Returns the maximum capacity of this coin dispenser.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 * 
+	 * @return The capacity. Will be positive.
+	 */
+	public int getCapacity() {
+		return maxCapacity;
+	}
+
+	/**
+	 * Causes the indicated coin to be added into the dispenser. If successful, a
+	 * "coinAdded" event is announced to its observers. If a successful coin
+	 * addition causes the dispenser to become full, a "coinsFull" event is
+	 * announced to its observers.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @throws DisabledException
+	 *             If the coin dispenser is currently disabled.
+	 * @throws SimulationException
+	 *             If coin is null.
+	 * @throws OverloadException
+	 *             If the coin dispenser is already full.
+	 */
+	@Override
+	public void accept(Coin coin) throws OverloadException, DisabledException {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		if(isDisabled())
+			throw new DisabledException();
+
+		if(coin == null)
+			throw new SimulationException(
+				new NullPointerException("coin is null, which has no analogue in the real world."));
+
+		if(queue.size() >= maxCapacity)
+			throw new OverloadException();
+
+		queue.add(coin);
+		notifyCoinAdded(coin);
+
+		if(queue.size() >= maxCapacity)
+			notifyCoinsFull();
+	}
+
+	/**
+	 * Releases a single coin from this coin dispenser. If successful, a
+	 * "coinRemoved" event is announced to its observers. If a successful coin
+	 * removal causes the dispenser to become empty, a "coinsEmpty" event is
+	 * announced to its observers.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @throws OverloadException
+	 *             If the output channel is unable to accept another coin.
+	 * @throws EmptyException
+	 *             If no coins are present in the dispenser to release.
+	 * @throws DisabledException
+	 *             If the dispenser is currently disabled.
+	 */
+	public void emit() throws OverloadException, EmptyException, DisabledException {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		if(isDisabled())
+			throw new DisabledException();
+
+		if(queue.size() == 0)
+			throw new EmptyException();
+
+		Coin coin = queue.remove();
+
+		notifyCoinRemoved(coin);
+		sink.deliver(coin);
+
+		if(queue.isEmpty())
+			notifyCoinsEmpty();
+	}
+
+	/**
+	 * Returns whether this coin dispenser has enough space to accept at least one
+	 * more coin. Announces no events.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 */
+	@Override
+	public boolean hasSpace() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		return queue.size() < maxCapacity;
+	}
+
+	private void notifyCoinAdded(Coin coin) {
+		for(CoinDispenserObserver observer : observers)
+			observer.coinAdded(this, coin);
+	}
+
+	private void notifyCoinRemoved(Coin coin) {
+		for(CoinDispenserObserver observer : observers)
+			observer.coinRemoved(this, coin);
+	}
+
+	private void notifyCoinsFull() {
+		for(CoinDispenserObserver observer : observers)
+			observer.coinsFull(this);
+	}
+
+	private void notifyCoinsEmpty() {
+		for(CoinDispenserObserver observer : observers)
+			observer.coinsEmpty(this);
+	}
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/CoinSlot.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/CoinSlot.java
new file mode 100644
index 0000000..514af14
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/CoinSlot.java	
@@ -0,0 +1,97 @@
+package org.lsmr.selfcheckout.devices;
+
+import org.lsmr.selfcheckout.Coin;
+import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
+import org.lsmr.selfcheckout.devices.observers.CoinSlotObserver;
+
+/**
+ * Represents a simple coin slot device that has one output channel. The slot is
+ * stupid: it has no functionality other than being enabled/disabled, and cannot
+ * determine the value and currency of the coin.
+ */
+public final class CoinSlot extends AbstractDevice<CoinSlotObserver> implements Acceptor<Coin> {
+	private UnidirectionalChannel<Coin> sink;
+
+	/**
+	 * Creates a coin slot.
+	 */
+	public CoinSlot() {}
+
+	/**
+	 * Connects channels to the coin slot. Causes no events.
+	 * <p>
+	 * This operation is permissible only during the configuration phase.
+	 * 
+	 * @param sink
+	 *            Where coins will always be passed.
+	 */
+	public void connect(UnidirectionalChannel<Coin> sink) {
+		if(phase != Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may only be called during the configuration phase."));
+
+		this.sink = sink;
+	}
+
+	/**
+	 * Tells the coin slot that the indicated coin is being inserted. If the slot is
+	 * enabled, this causes a "coinInserted" event to be announced to its observers.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @param coin
+	 *            The coin to be added. Cannot be null.
+	 * @throws DisabledException
+	 *             If the coin slot is currently disabled.
+	 * @throws SimulationException
+	 *             If coin is null.
+	 * @throws NullPointerException
+	 *             If the coin is null.
+	 */
+	public void accept(Coin coin) throws DisabledException {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		if(isDisabled())
+			throw new DisabledException();
+
+		if(coin == null)
+			throw new SimulationException(new NullPointerException("coin is null"));
+
+		notifyCoinInserted();
+
+		if(sink.hasSpace()) {
+			try {
+				sink.deliver(coin);
+			}
+			catch(OverloadException e) {
+				// Should never happen
+				phase = Phase.ERROR;
+				throw new SimulationException(e);
+			}
+		}
+		else
+			throw new SimulationException("Unable to route coin: Output channel is full");
+	}
+
+	@Override
+	public boolean hasSpace() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		return sink.hasSpace();
+	}
+
+	private void notifyCoinInserted() {
+		for(CoinSlotObserver observer : observers)
+			observer.coinInserted(this);
+	}
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/CoinStorageUnit.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/CoinStorageUnit.java
new file mode 100644
index 0000000..6fc0059
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/CoinStorageUnit.java	
@@ -0,0 +1,186 @@
+package org.lsmr.selfcheckout.devices;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+
+import org.lsmr.selfcheckout.Coin;
+import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
+import org.lsmr.selfcheckout.devices.observers.CoinStorageUnitObserver;
+
+/**
+ * Represents devices that store coins. They only receive coins, not dispense
+ * them. To access the coins inside, a human operator needs to physically remove
+ * the coins, simulated with the {@link #unload()} method. A
+ * {@link #load(Coin...)} method is provided for symmetry.
+ */
+public class CoinStorageUnit extends AbstractDevice<CoinStorageUnitObserver> implements Acceptor<Coin> {
+	private Coin[] storage;
+	private int nextIndex = 0;
+
+	/**
+	 * Creates a coin storage unit that can hold the indicated number of coins.
+	 * 
+	 * @param capacity
+	 *            The maximum number of coins that the unit can hold.
+	 * @throws SimulationException
+	 *             If the capacity is not positive.
+	 */
+	public CoinStorageUnit(int capacity) {
+		if(capacity <= 0)
+			throw new SimulationException(new IllegalArgumentException("The capacity must be positive."));
+
+		storage = new Coin[capacity];
+	}
+
+	/**
+	 * Gets the maximum number of coins that this storage unit can hold.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 * 
+	 * @return The capacity.
+	 */
+	public int getCapacity() {
+		return storage.length;
+	}
+
+	/**
+	 * Gets the current count of coins contained in this storage unit.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 * 
+	 * @return The current count.
+	 */
+	public int getCoinCount() {
+		return nextIndex;
+	}
+
+	/**
+	 * Allows a set of coins to be loaded into the storage unit directly. Existing
+	 * coins in the dispenser are not removed. Causes a "coinsLoaded" event to be
+	 * announced. Disabling has no effect on loading/unloading.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @param coins
+	 *            A sequence of coins to be added. Each cannot be null.
+	 * @throws SimulationException
+	 *             if the number of coins to be loaded exceeds the capacity of the
+	 *             unit.
+	 * @throws SimulationException
+	 *             If coins is null.
+	 * @throws SimulationException
+	 *             If any coin is null.
+	 * @throws OverloadException
+	 *             If too many coins are loaded.
+	 */
+	public void load(Coin... coins) throws SimulationException, OverloadException {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+
+		if(coins == null)
+			throw new SimulationException(
+				new NullPointerException("coins is null, which has no analogue in the real world."));
+
+		if(coins.length + nextIndex > storage.length)
+			throw new OverloadException("You tried to stuff too many coins in the storage unit.");
+
+		for(Coin coin : coins)
+			if(coin == null)
+				throw new SimulationException(new NullPointerException("No coin may be null"));
+
+		System.arraycopy(coins, 0, storage, nextIndex, coins.length);
+		nextIndex += coins.length;
+
+		notifyCoinsLoaded();
+	}
+
+	/**
+	 * Unloads coins from the storage unit directly. Causes a "coinsUnloaded" event
+	 * to be announced.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 * 
+	 * @return A list of the coins unloaded. May be empty. Will never be null.
+	 */
+	public List<Coin> unload() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+
+		List<Coin> coins = Arrays.asList(storage);
+
+		storage = new Coin[storage.length];
+		nextIndex = 0;
+		notifyCoinsUnloaded();
+
+		return coins;
+	}
+
+	/**
+	 * Causes the indicated coin to be added to the storage unit. If successful, a
+	 * "coinAdded" event is announced to its observers. If a successful coin
+	 * addition instead causes the unit to become full, a "coinsFull" event is
+	 * announced to its observers.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @throws DisabledException
+	 *             If the unit is currently disabled.
+	 * @throws SimulationException
+	 *             If coin is null.
+	 * @throws OverloadException
+	 *             If the unit is already full.
+	 */
+	public void accept(Coin coin) throws DisabledException, OverloadException {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		if(isDisabled())
+			throw new DisabledException();
+
+		if(coin == null)
+			throw new SimulationException(new NullPointerException("coin is null"));
+
+		if(nextIndex < storage.length) {
+			storage[nextIndex++] = coin;
+
+			if(nextIndex == storage.length)
+				notifyCoinsFull();
+			else
+				notifyCoinAdded();
+		}
+		else
+			throw new OverloadException();
+	}
+
+	@Override
+	public boolean hasSpace() {
+		return nextIndex < storage.length;
+	}
+
+	private void notifyCoinsLoaded() {
+		for(CoinStorageUnitObserver l : observers)
+			l.coinsLoaded(this);
+	}
+
+	private void notifyCoinsUnloaded() {
+		for(CoinStorageUnitObserver l : observers)
+			l.coinsUnloaded(this);
+	}
+
+	private void notifyCoinsFull() {
+		for(CoinStorageUnitObserver l : observers)
+			l.coinsFull(this);
+	}
+
+	private void notifyCoinAdded() {
+		for(CoinStorageUnitObserver l : observers)
+			l.coinAdded(this);
+	}
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/CoinTray.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/CoinTray.java
new file mode 100644
index 0000000..dabc9c3
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/CoinTray.java	
@@ -0,0 +1,102 @@
+package org.lsmr.selfcheckout.devices;
+
+import java.util.Arrays;
+import java.util.List;
+
+import org.lsmr.selfcheckout.Coin;
+import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
+import org.lsmr.selfcheckout.devices.observers.CoinTrayObserver;
+
+/**
+ * Simulates the tray where dispensed coins go for the user to collect them.
+ */
+public class CoinTray extends AbstractDevice<CoinTrayObserver> implements Acceptor<Coin> {
+	private Coin[] coins;
+	private int nextIndex = 0;
+
+	/**
+	 * Creates a coin tray.
+	 * 
+	 * @param capacity
+	 *            The maximum number of coins that this tray can hold without
+	 *            overflowing.
+	 * @throws SimulationException
+	 *             If the capacity is &le;0.
+	 */
+	public CoinTray(int capacity) {
+		if(capacity <= 0)
+			throw new SimulationException(new IllegalArgumentException("capacity must be positive."));
+
+		coins = new Coin[capacity];
+	}
+
+	/**
+	 * Causes the indicated coin to be added to the tray. A "coinAdded" event is
+	 * announced to observers.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @param coin
+	 *            The coin to add.
+	 * @throws SimulationException
+	 *             If coin is null.
+	 * @throws OverloadException
+	 *             If the tray overflows.
+	 */
+	public void accept(Coin coin) throws OverloadException, DisabledException {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		if(coin == null)
+			throw new SimulationException(
+				new NullPointerException("coin is null, which has no analogue in the real world."));
+
+		if(nextIndex < coins.length) {
+			coins[nextIndex++] = coin;
+			notifyCoinAdded();
+		}
+		else
+			throw new OverloadException("The tray has overflowed.");
+	}
+
+	/**
+	 * Simulates the act of physically removing coins from the try by a user.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @return The list of coins collected. May not be null. May be empty.
+	 */
+	public List<Coin> collectCoins() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		List<Coin> result = Arrays.asList(coins);
+
+		coins = new Coin[coins.length];
+		nextIndex = 0;
+
+		return result;
+	}
+
+	/**
+	 * Returns whether this coin receptacle has enough space to accept at least one
+	 * more coin: always true. Causes no events.
+	 */
+	@Override
+	public boolean hasSpace() {
+		return nextIndex < coins.length;
+	}
+
+	private void notifyCoinAdded() {
+		for(CoinTrayObserver l : observers)
+			l.coinAdded(this);
+	}
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/CoinValidator.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/CoinValidator.java
new file mode 100644
index 0000000..faf47e3
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/CoinValidator.java	
@@ -0,0 +1,268 @@
+package org.lsmr.selfcheckout.devices;
+
+import java.math.BigDecimal;
+import java.util.Collections;
+import java.util.Currency;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Random;
+
+import org.lsmr.selfcheckout.Coin;
+import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
+import org.lsmr.selfcheckout.devices.observers.CoinValidatorObserver;
+
+/**
+ * Represents a device for optically and/or physically validating coins. Coins
+ * deemed valid are moved to storage; coins deemed invalid are ejected.
+ */
+public final class CoinValidator extends AbstractDevice<CoinValidatorObserver> implements Acceptor<Coin> {
+	public final Currency currency;
+	private List<BigDecimal> denominations;
+	private UnidirectionalChannel<Coin> rejectionSink, overflowSink;
+	private Map<BigDecimal, UnidirectionalChannel<Coin>> standardSinks = null;
+
+	/**
+	 * Creates a coin validator that recognizes coins of the specified denominations
+	 * (i.e., values) and currency.
+	 * 
+	 * @param currency
+	 *            The kind of currency to accept.
+	 * @param denominations
+	 *            An array of the valid coin denominations (like $0.05, $0.10, etc.)
+	 *            to accept. Each value must be &gt;0 and unique in this array.
+	 * @throws SimulationException
+	 *             If either argument is null.
+	 * @throws SimulationException
+	 *             If the denominations array does not contain at least one value.
+	 * @throws SimulationException
+	 *             If any value in the denominations array is non-positive.
+	 * @throws SimulationException
+	 *             If any value in the denominations array is non-unique.
+	 */
+	public CoinValidator(Currency currency, List<BigDecimal> denominations) {
+		if(currency == null)
+			throw new SimulationException(
+				new NullPointerException("currency is null, which has no analogue in the real world."));
+
+		if(denominations == null)
+			throw new SimulationException(
+				new NullPointerException("denominations is null, which has no analogue in the real world."));
+
+		if(denominations.size() < 1)
+			throw new SimulationException(new IllegalArgumentException("There must be at least one denomination."));
+
+		this.currency = currency;
+		Collections.sort(denominations);
+
+		standardSinks = new HashMap<>();
+
+		for(BigDecimal denomination : denominations) {
+			if(denomination == null)
+				throw new SimulationException(new NullPointerException("A denomination is null"));
+
+			if(denomination.compareTo(BigDecimal.ZERO) <= 0)
+				throw new SimulationException(
+					new IllegalArgumentException("Non-positive denomination detected: " + denomination + "."));
+
+			if(standardSinks.containsKey(denomination))
+				throw new SimulationException(new IllegalArgumentException(
+					"Each denomination must be unique, but " + denomination + " is repeated."));
+
+			standardSinks.put(denomination, null);
+		}
+
+		this.denominations = denominations;
+	}
+
+	/**
+	 * Connects input and output channels to the coin slot. Causes no events.
+	 * <p>
+	 * This operation is permissible only during the configuration phase.
+	 * 
+	 * @param rejectionSink
+	 *            The channel to which rejected coins are routed.
+	 * @param overflowSink
+	 *            The channel to which valid coins are routed when the normal sink
+	 *            is full.
+	 * @param standardSinks
+	 *            The channels to which valid coins are normally routed. There must
+	 *            be one sink to correspond to each valid currency denomination, and
+	 *            they must be in the same order as the valid denominations.
+	 * @throws SimulationException
+	 *             If any argument is null.
+	 * @throws SimulationException
+	 *             If any standard sink is null.
+	 * @throws SimulationException
+	 *             If the number of standard sinks differs from the number of
+	 *             denominations.
+	 * @throws SimulationException
+	 *             If any sink is used in more than one position.
+	 */
+	public void connect(UnidirectionalChannel<Coin> rejectionSink,
+		Map<BigDecimal, UnidirectionalChannel<Coin>> standardSinks, UnidirectionalChannel<Coin> overflowSink) {
+		if(phase != Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may only be called during the configuration phase."));
+
+		if(rejectionSink == null)
+			throw new SimulationException(
+				new NullPointerException("rejectionSink is null, which has no analogue in the real world."));
+
+		if(overflowSink == null)
+			throw new SimulationException(
+				new NullPointerException("overflowSink is null, which has no analogue in the real world."));
+
+		if(standardSinks == null)
+			throw new SimulationException(
+				new NullPointerException("standardSinks is null, which has no analogue in the real world."));
+
+		if(standardSinks.keySet().size() != denominations.size())
+			throw new SimulationException(
+				new IllegalArgumentException("The number of standard sinks must equal the number of denominations."));
+
+		this.rejectionSink = rejectionSink;
+		this.overflowSink = overflowSink;
+
+		HashSet<UnidirectionalChannel<Coin>> set = new HashSet<>();
+
+		for(BigDecimal denomination : standardSinks.keySet()) {
+			UnidirectionalChannel<Coin> sink = standardSinks.get(denomination);
+			if(sink == null)
+				throw new SimulationException(
+					new NullPointerException("The sink for denomination " + denomination + " is null."));
+			else {
+				if(set.contains(sink))
+					throw new SimulationException(new IllegalArgumentException("Each channel must be unique."));
+
+				set.add(sink);
+			}
+		}
+
+		this.standardSinks = standardSinks;
+
+		if(set.contains(rejectionSink))
+			throw new SimulationException(new IllegalArgumentException("Each channel must be unique."));
+		else
+			set.add(rejectionSink);
+
+		if(set.contains(overflowSink))
+			throw new SimulationException(new IllegalArgumentException("Each channel must be unique."));
+
+		this.overflowSink = overflowSink;
+	}
+
+	private final Random pseudoRandomNumberGenerator = new Random();
+	private static final int PROBABILITY_OF_FALSE_REJECTION = 1; /* out of 100 */
+
+	private boolean isValid(Coin coin) {
+		if(currency.equals(coin.getCurrency()))
+			for(BigDecimal denomination : denominations)
+				if(denomination.equals(coin.getValue()))
+					return pseudoRandomNumberGenerator.nextInt(100) >= PROBABILITY_OF_FALSE_REJECTION;
+
+		return false;
+	}
+
+	/**
+	 * Tells the coin validator that the indicated coin is being inserted. If the
+	 * coin is valid, a "validCoinDetected" event is announced to its observers;
+	 * otherwise, an "invalidCoinDetected" event is announced to its observers.
+	 * <p>
+	 * If there is space in the machine to store a valid coin, it is passed to the
+	 * sink channel corresponding to the denomination of the coin.
+	 * </p>
+	 * <p>
+	 * If there is no space in the machine to store it or the coin is invalid, the
+	 * coin is ejected to the source.
+	 * </p>
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @param coin
+	 *            The coin to be added. Cannot be null.
+	 * @throws DisabledException
+	 *             if the coin validator is currently disabled.
+	 * @throws SimulationException
+	 *             If the coin is null.
+	 * @throws SimulationException
+	 *             If the coin cannot be delivered.
+	 */
+	public void accept(Coin coin) throws DisabledException {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		if(isDisabled())
+			throw new DisabledException();
+
+		if(coin == null)
+			throw new SimulationException(
+				new NullPointerException("coin is null, which has no analogue in the real world."));
+
+		if(isValid(coin)) {
+			notifyValidCoinDetected(coin);
+
+			UnidirectionalChannel<Coin> sink = standardSinks.get(coin.getValue());
+
+			if(sink.hasSpace()) {
+				try {
+					sink.deliver(coin);
+				}
+				catch(OverloadException e) {
+					// Should never happen
+					phase = Phase.ERROR;
+					throw new SimulationException(e);
+				}
+			}
+			else {
+				try {
+					rejectionSink.deliver(coin);
+				}
+				catch(OverloadException e) {
+					// Should never happen
+					phase = Phase.ERROR;
+					throw new SimulationException(e);
+				}
+			}
+		}
+		else {
+			notifyInvalidCoinDetected(coin);
+
+			try {
+				rejectionSink.deliver(coin);
+			}
+			catch(OverloadException e) {
+				// Should never happen
+				phase = Phase.ERROR;
+				throw new SimulationException(e);
+			}
+		}
+	}
+
+	@Override
+	public boolean hasSpace() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		return true; // Since we cannot know yet where a coin will route, assume that it is OK.
+	}
+
+	private void notifyValidCoinDetected(Coin coin) {
+		for(CoinValidatorObserver observer : observers)
+			observer.validCoinDetected(this, coin.getValue());
+	}
+
+	private void notifyInvalidCoinDetected(Coin coin) {
+		for(CoinValidatorObserver observer : observers)
+			observer.invalidCoinDetected(this);
+	}
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/DisabledException.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/DisabledException.java
new file mode 100644
index 0000000..6f1690f
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/DisabledException.java	
@@ -0,0 +1,8 @@
+package org.lsmr.selfcheckout.devices;
+
+/**
+ * Issued when a device cannot perform its usual functions because it has been
+ * disabled.
+ */
+@SuppressWarnings("serial")
+public class DisabledException extends Exception {}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/ElectronicScale.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/ElectronicScale.java
new file mode 100644
index 0000000..ffdc112
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/ElectronicScale.java	
@@ -0,0 +1,171 @@
+package org.lsmr.selfcheckout.devices;
+
+import java.util.ArrayList;
+
+import org.lsmr.selfcheckout.Item;
+import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
+import org.lsmr.selfcheckout.devices.observers.ElectronicScaleObserver;
+
+public class ElectronicScale extends AbstractDevice<ElectronicScaleObserver> {
+	private ArrayList<Item> items = new ArrayList<>();
+
+	private double weightLimitInGrams;
+	private double currentWeightInGrams = 0;
+	private double weightAtLastEvent = 0;
+	private double sensitivity;
+
+	/**
+	 * Constructs an electronic scale with the indicated maximum weight that it can
+	 * handle before going into overload.
+	 * 
+	 * @param weightLimitInGrams
+	 *            The weight threshold beyond which the scale will overload.
+	 * @param sensitivity
+	 *            The number of grams that can be added or removed since the last
+	 *            change event, without causing a new change event.
+	 * @throws SimulationException
+	 *             If either argument is &le;0.
+	 */
+	public ElectronicScale(int weightLimitInGrams, int sensitivity) {
+		if(weightLimitInGrams <= 0)
+			throw new SimulationException(new IllegalArgumentException("The maximum weight cannot be zero or less."));
+
+		if(sensitivity <= 0)
+			throw new SimulationException(new IllegalArgumentException("The sensitivity cannot be zero or less."));
+
+		this.weightLimitInGrams = weightLimitInGrams;
+		this.sensitivity = sensitivity;
+	}
+
+	/**
+	 * Gets the weight limit for the scale.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 * 
+	 * @return The weight limit.
+	 */
+	public double getWeightLimit() {
+		return weightLimitInGrams;
+	}
+
+	/**
+	 * Gets the current weight on the scale.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @return The current weight.
+	 * @throws OverloadException
+	 *             If the weight has overloaded the scale.
+	 */
+	public double getCurrentWeight() throws OverloadException {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		if(currentWeightInGrams <= weightLimitInGrams)
+			return currentWeightInGrams;
+
+		throw new OverloadException();
+	}
+
+	/**
+	 * Gets the sensitivity of the scale. Changes smaller than this limit are not
+	 * noticed or announced.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 * 
+	 * @return The sensitivity.
+	 */
+	public double getSensitivity() {
+		return sensitivity;
+	}
+
+	/**
+	 * Adds an item to the scale.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @param item
+	 *            The item to add.
+	 * @throws SimulationException
+	 *             If the same item is added more than once.
+	 */
+	public void add(Item item) {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		if(items.contains(item))
+			throw new SimulationException("The same item cannot be added more than once to the scale.");
+
+		currentWeightInGrams += item.getWeight();
+
+		items.add(item);
+
+		if(currentWeightInGrams > weightLimitInGrams)
+			notifyOverload();
+		else if(currentWeightInGrams - weightAtLastEvent > sensitivity)
+			notifyWeightChanged();
+	}
+
+	/**
+	 * Removes an item from the scale.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @param item
+	 *            The item to remove.
+	 * @throws SimulationException
+	 *             If the item is not on the scale.
+	 */
+	public void remove(Item item) {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		if(!items.remove(item))
+			throw new SimulationException("The item was not found amongst those on the scale.");
+
+		// To avoid drift in the sum due to round-off error, recalculate the weight.
+		double newWeightInGrams = 0.0;
+		for(Item itemOnScale : items)
+			newWeightInGrams += itemOnScale.getWeight();
+
+		double original = currentWeightInGrams;
+		currentWeightInGrams = newWeightInGrams;
+
+		if(original > weightLimitInGrams && newWeightInGrams <= weightLimitInGrams)
+			notifyOutOfOverload();
+
+		if(currentWeightInGrams <= weightLimitInGrams && weightAtLastEvent - currentWeightInGrams >= sensitivity)
+			notifyWeightChanged();
+	}
+
+	private void notifyOverload() {
+		for(ElectronicScaleObserver l : observers)
+			l.overload(this);
+	}
+
+	private void notifyOutOfOverload() {
+		weightAtLastEvent = currentWeightInGrams;
+
+		for(ElectronicScaleObserver l : observers)
+			l.outOfOverload(this);
+	}
+
+	private void notifyWeightChanged() {
+		weightAtLastEvent = currentWeightInGrams;
+
+		for(ElectronicScaleObserver l : observers)
+			l.weightChanged(this, currentWeightInGrams);
+	}
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/Emitter.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/Emitter.java
new file mode 100644
index 0000000..a8ab600
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/Emitter.java	
@@ -0,0 +1,12 @@
+package org.lsmr.selfcheckout.devices;
+
+import org.lsmr.selfcheckout.Coin;
+
+/**
+ * A simple base interface for devices that emit things.
+ * 
+ * @param <T>
+ *            The type of the things to emit.
+ */
+public interface Emitter<T> {
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/EmptyException.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/EmptyException.java
new file mode 100644
index 0000000..b726903
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/EmptyException.java	
@@ -0,0 +1,9 @@
+package org.lsmr.selfcheckout.devices;
+
+/**
+ * Represents the situation when a device is emptied but an attempt is made to
+ * remove something from it.
+ */
+public class EmptyException extends Exception {
+	private static final long serialVersionUID = 3566954386000387724L;
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/FlowThroughEmitter.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/FlowThroughEmitter.java
new file mode 100644
index 0000000..ff60458
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/FlowThroughEmitter.java	
@@ -0,0 +1,26 @@
+package org.lsmr.selfcheckout.devices;
+
+import org.lsmr.selfcheckout.Coin;
+
+/**
+ * A simple interface for devices that emit things.
+ * 
+ * @param <T>
+ *            The type of the things to emit.
+ */
+public interface FlowThroughEmitter<T> {
+	/**
+	 * Instructs the device to emit a specific thing, meaning that the device is
+	 * being handed this thing to pass onwards.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @param thing
+	 *            The thing to emit.
+	 * @throws DisabledException
+	 *             If the device is disabled.
+	 * @throws OverloadException
+	 *             If the receiving device is already full.
+	 */
+	public void emit(T thing) throws DisabledException, OverloadException;
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/FromStorageEmitter.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/FromStorageEmitter.java
new file mode 100644
index 0000000..ddb964a
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/FromStorageEmitter.java	
@@ -0,0 +1,26 @@
+package org.lsmr.selfcheckout.devices;
+
+import org.lsmr.selfcheckout.Coin;
+
+/**
+ * A simple interface for devices that emit things.
+ * 
+ * @param <T>
+ *            The type of the things to emit.
+ */
+public interface FromStorageEmitter<T> {
+	/**
+	 * Instructs the device to emit one thing, meaning that the device stores a set
+	 * of things and one of them is to be emitted.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @throws DisabledException
+	 *             If the device is disabled.
+	 * @throws EmptyException
+	 *             If the device is empty and cannot emit.
+	 * @throws OverloadException
+	 *             If the receiving device is already full.
+	 */
+	public void emit() throws DisabledException, EmptyException, OverloadException;
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/OverloadException.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/OverloadException.java
new file mode 100644
index 0000000..ee5e927
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/OverloadException.java	
@@ -0,0 +1,24 @@
+package org.lsmr.selfcheckout.devices;
+
+/**
+ * Represents situations where a device has been overloaded, in terms of weight,
+ * quantity of items, etc.
+ */
+public class OverloadException extends Exception {
+	private static final long serialVersionUID = 7813659161520664284L;
+
+	/**
+	 * Create an exception without an error message.
+	 */
+	public OverloadException() {}
+
+	/**
+	 * Create an exception with an error message.
+	 * 
+	 * @param message
+	 *            The error message to use.
+	 */
+	public OverloadException(String message) {
+		super(message);
+	}
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/ReceiptPrinter.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/ReceiptPrinter.java
new file mode 100644
index 0000000..9f2abe6
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/ReceiptPrinter.java	
@@ -0,0 +1,204 @@
+package org.lsmr.selfcheckout.devices;
+
+import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
+import org.lsmr.selfcheckout.devices.observers.ReceiptPrinterObserver;
+
+/**
+ * Represents printers used for printing receipts. A printer has a finite amount
+ * of paper (measured in lines that can be printed) and ink (measured in
+ * characters that can be printed).
+ * <p>
+ * Since this is a simulation, each character is assumed to require the same
+ * amount of ink (except blanks and newlines) and the font size is fixed.
+ * </p>
+ */
+public class ReceiptPrinter extends AbstractDevice<ReceiptPrinterObserver> {
+	public static final int MAXIMUM_INK = 1 << 20;
+	public static final int MAXIMUM_PAPER = 1 << 10;
+	private int charactersOfInkRemaining = 0;
+	private int linesOfPaperRemaining = 0;
+	private StringBuilder sb = new StringBuilder();
+	private int charactersOnCurrentLine = 0;
+
+	/**
+	 * Represents the maximum number of characters that can fit on one line of the
+	 * receipt. This is a simulation, so the font is assumed monospaced and of fixed
+	 * size.
+	 */
+	public final static int CHARACTERS_PER_LINE = 60;
+
+	/**
+	 * Creates a receipt printer.
+	 */
+	public ReceiptPrinter() {}
+
+	/**
+	 * Prints a single character to the receipt. Whitespace characters are ignored,
+	 * with the exception of ' ' (blank) and '\n', which signals to move to the
+	 * start of the next line.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @param c
+	 *            The character to print.
+	 * @throws SimulationException
+	 *             If there is no ink or no paper in the printer.
+	 * @throws SimulationException
+	 *             If the extra character would spill off the end of the line.
+	 */
+	public void print(char c) {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		if(c == '\n') {
+			--linesOfPaperRemaining;
+			charactersOnCurrentLine = 0;
+		}
+		else if(c != ' ' && Character.isWhitespace(c))
+			return;
+		else if(charactersOnCurrentLine == CHARACTERS_PER_LINE)
+			throw new SimulationException("The line is too long. Add a newline");
+		else if(linesOfPaperRemaining == 0)
+			throw new SimulationException("There is no paper in the printer.");
+		else
+			charactersOnCurrentLine++;
+
+		if(!Character.isWhitespace(c)) {
+			if(charactersOfInkRemaining == 0)
+				throw new SimulationException("There is no ink in the printer");
+
+			charactersOfInkRemaining--;
+		}
+
+		sb.append(c);
+
+		if(charactersOfInkRemaining == 0)
+			notifyOutOfInk();
+
+		if(linesOfPaperRemaining == 0)
+			notifyOutOfPaper();
+	}
+
+	/**
+	 * The receipt is finished printing, so cut it so that the customer can easily
+	 * remove it. Failure to cut the paper means that the receipt will not be
+	 * retrievable by the customer.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 */
+	public void cutPaper() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		lastReceipt = sb.toString();
+	}
+
+	private String lastReceipt = null;
+
+	/**
+	 * Simulates the customer removing the receipt. Failure to cut the receipt
+	 * first, or to always remove the receipt means that the customer will end up
+	 * with other customers' receipts too!
+	 * 
+	 * @return The receipt if it has been cut; otherwise, null.
+	 */
+	public String removeReceipt() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		String receipt = lastReceipt;
+
+		if(lastReceipt != null) {
+			lastReceipt = null;
+			sb = new StringBuilder();
+		}
+		else
+			throw new SimulationException("A non-existent receipt cannot be removed.");
+
+		return receipt;
+	}
+
+	/**
+	 * Adds ink to the printer. Simulates a human doing the adding.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 * 
+	 * @param quantity
+	 *            The quantity of characters-worth of ink to add.
+	 * @throws SimulationException
+	 *             If the quantity is negative.
+	 * @throws SimulationException
+	 *             If the total of the existing ink plus the added quantity is
+	 *             greater than the printer's capacity.
+	 */
+	public void addInk(int quantity) {
+		if(quantity < 0)
+			throw new SimulationException("Are you trying to remove ink?");
+
+		if(charactersOfInkRemaining + quantity > MAXIMUM_INK)
+			throw new SimulationException("You spilled a bunch of ink!");
+
+		if(quantity > 0) {
+			charactersOfInkRemaining += quantity;
+			notifyInkAdded();
+		}
+	}
+
+	/**
+	 * Adds paper to the printer. Simulates a human doing the adding.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 * 
+	 * @param quantity
+	 *            The quantity of lines-worth of paper to add.
+	 * @throws SimulationException
+	 *             If the quantity is negative.
+	 * @throws SimulationException
+	 *             If the total of the existing paper plus the added quantity is
+	 *             greater than the printer's capacity.
+	 */
+	public void addPaper(int units) {
+		if(units < 0)
+			throw new SimulationException("Are you trying to remove paper?");
+
+		if(linesOfPaperRemaining + units > MAXIMUM_PAPER)
+			throw new SimulationException("You may have broken the printer, jamming so much in there!");
+
+		if(units > 0) {
+			linesOfPaperRemaining += units;
+			notifyPaperAdded();
+		}
+	}
+
+	private void notifyOutOfInk() {
+		for(ReceiptPrinterObserver l : observers)
+			l.outOfInk(this);
+	}
+
+	private void notifyInkAdded() {
+		for(ReceiptPrinterObserver l : observers)
+			l.inkAdded(this);
+	}
+
+	private void notifyOutOfPaper() {
+		for(ReceiptPrinterObserver l : observers)
+			l.outOfPaper(this);
+	}
+
+	private void notifyPaperAdded() {
+		for(ReceiptPrinterObserver l : observers)
+			l.paperAdded(this);
+	}
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/SelfCheckoutStation.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/SelfCheckoutStation.java
new file mode 100644
index 0000000..edb9a0c
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/SelfCheckoutStation.java	
@@ -0,0 +1,257 @@
+package org.lsmr.selfcheckout.devices;
+
+import java.math.BigDecimal;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Currency;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+import javax.sound.sampled.AudioSystem;
+
+import org.lsmr.selfcheckout.Banknote;
+import org.lsmr.selfcheckout.Coin;
+
+/**
+ * Simulates the overall self-checkout station.
+ * <p>
+ * A self-checkout possesses the following units of hardware that the customer
+ * can see and interact with:
+ * <ul>
+ * <li>one electronic scale, with a configurable maximum weight before it
+ * overloads;</li>
+ * <li>one receipt printer;</li>
+ * <li>one card reader;</li>
+ * <li>one scanner;</li>
+ * <li>one input slot for banknotes;</li>
+ * <li>one output slot for banknotes;</li>
+ * <li>one input slot for coins;</li>
+ * <li>one output tray for coins; and,</li>
+ * <li>one speaker for audio output (note: you should directly use the
+ * {@link AudioSystem} class, if you want to produce sounds).</li>
+ * </ul>
+ * </p>
+ * <p>
+ * In addition, these units of hardware are accessible to personnel with a key
+ * to unlock the front of the station:
+ * <li>one banknote storage unit, with configurable capacity;</li>
+ * <li>one or more banknote dispensers, one for each supported denomination of
+ * banknote, as configured;</li>
+ * <li>one coin storage unit, with configurable capacity; and,</li>
+ * <li>one or more coin dispensers, one for each supported denomination of coin,
+ * as configured.</li>
+ * </ul>
+ * </p>
+ * <p>
+ * And finally, there are certain, additional units of hardware that would only
+ * be accessible to someone with the appropriate tools (like a screwdriver,
+ * crowbar, or sledge hammer):
+ * <ul>
+ * <li>one banknote validator; and</li>
+ * <li>one coin validator.</li>
+ * </ul>
+ * </p>
+ * <p>
+ * Many of these devices are interconnected, to permit coins or banknotes to
+ * pass between them. Specifically:
+ * <ul>
+ * <li>the coin slot is connected to the coin validator (this is a
+ * one-directional chain of devices);</li>
+ * <li>the coin validator is connected to each of the coin dispensers (i.e., the
+ * coin dispensers can be replenished with coins entered by customers), to the
+ * coin storage unit (for any overflow coins that do not fit in the dispensers),
+ * and to the coin tray for any rejected coins either because the coins are
+ * invalid or because even the overflow storage unit is full (this is a
+ * one-directional chain of devices);
+ * <li>each coin dispenser is connected to the coin tray, to provide change
+ * (this is a one-directional chain of devices);</li>
+ * <li>the banknote input slot is connected to the banknote validator (this is a
+ * <b>two</b>-directional chain of devices as an entered banknotes that are
+ * rejected by the validator can be returned to the customer);</li>
+ * <li>the banknote validator is connected to the banknote storage unit (this is
+ * a one-directional chain of devices); and,</li>
+ * <li>each banknote dispenser is connected to the output banknote slot; these
+ * dispensers cannot be replenished by banknotes provided by customers (this is
+ * a one-directional chain of devices).</li>
+ * </ul>
+ * </p>
+ * <p>
+ * All other functionality of the system must be performed in software,
+ * installed on the self-checkout station through custom observer classes
+ * implementing the various observer interfaces provided.
+ * </p>
+ * <p>
+ * Note that banknote denominations are required to be positive integers, while
+ * coin denominations are positive decimal values ({@link BigDecimal} is used
+ * for the latter to avoid roundoff problems arising from floating-point
+ * operations).
+ */
+public class SelfCheckoutStation {
+	public final ElectronicScale scale;
+	public final ReceiptPrinter printer;
+	public final CardReader cardReader;
+	public final BarcodeScanner scanner;
+
+	public final BanknoteSlot banknoteInput, banknoteOutput;
+	public final BanknoteValidator banknoteValidator;
+	public final BanknoteStorageUnit banknoteStorage;
+	public final static int BANKNOTE_STORAGE_CAPACITY = 1000;
+	public final int[] banknoteDenominations;
+	public final Map<Integer, BanknoteDispenser> banknoteDispensers;
+	public final static int BANKNOTE_DISPENSER_CAPACITY = 100;
+
+	public final CoinSlot coinSlot;
+	public final CoinValidator coinValidator;
+	public final CoinStorageUnit coinStorage;
+	public static final int COIN_STORAGE_CAPACITY = 1000;
+	public final List<BigDecimal> coinDenominations;
+	public final Map<BigDecimal, CoinDispenser> coinDispensers;
+	public static final int COIN_DISPENSER_CAPACITY = 200;
+	public final CoinTray coinTray;
+	public static final int COIN_TRAY_CAPACITY = 20;
+
+	/**
+	 * Creates a self-checkout station.
+	 * 
+	 * @param currency
+	 *            The kind of currency permitted.
+	 * @param banknoteDenominations
+	 *            The set of denominations (i.e., $5, $10, etc.) to accept.
+	 * @param coinDenominations
+	 *            The set of denominations (i.e., $0.05, $0.10, etc.) to accept.
+	 * @param scaleMaximumWeight
+	 *            The most weight that can be placed on the scale before it
+	 *            overloads.
+	 * @param scaleSensitivity
+	 *            Any weight changes smaller than this will not be detected or
+	 *            announced.
+	 * @throws SimulationException
+	 *             If any argument is null or negative.
+	 * @throws SimulationException
+	 *             If the number of banknote or coin denominations is &lt;1.
+	 */
+	public SelfCheckoutStation(Currency currency, int[] banknoteDenominations, BigDecimal[] coinDenominations,
+		int scaleMaximumWeight, int scaleSensitivity) {
+		if(currency == null || banknoteDenominations == null || coinDenominations == null)
+			throw new SimulationException(new NullPointerException("No argument may be null."));
+
+		if(scaleMaximumWeight <= 0)
+			throw new SimulationException(new IllegalArgumentException("The scale's maximum weight must be positive."));
+
+		if(scaleSensitivity <= 0)
+			throw new SimulationException(new IllegalArgumentException("The scale's sensitivity must be positive."));
+
+		if(banknoteDenominations.length == 0)
+			throw new SimulationException(
+				new IllegalArgumentException("There must be at least one allowable banknote denomination defined."));
+
+		if(coinDenominations.length == 0)
+			throw new SimulationException(
+				new IllegalArgumentException("There must be at least one allowable coin denomination defined."));
+
+		// Create the devices.
+		scale = new ElectronicScale(scaleMaximumWeight, scaleSensitivity);
+		printer = new ReceiptPrinter();
+		cardReader = new CardReader();
+		scanner = new BarcodeScanner();
+
+		this.banknoteDenominations = banknoteDenominations;
+		banknoteInput = new BanknoteSlot(false);
+		banknoteValidator = new BanknoteValidator(currency, banknoteDenominations);
+		banknoteStorage = new BanknoteStorageUnit(BANKNOTE_STORAGE_CAPACITY);
+		banknoteOutput = new BanknoteSlot(true);
+
+		banknoteDispensers = new HashMap<>();
+
+		for(int i = 0; i < banknoteDenominations.length; i++)
+			banknoteDispensers.put(banknoteDenominations[i], new BanknoteDispenser(BANKNOTE_DISPENSER_CAPACITY));
+
+		this.coinDenominations = Arrays.asList(coinDenominations);
+		coinSlot = new CoinSlot();
+		coinValidator = new CoinValidator(currency, this.coinDenominations);
+		coinStorage = new CoinStorageUnit(COIN_STORAGE_CAPACITY);
+		coinTray = new CoinTray(COIN_TRAY_CAPACITY);
+
+		coinDispensers = new HashMap<>();
+
+		for(int i = 0; i < coinDenominations.length; i++)
+			coinDispensers.put(coinDenominations[i], new CoinDispenser(COIN_DISPENSER_CAPACITY));
+
+		// Hook up everything.
+		interconnect(banknoteInput, banknoteValidator);
+		interconnect(banknoteValidator, banknoteStorage);
+
+		for(BanknoteDispenser dispenser : banknoteDispensers.values())
+			interconnect(dispenser, banknoteOutput);
+
+		interconnect(coinSlot, coinValidator);
+		interconnect(coinValidator, coinTray, coinDispensers, coinStorage);
+
+		for(CoinDispenser coinDispenser : coinDispensers.values())
+			interconnect(coinDispenser, coinTray);
+
+		scale.endConfigurationPhase();
+		printer.endConfigurationPhase();
+		cardReader.endConfigurationPhase();
+		scanner.endConfigurationPhase();
+
+		banknoteInput.endConfigurationPhase();
+		banknoteValidator.endConfigurationPhase();
+		banknoteStorage.endConfigurationPhase();
+		banknoteOutput.endConfigurationPhase();
+
+		for(BanknoteDispenser bd : banknoteDispensers.values())
+			bd.endConfigurationPhase();
+
+		coinSlot.endConfigurationPhase();
+		coinValidator.endConfigurationPhase();
+		coinStorage.endConfigurationPhase();
+		coinTray.endConfigurationPhase();
+
+		for(CoinDispenser cd : coinDispensers.values())
+			cd.endConfigurationPhase();
+	}
+
+	private BidirectionalChannel<Banknote> validatorSource;
+
+	private void interconnect(BanknoteSlot slot, BanknoteValidator validator) {
+		validatorSource = new BidirectionalChannel<Banknote>(slot, validator);
+		slot.connect(validatorSource);
+	}
+
+	private void interconnect(BanknoteValidator validator, BanknoteStorageUnit storage) {
+		UnidirectionalChannel<Banknote> bc = new UnidirectionalChannel<Banknote>(storage);
+		validator.connect(validatorSource, bc);
+	}
+
+	private void interconnect(BanknoteDispenser dispenser, BanknoteSlot slot) {
+		UnidirectionalChannel<Banknote> bc = new UnidirectionalChannel<Banknote>(slot);
+		dispenser.connect(bc);
+	}
+
+	private void interconnect(CoinSlot slot, CoinValidator validator) {
+		UnidirectionalChannel<Coin> cc = new UnidirectionalChannel<Coin>(validator);
+		slot.connect(cc);
+	}
+
+	private void interconnect(CoinValidator validator, CoinTray tray, Map<BigDecimal, CoinDispenser> dispensers,
+		CoinStorageUnit storage) {
+		UnidirectionalChannel<Coin> rejectChannel = new UnidirectionalChannel<Coin>(tray);
+		Map<BigDecimal, UnidirectionalChannel<Coin>> dispenserChannels = new HashMap<BigDecimal, UnidirectionalChannel<Coin>>();
+
+		for(BigDecimal denomination : dispensers.keySet()) {
+			CoinDispenser dispenser = dispensers.get(denomination);
+			dispenserChannels.put(denomination, new UnidirectionalChannel<Coin>(dispenser));
+		}
+
+		UnidirectionalChannel<Coin> overflowChannel = new UnidirectionalChannel<Coin>(storage);
+
+		validator.connect(rejectChannel, dispenserChannels, overflowChannel);
+	}
+
+	private void interconnect(CoinDispenser dispenser, CoinTray tray) {
+		UnidirectionalChannel<Coin> cc = new UnidirectionalChannel<Coin>(tray);
+		dispenser.connect(cc);
+	}
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/SimulationException.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/SimulationException.java
new file mode 100644
index 0000000..5ef08ac
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/SimulationException.java	
@@ -0,0 +1,32 @@
+package org.lsmr.selfcheckout.devices;
+
+/**
+ * An exception that can be raised when the behaviour within the simulator makes
+ * no sense, typically when it has not been configured correctly. This is
+ * different from an exception being raised because the preconditions of a
+ * component are violated, but that would make sense in the real world.
+ */
+@SuppressWarnings("serial")
+public class SimulationException extends RuntimeException {
+	private String nested;
+
+	/**
+	 * Constructor used to nest other exceptions.
+	 * 
+	 * @param nested
+	 *            An underlying exception that is to be wrapped.
+	 */
+	public SimulationException(Exception nested) {
+		this.nested = nested.toString();
+	}
+
+	/**
+	 * Basic constructor.
+	 * 
+	 * @param message
+	 *            An explanatory message of the problem.
+	 */
+	public SimulationException(String message) {
+		nested = message;
+	}
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/UnidirectionalChannel.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/UnidirectionalChannel.java
new file mode 100644
index 0000000..0174032
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/UnidirectionalChannel.java	
@@ -0,0 +1,49 @@
+package org.lsmr.selfcheckout.devices;
+
+import org.lsmr.selfcheckout.Coin;
+
+/**
+ * Represents a simple device (like, say, a tube) that allows things to move in
+ * one direction between other devices.
+ * 
+ * @param <T>
+ *            The type of the things to be transported.
+ */
+public class UnidirectionalChannel<T> {
+	private Acceptor<T> sink;
+
+	/**
+	 * Constructs a new coin channel whose output is connected to the indicated
+	 * sink.
+	 * 
+	 * @param sink
+	 *            The device at the output end of the channel.
+	 */
+	public UnidirectionalChannel(Acceptor<T> sink) {
+		this.sink = sink;
+	}
+
+	/**
+	 * Moves the indicated thing to the sink. This method should be called by the
+	 * source device, and not by an external application.
+	 * 
+	 * @param thing
+	 *            The thing to transport via the channel.
+	 * @throws OverloadException
+	 *             If the sink has no space for the thing.
+	 * @throws DisabledException
+	 *             If the sink is currently disabled.
+	 */
+	public void deliver(T thing) throws OverloadException, DisabledException {
+		sink.accept(thing);
+	}
+
+	/**
+	 * Returns whether the sink has space for at least one more thing.
+	 * 
+	 * @return true if the channel can accept a thing; false otherwise.
+	 */
+	public boolean hasSpace() {
+		return sink.hasSpace();
+	}
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/AbstractDeviceObserver.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/AbstractDeviceObserver.java
new file mode 100644
index 0000000..ced7820
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/AbstractDeviceObserver.java	
@@ -0,0 +1,26 @@
+package org.lsmr.selfcheckout.devices.observers;
+
+import org.lsmr.selfcheckout.devices.AbstractDevice;
+
+/**
+ * This class represents the abstract interface for all device observers. All
+ * subclasses should add their own event notification methods, the first
+ * parameter of which should always be the device affected.
+ */
+public interface AbstractDeviceObserver {
+	/**
+	 * Announces that the indicated device has been enabled.
+	 * 
+	 * @param device
+	 *                 The device that has been enabled.
+	 */
+	public void enabled(AbstractDevice<? extends AbstractDeviceObserver> device);
+
+	/**
+	 * Announces that the indicated device has been disabled.
+	 * 
+	 * @param device
+	 *                 The device that has been enabled.
+	 */
+	public void disabled(AbstractDevice<? extends AbstractDeviceObserver> device);
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/BanknoteDispenserObserver.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/BanknoteDispenserObserver.java
new file mode 100644
index 0000000..d4363bf
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/BanknoteDispenserObserver.java	
@@ -0,0 +1,71 @@
+package org.lsmr.selfcheckout.devices.observers;
+
+import org.lsmr.selfcheckout.Banknote;
+import org.lsmr.selfcheckout.devices.BanknoteDispenser;
+
+/**
+ * Observes events emanating from a banknote dispenser.
+ */
+public interface BanknoteDispenserObserver extends AbstractDeviceObserver {
+	/**
+	 * Announces that the indicated banknote dispenser is full of banknotes.
+	 * 
+	 * @param dispenser
+	 *            The dispenser where the event occurred.
+	 */
+	void moneyFull(BanknoteDispenser dispenser);
+
+	/**
+	 * Announces that the indicated banknote dispenser is empty of banknotes.
+	 * 
+	 * @param dispenser
+	 *            The dispenser where the event occurred.
+	 */
+	void banknotesEmpty(BanknoteDispenser dispenser);
+
+	/**
+	 * Announces that the indicated banknote has been added to the indicated
+	 * banknote dispenser.
+	 * 
+	 * @param dispenser
+	 *            The dispenser where the event occurred.
+	 * @param banknote
+	 *            The banknote that was added.
+	 */
+	void billAdded(BanknoteDispenser dispenser, Banknote banknote);
+
+	/**
+	 * Announces that the indicated banknote has been added to the indicated
+	 * banknote dispenser.
+	 * 
+	 * @param dispenser
+	 *            The dispenser where the event occurred.
+	 * @param banknote
+	 *            The banknote that was removed.
+	 */
+	void banknoteRemoved(BanknoteDispenser dispenser, Banknote banknote);
+
+	/**
+	 * Announces that the indicated sequence of banknotes has been added to the
+	 * indicated banknote dispenser. Used to simulate direct, physical loading of
+	 * the dispenser.
+	 * 
+	 * @param dispenser
+	 *            The dispenser where the event occurred.
+	 * @param banknotes
+	 *            The banknotes that were loaded.
+	 */
+	void banknotesLoaded(BanknoteDispenser dispenser, Banknote... banknotes);
+
+	/**
+	 * Announces that the indicated sequence of banknotes has been removed to the
+	 * indicated banknote dispenser. Used to simulate direct, physical unloading of
+	 * the dispenser.
+	 * 
+	 * @param dispenser
+	 *            The dispenser where the event occurred.
+	 * @param banknotes
+	 *            The banknotes that were unloaded.
+	 */
+	void banknotesUnloaded(BanknoteDispenser dispenser, Banknote... banknotes);
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/BanknoteSlotObserver.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/BanknoteSlotObserver.java
new file mode 100644
index 0000000..20ced82
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/BanknoteSlotObserver.java	
@@ -0,0 +1,34 @@
+package org.lsmr.selfcheckout.devices.observers;
+
+import org.lsmr.selfcheckout.Banknote;
+import org.lsmr.selfcheckout.devices.BanknoteSlot;
+
+/**
+ * Observes events emanating from a banknote slot.
+ */
+public interface BanknoteSlotObserver extends AbstractDeviceObserver {
+	/**
+	 * An event announcing that a banknote has been inserted.
+	 * 
+	 * @param slot
+	 *            The device on which the event occurred.
+	 */
+	void banknoteInserted(BanknoteSlot slot);
+
+	/**
+	 * An event announcing that a banknote has been returned to the user, dangling
+	 * from the slot.
+	 * 
+	 * @param slot
+	 *            The device on which the event occurred.
+	 */
+	void banknoteEjected(BanknoteSlot slot);
+
+	/**
+	 * An event announcing that a dangling banknote has been removed by the user.
+	 * 
+	 * @param slot
+	 *            The device on which the event occurred.
+	 */
+	void banknoteRemoved(BanknoteSlot slot);
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/BanknoteStorageUnitObserver.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/BanknoteStorageUnitObserver.java
new file mode 100644
index 0000000..9f17942
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/BanknoteStorageUnitObserver.java	
@@ -0,0 +1,43 @@
+package org.lsmr.selfcheckout.devices.observers;
+
+import org.lsmr.selfcheckout.Banknote;
+import org.lsmr.selfcheckout.devices.BanknoteStorageUnit;
+
+/**
+ * Observes events emanating from a banknote storage unit.
+ */
+public interface BanknoteStorageUnitObserver extends AbstractDeviceObserver {
+	/**
+	 * Announces that the indicated banknote storage unit is full of banknotes.
+	 * 
+	 * @param unit
+	 *            The storage unit where the event occurred.
+	 */
+	void banknotesFull(BanknoteStorageUnit unit);
+
+	/**
+	 * Announces that a banknote has been added to the indicated storage unit.
+	 * 
+	 * @param unit
+	 *            The storage unit where the event occurred.
+	 */
+	void banknoteAdded(BanknoteStorageUnit unit);
+
+	/**
+	 * Announces that the indicated storage unit has been loaded with banknotes.
+	 * Used to simulate direct, physical loading of the unit.
+	 * 
+	 * @param unit
+	 *            The storage unit where the event occurred.
+	 */
+	void banknotesLoaded(BanknoteStorageUnit unit);
+
+	/**
+	 * Announces that the storage unit has been emptied of banknotes. Used to
+	 * simulate direct, physical unloading of the unit.
+	 * 
+	 * @param unit
+	 *            The storage unit where the event occurred.
+	 */
+	void banknotesUnloaded(BanknoteStorageUnit unit);
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/BanknoteValidatorObserver.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/BanknoteValidatorObserver.java
new file mode 100644
index 0000000..583fa9d
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/BanknoteValidatorObserver.java	
@@ -0,0 +1,33 @@
+package org.lsmr.selfcheckout.devices.observers;
+
+import java.util.Currency;
+
+import org.lsmr.selfcheckout.Banknote;
+import org.lsmr.selfcheckout.devices.BanknoteValidator;
+
+/**
+ * Observes events emanating from a banknote validator.
+ */
+public interface BanknoteValidatorObserver extends AbstractDeviceObserver {
+	/**
+	 * An event announcing that the indicated banknote has been detected and
+	 * determined to be valid.
+	 * 
+	 * @param validator
+	 *            The device on which the event occurred.
+	 * @param currency
+	 *            The kind of currency of the inserted banknote.
+	 * @param value
+	 *            The value of the inserted banknote.
+	 */
+	void validBanknoteDetected(BanknoteValidator validator, Currency currency, int value);
+
+	/**
+	 * An event announcing that the indicated banknote has been detected and
+	 * determined to be invalid.
+	 * 
+	 * @param validator
+	 *            The device on which the event occurred.
+	 */
+	void invalidBanknoteDetected(BanknoteValidator validator);
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/BarcodeScannerObserver.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/BarcodeScannerObserver.java
new file mode 100644
index 0000000..5a73307
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/BarcodeScannerObserver.java	
@@ -0,0 +1,20 @@
+package org.lsmr.selfcheckout.devices.observers;
+
+import org.lsmr.selfcheckout.Barcode;
+import org.lsmr.selfcheckout.devices.BarcodeScanner;
+
+/**
+ * Observes events emanating from a barcode scanner.
+ */
+public interface BarcodeScannerObserver extends AbstractDeviceObserver {
+	/**
+	 * An event announcing that the indicated barcode has been successfully scanned.
+	 * 
+	 * @param barcodeScanner
+	 *            The device on which the event occurred.
+	 * @param barcode
+	 *            The barcode that was read by the scanner.
+	 */
+	void barcodeScanned(BarcodeScanner barcodeScanner, Barcode barcode);
+
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/CardReaderObserver.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/CardReaderObserver.java
new file mode 100644
index 0000000..9256e3a
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/CardReaderObserver.java	
@@ -0,0 +1,52 @@
+package org.lsmr.selfcheckout.devices.observers;
+
+import org.lsmr.selfcheckout.Card.CardData;
+import org.lsmr.selfcheckout.devices.CardReader;
+
+/**
+ * Observes events emanating from a coin dispenser.
+ */
+public interface CardReaderObserver extends AbstractDeviceObserver {
+	/**
+	 * Announces that a card has been inserted in the indicated card reader.
+	 * 
+	 * @param reader
+	 *            The reader where the event occurred.
+	 */
+	void cardInserted(CardReader reader);
+
+	/**
+	 * Announces that a card has been removed from the indicated card reader.
+	 * 
+	 * @param reader
+	 *            The reader where the event occurred.
+	 */
+	void cardRemoved(CardReader reader);
+
+	/**
+	 * Announces that a (tap-enabled) card has been tapped on the indicated card
+	 * reader.
+	 * 
+	 * @param reader
+	 *            The reader where the event occurred.
+	 */
+	void cardTapped(CardReader reader);
+
+	/**
+	 * Announces that a card has swiped on the indicated card reader.
+	 * 
+	 * @param reader
+	 *            The reader where the event occurred.
+	 */
+	void cardSwiped(CardReader reader);
+
+	/**
+	 * Announces that the data has been read from a card.
+	 * 
+	 * @param reader
+	 *            The reader where the event occurred.
+	 * @param data
+	 *            The data that was read. Note that this data may be corrupted.
+	 */
+	void cardDataRead(CardReader reader, CardData data);
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/CoinDispenserObserver.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/CoinDispenserObserver.java
new file mode 100644
index 0000000..d388e06
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/CoinDispenserObserver.java	
@@ -0,0 +1,67 @@
+package org.lsmr.selfcheckout.devices.observers;
+
+import org.lsmr.selfcheckout.Coin;
+import org.lsmr.selfcheckout.devices.CoinDispenser;
+
+/**
+ * Observes events emanating from a coin dispenser.
+ */
+public interface CoinDispenserObserver extends AbstractDeviceObserver {
+	/**
+	 * Announces that the indicated coin dispenser is full of coins.
+	 * 
+	 * @param dispenser
+	 *             The dispenser where the event occurred.
+	 */
+	void coinsFull(CoinDispenser dispenser);
+
+	/**
+	 * Announces that the indicated coin dispenser is empty of coins.
+	 * 
+	 * @param dispenser
+	 *             The dispenser where the event occurred.
+	 */
+	void coinsEmpty(CoinDispenser dispenser);
+
+	/**
+	 * Announces that the indicated coin has been added to the indicated coin dispenser.
+	 * 
+	 * @param dispenser
+	 *             The dispenser where the event occurred.
+	 * @param coin
+	 *             The coin that was added.
+	 */
+	void coinAdded(CoinDispenser dispenser, Coin coin);
+
+	/**
+	 * Announces that the indicated coin has been added to the indicated coin dispenser.
+	 * 
+	 * @param dispenser
+	 *             The dispenser where the event occurred.
+	 * @param coin
+	 *             The coin that was removed.
+	 */
+	void coinRemoved(CoinDispenser dispenser, Coin coin);
+
+	/**
+	 * Announces that the indicated sequence of coins has been added to the
+	 * indicated coin dispenser. Used to simulate direct, physical loading of the dispenser.
+	 * 
+	 * @param dispenser
+	 *              The dispenser where the event occurred.
+	 * @param coins
+	 *              The coins that were loaded.
+	 */
+	void coinsLoaded(CoinDispenser dispenser, Coin... coins);
+
+	/**
+	 * Announces that the indicated sequence of coins has been removed to the
+	 * indicated coin dispenser. Used to simulate direct, physical unloading of the dispenser.
+	 * 
+	 * @param dispenser
+	 *              The dispenser where the event occurred.
+	 * @param coins
+	 *              The coins that were unloaded.
+	 */
+	void coinsUnloaded(CoinDispenser dispenser, Coin... coins);
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/CoinSlotObserver.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/CoinSlotObserver.java
new file mode 100644
index 0000000..a091cb2
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/CoinSlotObserver.java	
@@ -0,0 +1,17 @@
+package org.lsmr.selfcheckout.devices.observers;
+
+import org.lsmr.selfcheckout.Coin;
+import org.lsmr.selfcheckout.devices.CoinSlot;
+
+/**
+ * Observes events emanating from a coin slot.
+ */
+public interface CoinSlotObserver extends AbstractDeviceObserver {
+	/**
+	 * An event announcing that a coin has been inserted.
+	 * 
+	 * @param slot
+	 *             The device on which the event occurred.
+	 */
+	void coinInserted(CoinSlot slot);
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/CoinStorageUnitObserver.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/CoinStorageUnitObserver.java
new file mode 100644
index 0000000..6049c36
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/CoinStorageUnitObserver.java	
@@ -0,0 +1,43 @@
+package org.lsmr.selfcheckout.devices.observers;
+
+import org.lsmr.selfcheckout.Coin;
+import org.lsmr.selfcheckout.devices.CoinStorageUnit;
+
+/**
+ * Observes events emanating from a coin storage unit.
+ */
+public interface CoinStorageUnitObserver extends AbstractDeviceObserver {
+	/**
+	 * Announces that the indicated coin storage unit is full of coins.
+	 * 
+	 * @param unit
+	 *            The storage unit where the event occurred.
+	 */
+	void coinsFull(CoinStorageUnit unit);
+
+	/**
+	 * Announces that a coin has been added to the indicated storage unit.
+	 * 
+	 * @param unit
+	 *            The storage unit where the event occurred.
+	 */
+	void coinAdded(CoinStorageUnit unit);
+
+	/**
+	 * Announces that the indicated storage unit has been loaded with coins.
+	 * Used to simulate direct, physical loading of the unit.
+	 * 
+	 * @param unit
+	 *            The storage unit where the event occurred.
+	 */
+	void coinsLoaded(CoinStorageUnit unit);
+
+	/**
+	 * Announces that the storage unit has been emptied of coins. Used to
+	 * simulate direct, physical unloading of the unit.
+	 * 
+	 * @param unit
+	 *            The storage unit where the event occurred.
+	 */
+	void coinsUnloaded(CoinStorageUnit unit);
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/CoinTrayObserver.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/CoinTrayObserver.java
new file mode 100644
index 0000000..f5be6ea
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/CoinTrayObserver.java	
@@ -0,0 +1,18 @@
+package org.lsmr.selfcheckout.devices.observers;
+
+import org.lsmr.selfcheckout.Coin;
+import org.lsmr.selfcheckout.devices.CoinTray;
+
+/**
+ * Observes events emanating from a coin tray. Coin trays are dumb devices so
+ * very few kinds of events can be announced by them.
+ */
+public interface CoinTrayObserver extends AbstractDeviceObserver {
+	/**
+	 * Announces that a coin has been added to the indicated tray.
+	 * 
+	 * @param tray
+	 *            The tray where the event occurred.
+	 */
+	void coinAdded(CoinTray tray);
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/CoinValidatorObserver.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/CoinValidatorObserver.java
new file mode 100644
index 0000000..f0660b0
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/CoinValidatorObserver.java	
@@ -0,0 +1,32 @@
+package org.lsmr.selfcheckout.devices.observers;
+
+import java.math.BigDecimal;
+
+import org.lsmr.selfcheckout.Banknote;
+import org.lsmr.selfcheckout.Coin;
+import org.lsmr.selfcheckout.devices.CoinValidator;
+
+/**
+ * Observes events emanating from a coin validator.
+ */
+public interface CoinValidatorObserver extends AbstractDeviceObserver {
+	/**
+	 * An event announcing that the indicated coin has been detected and determined
+	 * to be valid.
+	 * 
+	 * @param validator
+	 *            The device on which the event occurred.
+	 * @param value
+	 *            The value of the coin.
+	 */
+	void validCoinDetected(CoinValidator validator, BigDecimal value);
+
+	/**
+	 * An event announcing that a coin has been detected and determined to be
+	 * invalid.
+	 * 
+	 * @param validator
+	 *            The device on which the event occurred.
+	 */
+	void invalidCoinDetected(CoinValidator validator);
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/ElectronicScaleObserver.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/ElectronicScaleObserver.java
new file mode 100644
index 0000000..1d20b50
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/ElectronicScaleObserver.java	
@@ -0,0 +1,36 @@
+package org.lsmr.selfcheckout.devices.observers;
+
+import org.lsmr.selfcheckout.Coin;
+import org.lsmr.selfcheckout.devices.ElectronicScale;
+
+/**
+ * Observes events emanating from an electronic scale.
+ */
+public interface ElectronicScaleObserver extends AbstractDeviceObserver {
+	/**
+	 * Announces that the weight on the indicated scale has changed.
+	 * 
+	 * @param scale
+	 *            The scale where the event occurred.
+	 * @param weightInGrams
+	 *            The new weight.
+	 */
+	void weightChanged(ElectronicScale scale, double weightInGrams);
+
+	/**
+	 * Announces that excessive weight has been placed on the indicated scale.
+	 * 
+	 * @param scale
+	 *            The scale where the event occurred.
+	 */
+	void overload(ElectronicScale scale);
+
+	/**
+	 * Announces that the former excessive weight has been removed from the
+	 * indicated scale, and it is again able to measure weight.
+	 * 
+	 * @param scale
+	 *            The scale where the event occurred.
+	 */
+	void outOfOverload(ElectronicScale scale);
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/ReceiptPrinterObserver.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/ReceiptPrinterObserver.java
new file mode 100644
index 0000000..dc31b99
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/ReceiptPrinterObserver.java	
@@ -0,0 +1,40 @@
+package org.lsmr.selfcheckout.devices.observers;
+
+import org.lsmr.selfcheckout.devices.ReceiptPrinter;
+
+/**
+ * Observes events emanating from a receipt printer.
+ */
+public interface ReceiptPrinterObserver extends AbstractDeviceObserver {
+	/**
+	 * Announces that the indicated printer is out of paper.
+	 * 
+	 * @param printer
+	 *            The device from which the event emanated.
+	 */
+	void outOfPaper(ReceiptPrinter printer);
+
+	/**
+	 * Announces that the indicated printer is out of ink.
+	 * 
+	 * @param printer
+	 *            The device from which the event emanated.
+	 */
+	void outOfInk(ReceiptPrinter printer);
+
+	/**
+	 * Announces that paper has been added to the indicated printer.
+	 * 
+	 * @param printer
+	 *            The device from which the event emanated.
+	 */
+	void paperAdded(ReceiptPrinter printer);
+
+	/**
+	 * Announces that ink has been added to the indicated printer.
+	 * 
+	 * @param printer
+	 *            The device from which the event emanated.
+	 */
+	void inkAdded(ReceiptPrinter printer);
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/TouchScreenObserver.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/TouchScreenObserver.java
new file mode 100644
index 0000000..e6ea7ad
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/devices/observers/TouchScreenObserver.java	
@@ -0,0 +1,9 @@
+package org.lsmr.selfcheckout.devices.observers;
+
+import org.lsmr.selfcheckout.devices.AbstractDevice;
+
+/**
+ * Represents observers that respond only to enable/disable events on touch screens.
+ */
+public interface TouchScreenObserver extends AbstractDeviceObserver {
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/products/BarcodedProduct.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/products/BarcodedProduct.java
new file mode 100644
index 0000000..4559cba
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/products/BarcodedProduct.java	
@@ -0,0 +1,59 @@
+package org.lsmr.selfcheckout.products;
+
+import java.math.BigDecimal;
+
+import org.lsmr.selfcheckout.Barcode;
+import org.lsmr.selfcheckout.devices.SimulationException;
+
+/**
+ * Represents products with barcodes. Such products always have prices per-unit.
+ */
+public class BarcodedProduct extends Product {
+	private final Barcode barcode;
+	private final String description;
+
+	/**
+	 * Create a product.
+	 * 
+	 * @param barcode
+	 *            The barcode of the product.
+	 * @param description
+	 *            The description of the product.
+	 * @param price
+	 *            The price per-unit of the product.
+	 * @throws SimulationException
+	 *             If any argument is null.
+	 * @throws SimulationException
+	 *             If the price is &le;0.
+	 */
+	public BarcodedProduct(Barcode barcode, String description, BigDecimal price) {
+		super(price, true);
+
+		if(barcode == null)
+			throw new SimulationException(new NullPointerException("barcode is null"));
+
+		if(description == null)
+			throw new SimulationException(new NullPointerException("description is null"));
+
+		this.barcode = barcode;
+		this.description = description;
+	}
+
+	/**
+	 * Get the barcode.
+	 * 
+	 * @return The barcode. Cannot be null.
+	 */
+	public Barcode getBarcode() {
+		return barcode;
+	}
+
+	/**
+	 * Get the description.
+	 * 
+	 * @return The description. Cannot be null.
+	 */
+	public String getDescription() {
+		return description;
+	}
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/products/PLUCodedProduct.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/products/PLUCodedProduct.java
new file mode 100644
index 0000000..c3bab30
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/products/PLUCodedProduct.java	
@@ -0,0 +1,57 @@
+package org.lsmr.selfcheckout.products;
+
+import java.math.BigDecimal;
+
+import org.lsmr.selfcheckout.Barcode;
+import org.lsmr.selfcheckout.PriceLookupCode;
+import org.lsmr.selfcheckout.devices.SimulationException;
+
+/**
+ * Represents products with price-lookup (PLU) codes. Such products always have
+ * prices per-kilogram.
+ */
+public class PLUCodedProduct extends Product {
+	private final PriceLookupCode pluCode;
+	private final String description;
+
+	/**
+	 * Create a product.
+	 * 
+	 * @param pluCode
+	 *            The PLU code of the product.
+	 * @param description
+	 *            The description of the product.
+	 * @param price
+	 *            The price per-kilogram of the product.
+	 */
+	public PLUCodedProduct(PriceLookupCode pluCode, String description, BigDecimal price) {
+		super(price, false);
+
+		if(pluCode == null)
+			throw new SimulationException(new NullPointerException("barcode is null"));
+
+		if(description == null)
+			throw new SimulationException(new NullPointerException("description is null"));
+
+		this.pluCode = pluCode;
+		this.description = description;
+	}
+
+	/**
+	 * Get the PLU code.
+	 * 
+	 * @return The PLU code. Cannot be null.
+	 */
+	public PriceLookupCode getPLUCode() {
+		return pluCode;
+	}
+
+	/**
+	 * Get the description.
+	 * 
+	 * @return The description. Cannot be null.
+	 */
+	public String getDescription() {
+		return description;
+	}
+}
diff --git a/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/products/Product.java b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/products/Product.java
new file mode 100644
index 0000000..d47e70e
--- /dev/null
+++ b/SCS - Hardware - v1.0/src/org/lsmr/selfcheckout/products/Product.java	
@@ -0,0 +1,55 @@
+package org.lsmr.selfcheckout.products;
+
+import java.math.BigDecimal;
+
+import org.lsmr.selfcheckout.devices.SimulationException;
+
+/**
+ * Abstract base class for products. Note that a "product" is the <b>kind</> of
+ * item (e.g., 2 litre container of Dairyland brand 2% milk) and not an
+ * individual item, which would be the specific physical object (e.g.,
+ * <b>that</b> bottle of milk and not <b>this</b> one).
+ */
+public abstract class Product {
+	private final BigDecimal price;
+	private final boolean isPerUnit;
+
+	/**
+	 * Create a product instance.
+	 * 
+	 * @param price
+	 *            The price per unit or per kilogram.
+	 * @param isPerUnit
+	 *            True if the price is per unit; false if it is per kilogram.
+	 * @throws SimulationException
+	 *             If the price is null or &le;0.
+	 */
+	protected Product(BigDecimal price, boolean isPerUnit) {
+		if(price == null)
+			throw new SimulationException(new NullPointerException("price is null"));
+
+		if(price.compareTo(BigDecimal.ZERO) <= 0)
+			throw new SimulationException(new IllegalArgumentException("A product's price can only be positive."));
+
+		this.price = price;
+		this.isPerUnit = isPerUnit;
+	}
+
+	/**
+	 * Gets the price of the product.
+	 * 
+	 * @return The price. Cannot be null. Must be &gt;0.
+	 */
+	public BigDecimal getPrice() {
+		return price;
+	}
+
+	/**
+	 * Tests whether the price is per-unit, as opposed to per-kilogram.
+	 * 
+	 * @return true if the price is per-unit; otherwise, false.
+	 */
+	public boolean isPerUnit() {
+		return isPerUnit;
+	}
+}
diff --git a/bin/BanknoteController.class b/bin/BanknoteController.class
new file mode 100644
index 0000000..7ff8015
Binary files /dev/null and b/bin/BanknoteController.class differ
diff --git a/bin/org/lsmr/selfcheckout/Banknote.class b/bin/org/lsmr/selfcheckout/Banknote.class
new file mode 100644
index 0000000..0416eb6
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/Banknote.class differ
diff --git a/bin/org/lsmr/selfcheckout/Barcode.class b/bin/org/lsmr/selfcheckout/Barcode.class
new file mode 100644
index 0000000..464a475
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/Barcode.class differ
diff --git a/bin/org/lsmr/selfcheckout/BarcodedItem.class b/bin/org/lsmr/selfcheckout/BarcodedItem.class
new file mode 100644
index 0000000..de7368f
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/BarcodedItem.class differ
diff --git a/bin/org/lsmr/selfcheckout/BlockedCardException.class b/bin/org/lsmr/selfcheckout/BlockedCardException.class
new file mode 100644
index 0000000..0342831
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/BlockedCardException.class differ
diff --git a/bin/org/lsmr/selfcheckout/Card$CardData.class b/bin/org/lsmr/selfcheckout/Card$CardData.class
new file mode 100644
index 0000000..3a5a24b
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/Card$CardData.class differ
diff --git a/bin/org/lsmr/selfcheckout/Card$CardInsertData.class b/bin/org/lsmr/selfcheckout/Card$CardInsertData.class
new file mode 100644
index 0000000..b1844b6
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/Card$CardInsertData.class differ
diff --git a/bin/org/lsmr/selfcheckout/Card$CardSwipeData.class b/bin/org/lsmr/selfcheckout/Card$CardSwipeData.class
new file mode 100644
index 0000000..38d5704
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/Card$CardSwipeData.class differ
diff --git a/bin/org/lsmr/selfcheckout/Card$CardTapData.class b/bin/org/lsmr/selfcheckout/Card$CardTapData.class
new file mode 100644
index 0000000..c51bac1
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/Card$CardTapData.class differ
diff --git a/bin/org/lsmr/selfcheckout/Card.class b/bin/org/lsmr/selfcheckout/Card.class
new file mode 100644
index 0000000..7ca0563
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/Card.class differ
diff --git a/bin/org/lsmr/selfcheckout/ChipFailureException.class b/bin/org/lsmr/selfcheckout/ChipFailureException.class
new file mode 100644
index 0000000..f4aaf48
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/ChipFailureException.class differ
diff --git a/bin/org/lsmr/selfcheckout/Coin.class b/bin/org/lsmr/selfcheckout/Coin.class
new file mode 100644
index 0000000..55e3cde
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/Coin.class differ
diff --git a/bin/org/lsmr/selfcheckout/IllegalDigitException.class b/bin/org/lsmr/selfcheckout/IllegalDigitException.class
new file mode 100644
index 0000000..ecf0201
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/IllegalDigitException.class differ
diff --git a/bin/org/lsmr/selfcheckout/InvalidPINException.class b/bin/org/lsmr/selfcheckout/InvalidPINException.class
new file mode 100644
index 0000000..9a7fdaa
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/InvalidPINException.class differ
diff --git a/bin/org/lsmr/selfcheckout/Item.class b/bin/org/lsmr/selfcheckout/Item.class
new file mode 100644
index 0000000..a3468c5
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/Item.class differ
diff --git a/bin/org/lsmr/selfcheckout/MagneticStripeFailureException.class b/bin/org/lsmr/selfcheckout/MagneticStripeFailureException.class
new file mode 100644
index 0000000..f3ef20e
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/MagneticStripeFailureException.class differ
diff --git a/bin/org/lsmr/selfcheckout/Numeral.class b/bin/org/lsmr/selfcheckout/Numeral.class
new file mode 100644
index 0000000..fa00a27
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/Numeral.class differ
diff --git a/bin/org/lsmr/selfcheckout/PLUCodedItem.class b/bin/org/lsmr/selfcheckout/PLUCodedItem.class
new file mode 100644
index 0000000..eec7e69
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/PLUCodedItem.class differ
diff --git a/bin/org/lsmr/selfcheckout/PriceLookupCode.class b/bin/org/lsmr/selfcheckout/PriceLookupCode.class
new file mode 100644
index 0000000..22ee588
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/PriceLookupCode.class differ
diff --git a/bin/org/lsmr/selfcheckout/TapFailureException.class b/bin/org/lsmr/selfcheckout/TapFailureException.class
new file mode 100644
index 0000000..b22f856
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/TapFailureException.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/AbstractDevice$Phase.class b/bin/org/lsmr/selfcheckout/devices/AbstractDevice$Phase.class
new file mode 100644
index 0000000..f66cc1a
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/AbstractDevice$Phase.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/AbstractDevice.class b/bin/org/lsmr/selfcheckout/devices/AbstractDevice.class
new file mode 100644
index 0000000..7135fa4
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/AbstractDevice.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/Acceptor.class b/bin/org/lsmr/selfcheckout/devices/Acceptor.class
new file mode 100644
index 0000000..45c016e
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/Acceptor.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/BanknoteDispenser.class b/bin/org/lsmr/selfcheckout/devices/BanknoteDispenser.class
new file mode 100644
index 0000000..34485ac
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/BanknoteDispenser.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/BanknoteSlot.class b/bin/org/lsmr/selfcheckout/devices/BanknoteSlot.class
new file mode 100644
index 0000000..79a1500
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/BanknoteSlot.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/BanknoteStorageUnit.class b/bin/org/lsmr/selfcheckout/devices/BanknoteStorageUnit.class
new file mode 100644
index 0000000..9af0ff3
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/BanknoteStorageUnit.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/BanknoteValidator.class b/bin/org/lsmr/selfcheckout/devices/BanknoteValidator.class
new file mode 100644
index 0000000..c008572
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/BanknoteValidator.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/BarcodeScanner.class b/bin/org/lsmr/selfcheckout/devices/BarcodeScanner.class
new file mode 100644
index 0000000..1b0049f
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/BarcodeScanner.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/BidirectionalChannel.class b/bin/org/lsmr/selfcheckout/devices/BidirectionalChannel.class
new file mode 100644
index 0000000..adfe35a
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/BidirectionalChannel.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/CardReader.class b/bin/org/lsmr/selfcheckout/devices/CardReader.class
new file mode 100644
index 0000000..bc75481
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/CardReader.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/CoinDispenser.class b/bin/org/lsmr/selfcheckout/devices/CoinDispenser.class
new file mode 100644
index 0000000..e949320
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/CoinDispenser.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/CoinSlot.class b/bin/org/lsmr/selfcheckout/devices/CoinSlot.class
new file mode 100644
index 0000000..b06c85d
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/CoinSlot.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/CoinStorageUnit.class b/bin/org/lsmr/selfcheckout/devices/CoinStorageUnit.class
new file mode 100644
index 0000000..4fa1b4f
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/CoinStorageUnit.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/CoinTray.class b/bin/org/lsmr/selfcheckout/devices/CoinTray.class
new file mode 100644
index 0000000..91f3706
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/CoinTray.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/CoinValidator.class b/bin/org/lsmr/selfcheckout/devices/CoinValidator.class
new file mode 100644
index 0000000..f87b5f2
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/CoinValidator.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/DisabledException.class b/bin/org/lsmr/selfcheckout/devices/DisabledException.class
new file mode 100644
index 0000000..160c02e
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/DisabledException.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/ElectronicScale.class b/bin/org/lsmr/selfcheckout/devices/ElectronicScale.class
new file mode 100644
index 0000000..23e2f9c
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/ElectronicScale.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/Emitter.class b/bin/org/lsmr/selfcheckout/devices/Emitter.class
new file mode 100644
index 0000000..7a295ba
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/Emitter.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/EmptyException.class b/bin/org/lsmr/selfcheckout/devices/EmptyException.class
new file mode 100644
index 0000000..877ad17
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/EmptyException.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/FlowThroughEmitter.class b/bin/org/lsmr/selfcheckout/devices/FlowThroughEmitter.class
new file mode 100644
index 0000000..c8cb670
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/FlowThroughEmitter.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/FromStorageEmitter.class b/bin/org/lsmr/selfcheckout/devices/FromStorageEmitter.class
new file mode 100644
index 0000000..962fb88
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/FromStorageEmitter.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/OverloadException.class b/bin/org/lsmr/selfcheckout/devices/OverloadException.class
new file mode 100644
index 0000000..026d948
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/OverloadException.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/ReceiptPrinter.class b/bin/org/lsmr/selfcheckout/devices/ReceiptPrinter.class
new file mode 100644
index 0000000..a3cbbad
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/ReceiptPrinter.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/SelfCheckoutStation.class b/bin/org/lsmr/selfcheckout/devices/SelfCheckoutStation.class
new file mode 100644
index 0000000..d8362c2
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/SelfCheckoutStation.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/SimulationException.class b/bin/org/lsmr/selfcheckout/devices/SimulationException.class
new file mode 100644
index 0000000..4f0bdb9
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/SimulationException.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/UnidirectionalChannel.class b/bin/org/lsmr/selfcheckout/devices/UnidirectionalChannel.class
new file mode 100644
index 0000000..4dc61ad
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/UnidirectionalChannel.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/AbstractDeviceObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/AbstractDeviceObserver.class
new file mode 100644
index 0000000..185b861
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/observers/AbstractDeviceObserver.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/BanknoteDispenserObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/BanknoteDispenserObserver.class
new file mode 100644
index 0000000..dcb2f02
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/observers/BanknoteDispenserObserver.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/BanknoteSlotObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/BanknoteSlotObserver.class
new file mode 100644
index 0000000..a89eead
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/observers/BanknoteSlotObserver.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/BanknoteStorageUnitObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/BanknoteStorageUnitObserver.class
new file mode 100644
index 0000000..2671b9f
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/observers/BanknoteStorageUnitObserver.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/BanknoteValidatorObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/BanknoteValidatorObserver.class
new file mode 100644
index 0000000..2f6bb87
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/observers/BanknoteValidatorObserver.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/BarcodeScannerObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/BarcodeScannerObserver.class
new file mode 100644
index 0000000..7c4bb1e
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/observers/BarcodeScannerObserver.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/CardReaderObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/CardReaderObserver.class
new file mode 100644
index 0000000..1718764
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/observers/CardReaderObserver.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/CoinDispenserObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/CoinDispenserObserver.class
new file mode 100644
index 0000000..9283409
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/observers/CoinDispenserObserver.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/CoinSlotObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/CoinSlotObserver.class
new file mode 100644
index 0000000..3b00362
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/observers/CoinSlotObserver.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/CoinStorageUnitObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/CoinStorageUnitObserver.class
new file mode 100644
index 0000000..da91d12
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/observers/CoinStorageUnitObserver.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/CoinTrayObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/CoinTrayObserver.class
new file mode 100644
index 0000000..bf26991
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/observers/CoinTrayObserver.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/CoinValidatorObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/CoinValidatorObserver.class
new file mode 100644
index 0000000..817e5dc
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/observers/CoinValidatorObserver.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/ElectronicScaleObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/ElectronicScaleObserver.class
new file mode 100644
index 0000000..cfcc4eb
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/observers/ElectronicScaleObserver.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/ReceiptPrinterObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/ReceiptPrinterObserver.class
new file mode 100644
index 0000000..f4d748e
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/observers/ReceiptPrinterObserver.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/TouchScreenObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/TouchScreenObserver.class
new file mode 100644
index 0000000..9e96845
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/observers/TouchScreenObserver.class differ
diff --git a/bin/org/lsmr/selfcheckout/products/BarcodedProduct.class b/bin/org/lsmr/selfcheckout/products/BarcodedProduct.class
new file mode 100644
index 0000000..5d971c7
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/products/BarcodedProduct.class differ
diff --git a/bin/org/lsmr/selfcheckout/products/PLUCodedProduct.class b/bin/org/lsmr/selfcheckout/products/PLUCodedProduct.class
new file mode 100644
index 0000000..2c232ee
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/products/PLUCodedProduct.class differ
diff --git a/bin/org/lsmr/selfcheckout/products/Product.class b/bin/org/lsmr/selfcheckout/products/Product.class
new file mode 100644
index 0000000..e0f34c2
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/products/Product.class differ
diff --git a/src/BanknoteController.java b/src/BanknoteController.java
new file mode 100644
index 0000000..7c00f37
--- /dev/null
+++ b/src/BanknoteController.java
@@ -0,0 +1,68 @@
+import java.math.BigDecimal;
+import java.util.Currency;
+
+import org.lsmr.selfcheckout.devices.AbstractDevice;
+import org.lsmr.selfcheckout.devices.BanknoteStorageUnit;
+import org.lsmr.selfcheckout.devices.BanknoteValidator;
+import org.lsmr.selfcheckout.devices.SelfCheckoutStation;
+import org.lsmr.selfcheckout.devices.observers.AbstractDeviceObserver;
+import org.lsmr.selfcheckout.devices.observers.BanknoteStorageUnitObserver;
+import org.lsmr.selfcheckout.devices.observers.BanknoteValidatorObserver;
+
+public class BanknoteController implements BanknoteValidatorObserver, BanknoteStorageUnitObserver{
+
+	private int availableFunds;
+	private int validBanknotes = 0;
+	private boolean isFull = false;
+	
+	public BanknoteController(SelfCheckoutStation s) {
+		s.banknoteValidator.attach(this);
+		availableFunds = 0;
+	}
+
+	@Override
+	public void enabled(AbstractDevice<? extends AbstractDeviceObserver> device) {}
+
+	@Override
+	public void disabled(AbstractDevice<? extends AbstractDeviceObserver> device) {}
+
+	@Override
+	public void validBanknoteDetected(BanknoteValidator validator, Currency currency, int value) {
+		if(!isFull) {
+			availableFunds+=value;
+		}
+		
+	}
+
+	@Override
+	public void invalidBanknoteDetected(BanknoteValidator validator) {
+		
+	}
+
+	@Override
+	public void banknotesFull(BanknoteStorageUnit unit) {
+		isFull = true;
+		
+	}
+
+	@Override
+	public void banknoteAdded(BanknoteStorageUnit unit) {}
+
+	@Override
+	public void banknotesLoaded(BanknoteStorageUnit unit) {}
+
+	@Override
+	public void banknotesUnloaded(BanknoteStorageUnit unit) {
+		isFull = false;
+	}
+	
+	public boolean hasSufficientFunds(float price) {
+		return availableFunds>price;
+	}
+	
+	public int getCurrentFunds() {
+		return availableFunds;
+	}
+	
+	
+}

commit e3e7fd949e195de0a7997408a1003228486e27db
Merge: 9c0079d 3c3aaa8
Author: lexahoa <sparr@LAPTOP-V521ED67>
Date:   Fri Mar 18 04:28:14 2022 -0400

    files for wish-to-checkout

commit 9c0079d247dfa4cc047aa492b037b63e49adb235
Author: lexahoa <sparr@LAPTOP-V521ED67>
Date:   Fri Mar 18 04:20:48 2022 -0400

    files about

diff --git a/src/.classpath b/src/.classpath
new file mode 100644
index 0000000..483d8d0
--- /dev/null
+++ b/src/.classpath
@@ -0,0 +1,12 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<classpath>
+	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER">
+		<attributes>
+			<attribute name="module" value="true"/>
+		</attributes>
+	</classpathentry>
+	<classpathentry kind="con" path="org.eclipse.jdt.junit.JUNIT_CONTAINER/4"/>
+	<classpathentry kind="src" path=""/>
+	<classpathentry kind="src" path="/SCS - Hardware - v0.3"/>
+	<classpathentry kind="output" path=""/>
+</classpath>
diff --git a/src/.project b/src/.project
new file mode 100644
index 0000000..0f6f6a7
--- /dev/null
+++ b/src/.project
@@ -0,0 +1,17 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>src</name>
+	<comment></comment>
+	<projects>
+	</projects>
+	<buildSpec>
+		<buildCommand>
+			<name>org.eclipse.jdt.core.javabuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+	</buildSpec>
+	<natures>
+		<nature>org.eclipse.jdt.core.javanature</nature>
+	</natures>
+</projectDescription>
diff --git a/src/org/lsmr/selfcheckout/.gitignore b/src/org/lsmr/selfcheckout/.gitignore
new file mode 100644
index 0000000..8741d12
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/.gitignore
@@ -0,0 +1,12 @@
+/Banknote.class
+/Barcode.class
+/BarcodedItem.class
+/BlockedCardException.class
+/Card$CardData.class
+/Card$CardInsertData.class
+/Card$CardSwipeData.class
+/Card$CardTapData.class
+/Card.class
+/ChipFailureException.class
+/Coin.class
+/SCSLogic.class
diff --git a/src/org/lsmr/selfcheckout/SCS - Software/.gitignore b/src/org/lsmr/selfcheckout/SCS - Software/.gitignore
new file mode 100644
index 0000000..9eca640
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/SCS - Software/.gitignore	
@@ -0,0 +1 @@
+/SCSLogic.class
diff --git a/src/org/lsmr/selfcheckout/SCS - Software/SCSLogic b/src/org/lsmr/selfcheckout/SCS - Software/SCSLogic
deleted file mode 100644
index 8b13789..0000000
--- a/src/org/lsmr/selfcheckout/SCS - Software/SCSLogic	
+++ /dev/null
@@ -1 +0,0 @@
-
diff --git a/src/org/lsmr/selfcheckout/SCS - Software/SCSLogic.java b/src/org/lsmr/selfcheckout/SCS - Software/SCSLogic.java
new file mode 100644
index 0000000..768629c
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/SCS - Software/SCSLogic.java	
@@ -0,0 +1,4 @@
+public class SCSLogic {
+	
+	
+}
diff --git a/src/org/lsmr/selfcheckout/SCSLogic.java b/src/org/lsmr/selfcheckout/SCSLogic.java
new file mode 100644
index 0000000..9a74570
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/SCSLogic.java
@@ -0,0 +1,83 @@
+package org.lsmr.selfcheckout;
+
+import org.lsmr.selfcheckout.devices.AbstractDevice;
+import org.lsmr.selfcheckout.devices.Acceptor;
+import org.lsmr.selfcheckout.devices.DisabledException;
+import org.lsmr.selfcheckout.devices.ElectronicScale;
+import org.lsmr.selfcheckout.devices.OverloadException;
+import org.lsmr.selfcheckout.devices.SimulationException;
+import org.lsmr.selfcheckout.devices.observers.AbstractDeviceObserver;
+
+public class SCSLogic extends AbstractDevice<AbstractDeviceObserver> implements Acceptor<AbstractDeviceObserver>{
+	
+	private ElectronicScale electronic;
+	
+	
+	
+	
+	public SCSLogic(ElectronicScale e) {
+		this.electronic = e;
+	}
+	
+	
+	
+	
+	public void wish_checkout(AbstractDeviceObserver payment_method) throws OverloadException, DisabledException  {
+		
+		try {
+			this.attach(payment_method);
+			while(true) {
+				if (!electronic.isDisabled()) {  // keep checking the weight of bagging area, check if the weight has changed
+					
+					this.accept(payment_method);
+					
+					if (this.isDisabled()) {
+						break;
+					}
+					else { //this should never been run
+						throw new SimulationException("can't receive payment method");
+					}
+					
+				}
+				else {
+					throw new SimulationException("the weight has changed");
+				}
+				
+			}
+			//....might need to call the matched payment method
+			
+		} catch (OverloadException e) {
+			throw e;
+		}catch (DisabledException e) {
+		    throw e;
+		}
+		
+		
+		
+		
+		
+	}
+
+
+
+
+
+
+
+
+
+
+	@Override
+	public void accept(AbstractDeviceObserver thing) throws OverloadException, DisabledException {
+			thing.enabled(this);
+	}
+
+
+
+	@Override
+	public boolean hasSpace() { //not used yet
+		// TODO Auto-generated method stub
+		return false;
+	}
+	
+}
diff --git a/src/org/lsmr/selfcheckout/devices/.gitignore b/src/org/lsmr/selfcheckout/devices/.gitignore
new file mode 100644
index 0000000..8271a9b
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/devices/.gitignore
@@ -0,0 +1,22 @@
+/AbstractDevice$Phase.class
+/AbstractDevice.class
+/Acceptor.class
+/BanknoteDispenser.class
+/BanknoteSlot.class
+/BanknoteStorageUnit.class
+/BanknoteValidator.class
+/BarcodeScanner.class
+/BidirectionalChannel.class
+/CardReader.class
+/CoinDispenser.class
+/CoinSlot.class
+/CoinStorageUnit.class
+/CoinTray.class
+/CoinValidator.class
+/DisabledException.class
+/ElectronicScale.class
+/Emitter.class
+/EmptyException.class
+/FlowThroughEmitter.class
+/FromStorageEmitter.class
+/SimulationException.class
diff --git a/src/org/lsmr/selfcheckout/devices/SimulationException.java b/src/org/lsmr/selfcheckout/devices/SimulationException.java
new file mode 100644
index 0000000..7001f20
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/devices/SimulationException.java
@@ -0,0 +1,32 @@
+package org.lsmr.selfcheckout.devices;
+
+/**
+ * An exception that can be raised when the behaviour within the simulator makes
+ * no sense, typically when it has not been configured correctly. This is
+ * different from an exception being raised because the preconditions of a
+ * component are violated, but that would make sense in the real world.
+ */
+@SuppressWarnings("serial")
+public class SimulationException extends RuntimeException {
+	private String nested;
+
+	/**
+	 * Constructor used to nest other exceptions.
+	 * 
+	 * @param nested
+	 *            An underlying exception that is to be wrapped.
+	 */
+	public SimulationException(Exception nested) {
+		this.nested = nested.toString();
+	}
+
+	/**
+	 * Basic constructor.
+	 * 
+	 * @param message
+	 *            An explanatory message of the problem.
+	 */
+	public SimulationException(String message) {
+		nested = message;
+	}
+}
diff --git a/src/org/lsmr/selfcheckout/devices/observers/.gitignore b/src/org/lsmr/selfcheckout/devices/observers/.gitignore
new file mode 100644
index 0000000..f538ad6
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/devices/observers/.gitignore
@@ -0,0 +1,10 @@
+/AbstractDeviceObserver.class
+/BanknoteDispenserObserver.class
+/BanknoteSlotObserver.class
+/BanknoteStorageUnitObserver.class
+/BanknoteValidatorObserver.class
+/BarcodeScannerObserver.class
+/CardReaderObserver.class
+/CoinDispenserObserver.class
+/CoinSlotObserver.class
+/CoinStorageUnitObserver.class
diff --git a/src/org/lsmr/selfcheckout/tests/.gitignore b/src/org/lsmr/selfcheckout/tests/.gitignore
new file mode 100644
index 0000000..7ba8755
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/tests/.gitignore
@@ -0,0 +1,5 @@
+/test_wish_to_checkout.class
+/AbstractDeviceObserverStub.class
+/ElectronicScaleObserverStub.class
+/test_wish_to_checkout$1.class
+/test_wish_to_checkout$2.class
diff --git a/src/org/lsmr/selfcheckout/tests/AbstractDeviceObserverStub.java b/src/org/lsmr/selfcheckout/tests/AbstractDeviceObserverStub.java
new file mode 100644
index 0000000..d888524
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/tests/AbstractDeviceObserverStub.java
@@ -0,0 +1,19 @@
+package org.lsmr.selfcheckout.tests;
+
+import org.lsmr.selfcheckout.devices.AbstractDevice;
+import org.lsmr.selfcheckout.devices.observers.AbstractDeviceObserver;
+
+public class AbstractDeviceObserverStub implements AbstractDeviceObserver {
+
+	@Override
+	public void enabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
+		device.disable();	
+	}
+
+	@Override
+	public void disabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
+		// TODO Auto-generated method stub
+		
+	}
+
+}
diff --git a/src/org/lsmr/selfcheckout/tests/ElectronicScaleObserverStub.java b/src/org/lsmr/selfcheckout/tests/ElectronicScaleObserverStub.java
new file mode 100644
index 0000000..a548bbd
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/tests/ElectronicScaleObserverStub.java
@@ -0,0 +1,40 @@
+package org.lsmr.selfcheckout.tests;
+
+import org.lsmr.selfcheckout.devices.AbstractDevice;
+import org.lsmr.selfcheckout.devices.ElectronicScale;
+import org.lsmr.selfcheckout.devices.observers.AbstractDeviceObserver;
+import org.lsmr.selfcheckout.devices.observers.ElectronicScaleObserver;
+
+public class ElectronicScaleObserverStub implements ElectronicScaleObserver {
+
+	@Override
+	public void enabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
+		// TODO Auto-generated method stub
+		
+	}
+
+	@Override
+	public void disabled(AbstractDevice<? extends AbstractDeviceObserver> device) {
+		// TODO Auto-generated method stub
+		
+	}
+
+	@Override
+	public void weightChanged(ElectronicScale scale, double weightInGrams) {
+		scale.disable();
+		
+	}
+
+	@Override
+	public void overload(ElectronicScale scale) {
+		// TODO Auto-generated method stub
+		
+	}
+
+	@Override
+	public void outOfOverload(ElectronicScale scale) {
+		// TODO Auto-generated method stub
+		
+	}
+
+}
diff --git a/src/org/lsmr/selfcheckout/tests/test_wish_to_checkout.java b/src/org/lsmr/selfcheckout/tests/test_wish_to_checkout.java
new file mode 100644
index 0000000..43cef01
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/tests/test_wish_to_checkout.java
@@ -0,0 +1,69 @@
+package org.lsmr.selfcheckout.tests;
+
+import static org.junit.Assert.*;
+
+import org.junit.Before;
+import org.junit.Test;
+import org.lsmr.selfcheckout.Item;
+import org.lsmr.selfcheckout.SCSLogic;
+import org.lsmr.selfcheckout.devices.AbstractDevice;
+import org.lsmr.selfcheckout.devices.DisabledException;
+import org.lsmr.selfcheckout.devices.ElectronicScale;
+import org.lsmr.selfcheckout.devices.OverloadException;
+import org.lsmr.selfcheckout.devices.SimulationException;
+import org.lsmr.selfcheckout.devices.observers.AbstractDeviceObserver;
+
+import junit.extensions.TestSetup;
+import junit.framework.Assert;
+
+public class test_wish_to_checkout {
+
+	private SCSLogic test_object;
+	private AbstractDeviceObserverStub payment;
+	private ElectronicScaleObserverStub w_observer;
+	private ElectronicScale E;
+	
+	@Before
+	public void TestSetup() {
+		this.E = new ElectronicScale(100, 1);
+		this.test_object = new SCSLogic(E);
+		this.payment = new AbstractDeviceObserverStub();
+		this.w_observer = new ElectronicScaleObserverStub();
+		
+	}
+	
+	@Test(expected = SimulationException.class)
+	public void test_attachment() throws OverloadException, DisabledException {
+		test_object.wish_checkout(payment);
+		test_object.detach(payment);
+		test_object.detach(payment);
+	}
+	
+	@Test(expected = SimulationException.class)
+	public void test_weight_changed() throws OverloadException, DisabledException {
+		E.attach(w_observer);
+		Item test_item1 = new Item(20) {};
+		Item test_item2 = new Item(40) {};
+		E.add(test_item1);
+		E.enable();
+		
+		E.add(test_item2);
+		
+		test_object.wish_checkout(payment);
+		
+	}
+	
+	@Test
+	public void test_normal_wish() throws OverloadException, DisabledException {
+		test_object.endConfigurationPhase();
+		E.attach(w_observer);
+		E.endConfigurationPhase();
+		E.enable();
+		test_object.wish_checkout(payment);
+		assertTrue("this should be true",test_object.isDisabled());
+		
+		
+	}
+	
+
+}

commit 3c3aaa8bc6c0308bf394a6483931b4eea057c91a
Author: lexahoa <60637851+lexahoa@users.noreply.github.com>
Date:   Thu Mar 17 22:15:24 2022 -0400

    Update README.txt

diff --git a/README.txt b/README.txt
index 004b3af..3c74dda 100644
--- a/README.txt
+++ b/README.txt
@@ -8,8 +8,8 @@ Requirements:
   -Get current weight for electronic scale
   -Expect new weight on the electronic scale to be the addition of the weight of newly scanned item
 3.Customer wishes to checkout (zhongmin)
-  -disable the scanner and keep checking the weight
-  -check how the customer willing to pay
+  -keep looping and checking the weight
+  -check how the customer willing to pay (e.g. button pressed)
 4.Customer pays with a coin (Justin)
   -Coin slot observer to check if slot is open
   -Observe what coin inserted

commit 1ebe196327d834f5c7ae1d1a710f3ae9dacc9937
Author: lexahoa <60637851+lexahoa@users.noreply.github.com>
Date:   Tue Mar 15 20:39:07 2022 -0400

    Update README.txt

diff --git a/README.txt b/README.txt
index 4e5c077..004b3af 100644
--- a/README.txt
+++ b/README.txt
@@ -9,7 +9,7 @@ Requirements:
   -Expect new weight on the electronic scale to be the addition of the weight of newly scanned item
 3.Customer wishes to checkout (zhongmin)
   -disable the scanner and keep checking the weight
-  -ask how the customer willing to pay
+  -check how the customer willing to pay
 4.Customer pays with a coin (Justin)
   -Coin slot observer to check if slot is open
   -Observe what coin inserted

commit 59a471d7c175e861dd33f064449dee0dac714fb5
Author: lexahoa <60637851+lexahoa@users.noreply.github.com>
Date:   Tue Mar 15 20:35:31 2022 -0400

    Update README.txt

diff --git a/README.txt b/README.txt
index db7f608..4e5c077 100644
--- a/README.txt
+++ b/README.txt
@@ -8,6 +8,8 @@ Requirements:
   -Get current weight for electronic scale
   -Expect new weight on the electronic scale to be the addition of the weight of newly scanned item
 3.Customer wishes to checkout (zhongmin)
+  -disable the scanner and keep checking the weight
+  -ask how the customer willing to pay
 4.Customer pays with a coin (Justin)
   -Coin slot observer to check if slot is open
   -Observe what coin inserted

commit f51db735685803dcca8139076024f9dbf0cd3154
Author: lexahoa <60637851+lexahoa@users.noreply.github.com>
Date:   Tue Mar 15 20:26:10 2022 -0400

    Update README.txt

diff --git a/README.txt b/README.txt
index e69a5bf..db7f608 100644
--- a/README.txt
+++ b/README.txt
@@ -7,7 +7,7 @@ Requirements:
   -Checks for weight of item
   -Get current weight for electronic scale
   -Expect new weight on the electronic scale to be the addition of the weight of newly scanned item
-3.Customer wishes to checkout
+3.Customer wishes to checkout (zhongmin)
 4.Customer pays with a coin (Justin)
   -Coin slot observer to check if slot is open
   -Observe what coin inserted

commit ed6a54094e1bae9a9f2acf09ed6c84ddac03bcaa
Author: jameskhalil <87144837+jameskhalil@users.noreply.github.com>
Date:   Tue Mar 15 18:24:47 2022 -0600

    Update README.txt

diff --git a/README.txt b/README.txt
index b91afbd..e69a5bf 100644
--- a/README.txt
+++ b/README.txt
@@ -18,4 +18,9 @@ Requirements:
   -Observe what banknote inserted
   -Add ammount of money based on what banknote was inserted
   -Check if cost is reached everytime banknote is inserted
+
 TestCases:
+-Each person who works on the software control also works on the test cases.
+-Check your partner's test cases (2 and 4 check each other's test case, and 3 and 5 check each other's test cases)
+-If you think your partner is missing a test case for their task, you can message them to tell them what they should add (you can also add it yourself but that might get messy so it's best to check)
+-1 will be 2 people, who will both work on the test cases and version control.

commit 7b95ec146702796ca051867e1beb2bc411a9b3a2
Author: kev9268 <99704077+kev9268@users.noreply.github.com>
Date:   Tue Mar 15 18:24:29 2022 -0600

    Update README.txt

diff --git a/README.txt b/README.txt
index ecc94ea..b91afbd 100644
--- a/README.txt
+++ b/README.txt
@@ -3,7 +3,7 @@ Requirements:
   -Takes in barcode of item
   -Gathers items information (Price,weight,etc)
   -Adds cost of item to currect cost
-2.Customer places item in bagging area
+2.Customer places item in bagging area (Kevin)
   -Checks for weight of item
   -Get current weight for electronic scale
   -Expect new weight on the electronic scale to be the addition of the weight of newly scanned item

commit 6644feb6fdc41c621c497f51ba0896ee2e937cfb
Author: kev9268 <99704077+kev9268@users.noreply.github.com>
Date:   Tue Mar 15 18:23:40 2022 -0600

    Update README.txt

diff --git a/README.txt b/README.txt
index 49973e4..ecc94ea 100644
--- a/README.txt
+++ b/README.txt
@@ -14,5 +14,8 @@ Requirements:
   -Add ammount of money based on what coin was inserted
   -Check if cost is reached everytime coin is inserted
 5.Customer pays with a banknote - (Manbir)
-
+  -Banknote slot observer to check if slot is open
+  -Observe what banknote inserted
+  -Add ammount of money based on what banknote was inserted
+  -Check if cost is reached everytime banknote is inserted
 TestCases:

commit 3087c837c56530b42b123452c569b64133c1276b
Author: Manbir1 <60634350+Manbir1@users.noreply.github.com>
Date:   Tue Mar 15 18:22:44 2022 -0600

    Update README.txt

diff --git a/README.txt b/README.txt
index 078ae7c..49973e4 100644
--- a/README.txt
+++ b/README.txt
@@ -13,6 +13,6 @@ Requirements:
   -Observe what coin inserted
   -Add ammount of money based on what coin was inserted
   -Check if cost is reached everytime coin is inserted
-5.Customer pays with a banknote
+5.Customer pays with a banknote - (Manbir)
 
 TestCases:

commit a9f9b56bb22f88d462b5e2db4831cf749a47bf6f
Author: Justin Yu <60626089+justinjelly@users.noreply.github.com>
Date:   Tue Mar 15 18:21:38 2022 -0600

    Update README.txt
    
    Claimed use case #4

diff --git a/README.txt b/README.txt
index f4ba11d..078ae7c 100644
--- a/README.txt
+++ b/README.txt
@@ -8,7 +8,7 @@ Requirements:
   -Get current weight for electronic scale
   -Expect new weight on the electronic scale to be the addition of the weight of newly scanned item
 3.Customer wishes to checkout
-4.Customer pays with a coin
+4.Customer pays with a coin (Justin)
   -Coin slot observer to check if slot is open
   -Observe what coin inserted
   -Add ammount of money based on what coin was inserted

commit a54b3ca07583e825b4ea47deffca68776b690622
Author: kev9268 <99704077+kev9268@users.noreply.github.com>
Date:   Tue Mar 15 18:20:24 2022 -0600

    Update README.txt

diff --git a/README.txt b/README.txt
index 3e88df6..f4ba11d 100644
--- a/README.txt
+++ b/README.txt
@@ -12,6 +12,7 @@ Requirements:
   -Coin slot observer to check if slot is open
   -Observe what coin inserted
   -Add ammount of money based on what coin was inserted
+  -Check if cost is reached everytime coin is inserted
 5.Customer pays with a banknote
 
 TestCases:

commit b445b8031fa13604cc3b4ed66d44308dd7a9eeae
Author: kev9268 <99704077+kev9268@users.noreply.github.com>
Date:   Tue Mar 15 18:19:55 2022 -0600

    Update README.txt

diff --git a/README.txt b/README.txt
index 80672c5..3e88df6 100644
--- a/README.txt
+++ b/README.txt
@@ -10,7 +10,7 @@ Requirements:
 3.Customer wishes to checkout
 4.Customer pays with a coin
   -Coin slot observer to check if slot is open
-  -Coin
+  -Observe what coin inserted
   -Add ammount of money based on what coin was inserted
 5.Customer pays with a banknote
 

commit 7c1a0bf1f93c426c88e0f6d4f3134aa751f0d8ae
Author: jameskhalil <87144837+jameskhalil@users.noreply.github.com>
Date:   Tue Mar 15 18:13:43 2022 -0600

    Update README.txt

diff --git a/README.txt b/README.txt
index 487d962..80672c5 100644
--- a/README.txt
+++ b/README.txt
@@ -1,5 +1,5 @@
 Requirements:
-1.Customer scans an item
+1.Customer scans an item -(James, Bassel)
   -Takes in barcode of item
   -Gathers items information (Price,weight,etc)
   -Adds cost of item to currect cost

commit f9437a355f62db494d2379870af9b36c8aea532f
Author: kev9268 <99704077+kev9268@users.noreply.github.com>
Date:   Tue Mar 15 18:02:17 2022 -0600

    Update README.txt

diff --git a/README.txt b/README.txt
index 39d82bc..487d962 100644
--- a/README.txt
+++ b/README.txt
@@ -4,8 +4,14 @@ Requirements:
   -Gathers items information (Price,weight,etc)
   -Adds cost of item to currect cost
 2.Customer places item in bagging area
+  -Checks for weight of item
+  -Get current weight for electronic scale
+  -Expect new weight on the electronic scale to be the addition of the weight of newly scanned item
 3.Customer wishes to checkout
 4.Customer pays with a coin
+  -Coin slot observer to check if slot is open
+  -Coin
+  -Add ammount of money based on what coin was inserted
 5.Customer pays with a banknote
 
 TestCases:

commit e7bd878ac8637d574b335fce8e00ebed36517709
Author: kev9268 <99704077+kev9268@users.noreply.github.com>
Date:   Tue Mar 15 17:55:34 2022 -0600

    Update README.txt

diff --git a/README.txt b/README.txt
index c20c405..39d82bc 100644
--- a/README.txt
+++ b/README.txt
@@ -1 +1,11 @@
 Requirements:
+1.Customer scans an item
+  -Takes in barcode of item
+  -Gathers items information (Price,weight,etc)
+  -Adds cost of item to currect cost
+2.Customer places item in bagging area
+3.Customer wishes to checkout
+4.Customer pays with a coin
+5.Customer pays with a banknote
+
+TestCases:

commit e296373384095a663551cff06997a21b12f2f53f
Author: kev9268 <99704077+kev9268@users.noreply.github.com>
Date:   Tue Mar 15 17:49:11 2022 -0600

    Update README.txt

diff --git a/README.txt b/README.txt
index 4931a0a..c20c405 100644
--- a/README.txt
+++ b/README.txt
@@ -1 +1 @@
-test,test
\ No newline at end of file
+Requirements:

commit f20261d606e1fe0aed00ad087dea2f78ea4bd2de
Merge: ecd9f01 372c16a
Author: lexahoa <sparr@LAPTOP-V521ED67>
Date:   Sun Mar 13 14:53:41 2022 -0400

    Merge branch 'main' of https://github.com/kev9268/SENGProject

commit ecd9f016399244bdb820da5134397d31a545feaa
Author: lexahoa <sparr@LAPTOP-V521ED67>
Date:   Sun Mar 13 14:52:54 2022 -0400

    test upload

diff --git a/README.txt b/README.txt
index b740044..4931a0a 100644
--- a/README.txt
+++ b/README.txt
@@ -1 +1 @@
-wait....
\ No newline at end of file
+test,test
\ No newline at end of file

commit 372c16a7a9e656383b65120c4287b2c7daf31e80
Merge: 01067e4 a80a55e
Author: lexahoa <60637851+lexahoa@users.noreply.github.com>
Date:   Sun Mar 13 14:31:21 2022 -0400

    Merge pull request #1 from kev9268/master
    
    Master

commit a80a55e30e8aa1f14ddfbb8fd4b0a2fd800bdca7
Author: lexahoa <sparr@LAPTOP-V521ED67>
Date:   Sun Mar 13 14:04:26 2022 -0400

    empty readme.txt

diff --git a/README.txt b/README.txt
index e69de29..b740044 100644
--- a/README.txt
+++ b/README.txt
@@ -0,0 +1 @@
+wait....
\ No newline at end of file

commit 19816c6746365a6d0e60ecbea91e9597350651fe
Author: lexahoa <sparr@LAPTOP-V521ED67>
Date:   Sun Mar 13 13:47:18 2022 -0400

    Readme file

diff --git a/README.txt b/README.txt
new file mode 100644
index 0000000..e69de29

commit 01067e476877794b7c845092350a92509f2988a8
Author: kev9268 <99704077+kev9268@users.noreply.github.com>
Date:   Sun Mar 13 11:11:42 2022 -0600

    Rename logic to SCSLogic

diff --git a/src/org/lsmr/selfcheckout/SCS - Software/logic b/src/org/lsmr/selfcheckout/SCS - Software/SCSLogic
similarity index 100%
rename from src/org/lsmr/selfcheckout/SCS - Software/logic
rename to src/org/lsmr/selfcheckout/SCS - Software/SCSLogic

commit 586386bc6535f44c4d5d05df4b3b19ae9ebaaf01
Author: kev9268 <99704077+kev9268@users.noreply.github.com>
Date:   Sun Mar 13 11:03:01 2022 -0600

    Create test

diff --git a/src/org/lsmr/selfcheckout/SCS - Software/SCS - Software - Test/test b/src/org/lsmr/selfcheckout/SCS - Software/SCS - Software - Test/test
new file mode 100644
index 0000000..8b13789
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/SCS - Software/SCS - Software - Test/test	
@@ -0,0 +1 @@
+

commit 389555e36fc4d576b34d17ccc8fd91438b7bf3d4
Author: kev9268 <99704077+kev9268@users.noreply.github.com>
Date:   Sun Mar 13 11:02:16 2022 -0600

    Create logic

diff --git a/src/org/lsmr/selfcheckout/SCS - Software/logic b/src/org/lsmr/selfcheckout/SCS - Software/logic
new file mode 100644
index 0000000..8b13789
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/SCS - Software/logic	
@@ -0,0 +1 @@
+

commit bfd240a36bc76ccd203e520443a8575630f60821
Author: basselhasan <47043095+basselhasan@users.noreply.github.com>
Date:   Sun Mar 13 10:29:26 2022 -0600

    Rename org.eclipse.jdt.core.prefs to .settings/org.eclipse.jdt.core.prefs

diff --git a/org.eclipse.jdt.core.prefs b/.settings/org.eclipse.jdt.core.prefs
similarity index 100%
rename from org.eclipse.jdt.core.prefs
rename to .settings/org.eclipse.jdt.core.prefs

commit 2fb32d445f68d90013d3725985e0cae188ca009a
Author: kev9268 <99704077+kev9268@users.noreply.github.com>
Date:   Sun Mar 13 10:28:20 2022 -0600

    Add files via upload

diff --git a/org.eclipse.jdt.core.prefs b/org.eclipse.jdt.core.prefs
new file mode 100644
index 0000000..bb35fa0
--- /dev/null
+++ b/org.eclipse.jdt.core.prefs
@@ -0,0 +1,11 @@
+eclipse.preferences.version=1
+org.eclipse.jdt.core.compiler.codegen.inlineJsrBytecode=enabled
+org.eclipse.jdt.core.compiler.codegen.targetPlatform=1.8
+org.eclipse.jdt.core.compiler.codegen.unusedLocal=preserve
+org.eclipse.jdt.core.compiler.compliance=1.8
+org.eclipse.jdt.core.compiler.debug.lineNumber=generate
+org.eclipse.jdt.core.compiler.debug.localVariable=generate
+org.eclipse.jdt.core.compiler.debug.sourceFile=generate
+org.eclipse.jdt.core.compiler.problem.assertIdentifier=error
+org.eclipse.jdt.core.compiler.problem.enumIdentifier=error
+org.eclipse.jdt.core.compiler.source=1.8

commit a75fc26ed5198e18a9aa131c47433e4378605482
Author: kev9268 <99704077+kev9268@users.noreply.github.com>
Date:   Sun Mar 13 10:27:19 2022 -0600

    Add files via upload

diff --git a/.classpath b/.classpath
new file mode 100644
index 0000000..6a189c4
--- /dev/null
+++ b/.classpath
@@ -0,0 +1,7 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<classpath>
+	<classpathentry kind="src" path="src"/>
+	<classpathentry kind="con" path="org.eclipse.jdt.junit.JUNIT_CONTAINER/4"/>
+	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER"/>
+	<classpathentry kind="output" path="bin"/>
+</classpath>
diff --git a/.project b/.project
new file mode 100644
index 0000000..57573c6
--- /dev/null
+++ b/.project
@@ -0,0 +1,17 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>SCS - Hardware - v1.0</name>
+	<comment></comment>
+	<projects>
+	</projects>
+	<buildSpec>
+		<buildCommand>
+			<name>org.eclipse.jdt.core.javabuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+	</buildSpec>
+	<natures>
+		<nature>org.eclipse.jdt.core.javanature</nature>
+	</natures>
+</projectDescription>

commit f55651094c7631540f60d9ba72755b7b1a926425
Author: kev9268 <99704077+kev9268@users.noreply.github.com>
Date:   Sun Mar 13 10:26:17 2022 -0600

    Add files via upload

diff --git a/bin/org/lsmr/selfcheckout/Banknote.class b/bin/org/lsmr/selfcheckout/Banknote.class
new file mode 100644
index 0000000..fbc21cf
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/Banknote.class differ
diff --git a/bin/org/lsmr/selfcheckout/Barcode.class b/bin/org/lsmr/selfcheckout/Barcode.class
new file mode 100644
index 0000000..5cea197
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/Barcode.class differ
diff --git a/bin/org/lsmr/selfcheckout/BarcodedItem.class b/bin/org/lsmr/selfcheckout/BarcodedItem.class
new file mode 100644
index 0000000..2d68447
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/BarcodedItem.class differ
diff --git a/bin/org/lsmr/selfcheckout/BlockedCardException.class b/bin/org/lsmr/selfcheckout/BlockedCardException.class
new file mode 100644
index 0000000..536dd3d
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/BlockedCardException.class differ
diff --git a/bin/org/lsmr/selfcheckout/Card$CardData.class b/bin/org/lsmr/selfcheckout/Card$CardData.class
new file mode 100644
index 0000000..795e5b4
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/Card$CardData.class differ
diff --git a/bin/org/lsmr/selfcheckout/Card$CardInsertData.class b/bin/org/lsmr/selfcheckout/Card$CardInsertData.class
new file mode 100644
index 0000000..a2d7141
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/Card$CardInsertData.class differ
diff --git a/bin/org/lsmr/selfcheckout/Card$CardSwipeData.class b/bin/org/lsmr/selfcheckout/Card$CardSwipeData.class
new file mode 100644
index 0000000..a72d8a2
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/Card$CardSwipeData.class differ
diff --git a/bin/org/lsmr/selfcheckout/Card$CardTapData.class b/bin/org/lsmr/selfcheckout/Card$CardTapData.class
new file mode 100644
index 0000000..8efccff
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/Card$CardTapData.class differ
diff --git a/bin/org/lsmr/selfcheckout/Card.class b/bin/org/lsmr/selfcheckout/Card.class
new file mode 100644
index 0000000..262b944
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/Card.class differ
diff --git a/bin/org/lsmr/selfcheckout/ChipFailureException.class b/bin/org/lsmr/selfcheckout/ChipFailureException.class
new file mode 100644
index 0000000..fa389c2
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/ChipFailureException.class differ
diff --git a/bin/org/lsmr/selfcheckout/Coin.class b/bin/org/lsmr/selfcheckout/Coin.class
new file mode 100644
index 0000000..67690f1
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/Coin.class differ
diff --git a/bin/org/lsmr/selfcheckout/IllegalDigitException.class b/bin/org/lsmr/selfcheckout/IllegalDigitException.class
new file mode 100644
index 0000000..be8be69
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/IllegalDigitException.class differ
diff --git a/bin/org/lsmr/selfcheckout/InvalidPINException.class b/bin/org/lsmr/selfcheckout/InvalidPINException.class
new file mode 100644
index 0000000..c08cda6
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/InvalidPINException.class differ
diff --git a/bin/org/lsmr/selfcheckout/Item.class b/bin/org/lsmr/selfcheckout/Item.class
new file mode 100644
index 0000000..69e38c1
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/Item.class differ
diff --git a/bin/org/lsmr/selfcheckout/MagneticStripeFailureException.class b/bin/org/lsmr/selfcheckout/MagneticStripeFailureException.class
new file mode 100644
index 0000000..0f8b1e6
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/MagneticStripeFailureException.class differ
diff --git a/bin/org/lsmr/selfcheckout/Numeral.class b/bin/org/lsmr/selfcheckout/Numeral.class
new file mode 100644
index 0000000..ac8cc6e
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/Numeral.class differ
diff --git a/bin/org/lsmr/selfcheckout/PLUCodedItem.class b/bin/org/lsmr/selfcheckout/PLUCodedItem.class
new file mode 100644
index 0000000..941940c
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/PLUCodedItem.class differ
diff --git a/bin/org/lsmr/selfcheckout/PriceLookupCode.class b/bin/org/lsmr/selfcheckout/PriceLookupCode.class
new file mode 100644
index 0000000..0884227
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/PriceLookupCode.class differ
diff --git a/bin/org/lsmr/selfcheckout/TapFailureException.class b/bin/org/lsmr/selfcheckout/TapFailureException.class
new file mode 100644
index 0000000..8d9b145
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/TapFailureException.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/AbstractDevice$Phase.class b/bin/org/lsmr/selfcheckout/devices/AbstractDevice$Phase.class
new file mode 100644
index 0000000..1dae3ed
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/AbstractDevice$Phase.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/AbstractDevice.class b/bin/org/lsmr/selfcheckout/devices/AbstractDevice.class
new file mode 100644
index 0000000..aff6c5e
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/AbstractDevice.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/Acceptor.class b/bin/org/lsmr/selfcheckout/devices/Acceptor.class
new file mode 100644
index 0000000..9043506
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/Acceptor.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/BanknoteDispenser.class b/bin/org/lsmr/selfcheckout/devices/BanknoteDispenser.class
new file mode 100644
index 0000000..a829b5d
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/BanknoteDispenser.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/BanknoteSlot.class b/bin/org/lsmr/selfcheckout/devices/BanknoteSlot.class
new file mode 100644
index 0000000..f18b4a4
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/BanknoteSlot.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/BanknoteStorageUnit.class b/bin/org/lsmr/selfcheckout/devices/BanknoteStorageUnit.class
new file mode 100644
index 0000000..21d4eff
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/BanknoteStorageUnit.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/BanknoteValidator.class b/bin/org/lsmr/selfcheckout/devices/BanknoteValidator.class
new file mode 100644
index 0000000..a42c54f
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/BanknoteValidator.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/BarcodeScanner.class b/bin/org/lsmr/selfcheckout/devices/BarcodeScanner.class
new file mode 100644
index 0000000..093246f
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/BarcodeScanner.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/BidirectionalChannel.class b/bin/org/lsmr/selfcheckout/devices/BidirectionalChannel.class
new file mode 100644
index 0000000..8ae0603
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/BidirectionalChannel.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/CardReader.class b/bin/org/lsmr/selfcheckout/devices/CardReader.class
new file mode 100644
index 0000000..1a090b0
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/CardReader.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/CoinDispenser.class b/bin/org/lsmr/selfcheckout/devices/CoinDispenser.class
new file mode 100644
index 0000000..d069691
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/CoinDispenser.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/CoinSlot.class b/bin/org/lsmr/selfcheckout/devices/CoinSlot.class
new file mode 100644
index 0000000..db8f809
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/CoinSlot.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/CoinStorageUnit.class b/bin/org/lsmr/selfcheckout/devices/CoinStorageUnit.class
new file mode 100644
index 0000000..db1e2c4
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/CoinStorageUnit.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/CoinTray.class b/bin/org/lsmr/selfcheckout/devices/CoinTray.class
new file mode 100644
index 0000000..6f49c78
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/CoinTray.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/CoinValidator.class b/bin/org/lsmr/selfcheckout/devices/CoinValidator.class
new file mode 100644
index 0000000..de514e7
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/CoinValidator.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/DisabledException.class b/bin/org/lsmr/selfcheckout/devices/DisabledException.class
new file mode 100644
index 0000000..5c66261
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/DisabledException.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/ElectronicScale.class b/bin/org/lsmr/selfcheckout/devices/ElectronicScale.class
new file mode 100644
index 0000000..a9314d0
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/ElectronicScale.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/Emitter.class b/bin/org/lsmr/selfcheckout/devices/Emitter.class
new file mode 100644
index 0000000..b23e858
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/Emitter.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/EmptyException.class b/bin/org/lsmr/selfcheckout/devices/EmptyException.class
new file mode 100644
index 0000000..dc98a0f
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/EmptyException.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/FlowThroughEmitter.class b/bin/org/lsmr/selfcheckout/devices/FlowThroughEmitter.class
new file mode 100644
index 0000000..7db53cc
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/FlowThroughEmitter.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/FromStorageEmitter.class b/bin/org/lsmr/selfcheckout/devices/FromStorageEmitter.class
new file mode 100644
index 0000000..bc15cfc
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/FromStorageEmitter.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/OverloadException.class b/bin/org/lsmr/selfcheckout/devices/OverloadException.class
new file mode 100644
index 0000000..ce0e2cd
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/OverloadException.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/ReceiptPrinter.class b/bin/org/lsmr/selfcheckout/devices/ReceiptPrinter.class
new file mode 100644
index 0000000..4db506b
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/ReceiptPrinter.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/SelfCheckoutStation.class b/bin/org/lsmr/selfcheckout/devices/SelfCheckoutStation.class
new file mode 100644
index 0000000..4c8882f
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/SelfCheckoutStation.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/SimulationException.class b/bin/org/lsmr/selfcheckout/devices/SimulationException.class
new file mode 100644
index 0000000..d616ae5
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/SimulationException.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/UnidirectionalChannel.class b/bin/org/lsmr/selfcheckout/devices/UnidirectionalChannel.class
new file mode 100644
index 0000000..964485e
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/UnidirectionalChannel.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/AbstractDeviceObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/AbstractDeviceObserver.class
new file mode 100644
index 0000000..3b3f3af
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/observers/AbstractDeviceObserver.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/BanknoteDispenserObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/BanknoteDispenserObserver.class
new file mode 100644
index 0000000..ef277e1
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/observers/BanknoteDispenserObserver.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/BanknoteSlotObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/BanknoteSlotObserver.class
new file mode 100644
index 0000000..8fa6c54
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/observers/BanknoteSlotObserver.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/BanknoteStorageUnitObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/BanknoteStorageUnitObserver.class
new file mode 100644
index 0000000..dbec2ad
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/observers/BanknoteStorageUnitObserver.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/BanknoteValidatorObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/BanknoteValidatorObserver.class
new file mode 100644
index 0000000..b779d7e
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/observers/BanknoteValidatorObserver.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/BarcodeScannerObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/BarcodeScannerObserver.class
new file mode 100644
index 0000000..3ef8e5f
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/observers/BarcodeScannerObserver.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/CardReaderObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/CardReaderObserver.class
new file mode 100644
index 0000000..21606de
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/observers/CardReaderObserver.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/CoinDispenserObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/CoinDispenserObserver.class
new file mode 100644
index 0000000..7910341
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/observers/CoinDispenserObserver.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/CoinSlotObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/CoinSlotObserver.class
new file mode 100644
index 0000000..bd71242
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/observers/CoinSlotObserver.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/CoinStorageUnitObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/CoinStorageUnitObserver.class
new file mode 100644
index 0000000..b922285
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/observers/CoinStorageUnitObserver.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/CoinTrayObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/CoinTrayObserver.class
new file mode 100644
index 0000000..1391af5
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/observers/CoinTrayObserver.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/CoinValidatorObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/CoinValidatorObserver.class
new file mode 100644
index 0000000..b11003b
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/observers/CoinValidatorObserver.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/ElectronicScaleObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/ElectronicScaleObserver.class
new file mode 100644
index 0000000..6bf0d70
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/observers/ElectronicScaleObserver.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/ReceiptPrinterObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/ReceiptPrinterObserver.class
new file mode 100644
index 0000000..9cd53cf
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/observers/ReceiptPrinterObserver.class differ
diff --git a/bin/org/lsmr/selfcheckout/devices/observers/TouchScreenObserver.class b/bin/org/lsmr/selfcheckout/devices/observers/TouchScreenObserver.class
new file mode 100644
index 0000000..ef726bb
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/devices/observers/TouchScreenObserver.class differ
diff --git a/bin/org/lsmr/selfcheckout/products/BarcodedProduct.class b/bin/org/lsmr/selfcheckout/products/BarcodedProduct.class
new file mode 100644
index 0000000..aba29ee
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/products/BarcodedProduct.class differ
diff --git a/bin/org/lsmr/selfcheckout/products/PLUCodedProduct.class b/bin/org/lsmr/selfcheckout/products/PLUCodedProduct.class
new file mode 100644
index 0000000..80746e5
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/products/PLUCodedProduct.class differ
diff --git a/bin/org/lsmr/selfcheckout/products/Product.class b/bin/org/lsmr/selfcheckout/products/Product.class
new file mode 100644
index 0000000..b3888c1
Binary files /dev/null and b/bin/org/lsmr/selfcheckout/products/Product.class differ
diff --git a/src/org/lsmr/selfcheckout/Banknote.java b/src/org/lsmr/selfcheckout/Banknote.java
new file mode 100644
index 0000000..ad0981e
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/Banknote.java
@@ -0,0 +1,66 @@
+package org.lsmr.selfcheckout;
+
+import java.math.BigDecimal;
+import java.util.Currency;
+
+import org.lsmr.selfcheckout.devices.SimulationException;
+
+/**
+ * Instances of this class represent individual banknotes. The value of a
+ * banknote is assumed to always be a positive integer multiple of the base
+ * currency.
+ */
+public class Banknote {
+	private int value;
+	private Currency currency;
+
+	/**
+	 * Constructs a banknote.
+	 * @param currency
+	 *            The currency represented by this banknote.
+	 * @param value
+	 *            The value of the banknote, in multiples of the unit of currency.
+	 * 
+	 * @throws SimulationException
+	 *             If the value is &le;0.
+	 * @throws SimulationException
+	 *             If currency is null.
+	 */
+	public Banknote(Currency currency, int value) {
+		if(currency == null)
+			throw new SimulationException(new NullPointerException("currency is null"));
+
+		if(value <= 0)
+			throw new SimulationException(
+				new IllegalArgumentException("The value must be greater than 0: the argument passed was " + value));
+
+		this.value = value;
+		this.currency = currency;
+	}
+
+	/**
+	 * Accessor for the value.
+	 * 
+	 * @return The value of the banknote. Should always be &gt;0.
+	 */
+	public int getValue() {
+		return value;
+	}
+
+	/**
+	 * Accessor for the currency.
+	 * 
+	 * @return The currency for this banknote. Note that this is not the same as the
+	 *             "denomination" (e.g., a Canadian $10 bill is worth 10 Canadian
+	 *             dollars, so a Canadian $10 bill would have currency "Canadian
+	 *             dollars").
+	 */
+	public Currency getCurrency() {
+		return currency;
+	}
+
+	@Override
+	public String toString() {
+		return Integer.toString(value) + " " + currency;
+	}
+}
diff --git a/src/org/lsmr/selfcheckout/Barcode.java b/src/org/lsmr/selfcheckout/Barcode.java
new file mode 100644
index 0000000..b989b61
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/Barcode.java
@@ -0,0 +1,109 @@
+package org.lsmr.selfcheckout;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+
+import org.lsmr.selfcheckout.devices.SimulationException;
+
+/**
+ * Represents a barcode value (not the graphic barcode itself). Real-world
+ * barcodes are a sequence of digits, so that is what is modelled here.
+ */
+public class Barcode {
+	private Numeral[] digits;
+
+	/**
+	 * Constructs a barcode from an array of numerals.
+	 * 
+	 * @param code
+	 *            An array of numerals.
+	 * @throws SimulationException
+	 *             If any character in the input is not a digit between 0 and 9,
+	 *             inclusive.
+	 * @throws SimulationException
+	 *             If the code is null
+	 * @throws SimulationException
+	 *             If the code's length is &lt;1 or &gt;48.
+	 */
+	public Barcode(Numeral[] code) {
+		if(code == null)
+			throw new SimulationException(new NullPointerException("code is null"));
+
+		digits = new Numeral[code.length];
+
+		if(code.length < 1)
+			throw new SimulationException(
+				new IllegalArgumentException("A barcode cannot contain less than one digit."));
+
+		if(code.length > 48)
+			throw new SimulationException(
+				new IllegalArgumentException("A barcode cannot contain more than forty-eight digits."));
+
+		for(int i = 0; i < code.length; i++) {
+			if(code[i] == null)
+				throw new SimulationException(new NullPointerException("code[" + i + "] is null"));
+
+			digits[i] = code[i];
+		}
+	}
+
+	/**
+	 * Gets the count of digits in this code.
+	 * 
+	 * @return The count of digits.
+	 */
+	public int digitCount() {
+		return digits.length;
+	}
+
+	/**
+	 * Gets the digit at the indicated index within the code.
+	 * 
+	 * @param index
+	 *            The index of the digit, &ge;0 and &lt;count.
+	 * @return The digit at the indicated index.
+	 * @throws SimulationException
+	 *             If the index is outside the legal range.
+	 */
+	public Numeral getDigitAt(int index) {
+		try {
+			return digits[index];
+		}
+		catch(IndexOutOfBoundsException e) {
+			throw new SimulationException(e);
+		}
+	}
+
+	@Override
+	public String toString() {
+		char[] characters = new char[digits.length];
+
+		for(int i = 0; i < digits.length; i++)
+			characters[i] = Character.forDigit(digits[i].getValue(), 10);
+
+		return new String(characters);
+	}
+
+	@Override
+	public boolean equals(Object object) {
+		if(object instanceof Barcode) {
+			Barcode other = (Barcode)object;
+
+			if(other.digits.length != digits.length)
+				return false;
+
+			for(int i = 0; i < digits.length; i++)
+				if(!digits[i].equals(other.digits[i]))
+					return false;
+
+			return true;
+		}
+
+		return false;
+	}
+
+	@Override
+	public int hashCode() {
+		return Arrays.hashCode(digits);
+	}
+}
\ No newline at end of file
diff --git a/src/org/lsmr/selfcheckout/BarcodedItem.java b/src/org/lsmr/selfcheckout/BarcodedItem.java
new file mode 100644
index 0000000..cc57193
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/BarcodedItem.java
@@ -0,0 +1,41 @@
+package org.lsmr.selfcheckout;
+
+import org.lsmr.selfcheckout.devices.SimulationException;
+import org.lsmr.selfcheckout.products.Product;
+
+/**
+ * Represents items for sale, each with a particular barcode and weight.
+ */
+public class BarcodedItem extends Item {
+	private Barcode barcode;
+
+	/**
+	 * Basic constructor.
+	 * 
+	 * @param kind
+	 *            The kind of product that this item is.
+	 * @param weightInGrams
+	 *            The real weight of the item.
+	 * @throws SimulationException
+	 *             If the barcode is null.
+	 * @throws SimulationException
+	 *             If the weight is &le;0.
+	 */
+	public BarcodedItem(Barcode barcode, double weightInGrams) {
+		super(weightInGrams);
+
+		if(barcode == null)
+			throw new SimulationException(new NullPointerException("barcode is null"));
+
+		this.barcode = barcode;
+	}
+
+	/**
+	 * Gets the barcode of this item.
+	 * 
+	 * @return The barcode.
+	 */
+	public Barcode getBarcode() {
+		return barcode;
+	}
+}
diff --git a/src/org/lsmr/selfcheckout/BlockedCardException.java b/src/org/lsmr/selfcheckout/BlockedCardException.java
new file mode 100644
index 0000000..63b13ba
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/BlockedCardException.java
@@ -0,0 +1,15 @@
+package org.lsmr.selfcheckout;
+
+import java.io.IOException;
+
+/**
+ * Represents exceptions arising from a blocked card.
+ */
+public class BlockedCardException extends IOException {
+	private static final long serialVersionUID = 8824192400137175094L;
+
+	/**
+	 * Create an exception.
+	 */
+	public BlockedCardException() {}
+}
diff --git a/src/org/lsmr/selfcheckout/Card.java b/src/org/lsmr/selfcheckout/Card.java
new file mode 100644
index 0000000..e3f6fb9
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/Card.java
@@ -0,0 +1,289 @@
+package org.lsmr.selfcheckout;
+
+import java.io.IOException;
+import java.util.Random;
+import java.util.concurrent.ThreadLocalRandom;
+
+import org.lsmr.selfcheckout.devices.SimulationException;
+
+/**
+ * Represents plastic cards (e.g., credit cards, debit cards, membership cards).
+ */
+public final class Card {
+	private final String type;
+	private final String number;
+	private final String cardholder;
+	private final String cvv;
+	private final String pin;
+	public final boolean isTapEnabled;
+	public final boolean hasChip;
+	private int failedTrials = 0;
+	private boolean isBlocked;
+
+	/**
+	 * Create a card instance.
+	 * 
+	 * @param type
+	 *            The type of the card.
+	 * @param number
+	 *            The number of the card. This has to be a string of digits.
+	 * @param cardholder
+	 *            The name of the cardholder.
+	 * @param cvv
+	 *            The card verification value (CVV), a 3- or 4-digit value often on
+	 *            the back of the card. This can be null.
+	 * @param pin
+	 *            The personal identification number (PIN) for access to the card.
+	 *            This can be null if the card has no chip.
+	 * @param isTapEnabled
+	 *            Whether this card is capable of being tapped.
+	 * @param hasChip
+	 *            Whether this card has a chip.
+	 * @throws SimulationException
+	 *             If type, number, or cardholder is null.
+	 * @throws SimulationException
+	 *             If hasChip is true but pin is null.
+	 */
+	public Card(String type, String number, String cardholder, String cvv, String pin, boolean isTapEnabled,
+		boolean hasChip) {
+		if(type == null)
+			throw new SimulationException(new NullPointerException("type is null"));
+
+		if(number == null)
+			throw new SimulationException(new NullPointerException("number is null"));
+
+		if(cardholder == null)
+			throw new SimulationException(new NullPointerException("cardholder is null"));
+
+		if(hasChip && pin == null)
+			throw new SimulationException(new NullPointerException("has chip but pin is null"));
+
+		this.type = type;
+		this.number = number;
+		this.cardholder = cardholder;
+		this.cvv = cvv;
+		this.pin = pin;
+		this.isTapEnabled = isTapEnabled;
+		this.hasChip = hasChip;
+	}
+
+	private static final Random random = new Random(0);
+	private static final double PROBABILITY_OF_MAGNETIC_STRIPE_FAILURE = 0.01;
+	private static final double PROBABILITY_OF_TAP_FAILURE = 0.005;
+	private static final double PROBABILITY_OF_INSERT_FAILURE = 0.001;
+	private static final double PROBABILITY_OF_MAGNETIC_STRIPE_CORRUPTION = 0.001;
+	private static final double PROBABILITY_OF_CHIP_CORRUPTION = 0.00001;
+
+	/**
+	 * Simulates the action of swiping the card.
+	 * 
+	 * @return The card data.
+	 * @throws IOException
+	 *             If anything went wrong with the data transfer.
+	 */
+	public final CardSwipeData swipe() throws IOException {
+		if(isBlocked)
+			throw new BlockedCardException();
+
+		if(random.nextDouble() <= PROBABILITY_OF_MAGNETIC_STRIPE_FAILURE)
+			throw new MagneticStripeFailureException();
+
+		return new CardSwipeData();
+	}
+
+	/**
+	 * Simulates the action of tapping the card.
+	 * 
+	 * @return The card data.
+	 * @throws IOException
+	 *             If anything went wrong with the data transfer.
+	 */
+	public final CardTapData tap() throws IOException {
+		if(isBlocked)
+			throw new BlockedCardException();
+
+		if(isTapEnabled) {
+			if(random.nextDouble() <= PROBABILITY_OF_TAP_FAILURE)
+				throw new TapFailureException();
+
+			return new CardTapData();
+		}
+
+		return null;
+	}
+
+	/**
+	 * Simulates the action of inserting the card.
+	 * 
+	 * @return The card data.
+	 * @throws IOException
+	 *             If anything went wrong with the data transfer.
+	 */
+	public final CardInsertData insert(String pin) throws IOException {
+		if(isBlocked)
+			throw new BlockedCardException();
+
+		if(hasChip) {
+			if(random.nextDouble() <= PROBABILITY_OF_INSERT_FAILURE)
+				throw new ChipFailureException();
+
+			return new CardInsertData(pin);
+		}
+
+		return null;
+	}
+
+	private String randomize(String original, double probability) {
+		if(random.nextDouble() <= probability) {
+			int length = original.length();
+			int index = random.nextInt(length);
+			String first;
+
+			if(index == 0)
+				first = "";
+			else
+				first = original.substring(0, index);
+
+			char second = original.charAt(index);
+			second++;
+
+			String third;
+
+			if(index == length - 1)
+				third = "";
+			else
+				third = original.substring(index + 1, length);
+
+			return first + second + third;
+		}
+
+		return original;
+	}
+
+	/**
+	 * The abstract base type of card data.
+	 */
+	public interface CardData {
+		/**
+		 * Gets the type of the card.
+		 * 
+		 * @return The type of the card.
+		 */
+		public String getType();
+
+		/**
+		 * Gets the number of the card.
+		 * 
+		 * @return The number of the card.
+		 */
+		public String getNumber();
+
+		/**
+		 * Gets the cardholder's name.
+		 * 
+		 * @return The cardholder's name.
+		 */
+		public String getCardholder();
+
+		/**
+		 * Gets the card verification value (CVV) of the card.
+		 * 
+		 * @return The CVV of the card.
+		 * @throws UnsupportedOperationException
+		 *             If this operation is unsupported by this object.
+		 */
+		public String getCVV();
+	}
+
+	/**
+	 * The data from swiping a card.
+	 */
+	public class CardSwipeData implements CardData {
+		@Override
+		public String getType() {
+			return randomize(type, PROBABILITY_OF_MAGNETIC_STRIPE_CORRUPTION);
+		}
+
+		@Override
+		public String getNumber() {
+			return randomize(number, PROBABILITY_OF_MAGNETIC_STRIPE_CORRUPTION);
+		}
+
+		@Override
+		public String getCardholder() {
+			return randomize(cardholder, PROBABILITY_OF_MAGNETIC_STRIPE_CORRUPTION);
+		}
+
+		@Override
+		public String getCVV() {
+			throw new UnsupportedOperationException();
+		}
+	}
+
+	/**
+	 * The data from tapping a card.
+	 */
+	public final class CardTapData implements CardData {
+		@Override
+		public String getType() {
+			return randomize(type, PROBABILITY_OF_CHIP_CORRUPTION);
+		}
+
+		@Override
+		public String getNumber() {
+			return randomize(number, PROBABILITY_OF_CHIP_CORRUPTION);
+		}
+
+		@Override
+		public String getCardholder() {
+			return randomize(cardholder, PROBABILITY_OF_CHIP_CORRUPTION);
+		}
+
+		@Override
+		public String getCVV() {
+			return randomize(cvv, PROBABILITY_OF_CHIP_CORRUPTION);
+		}
+	}
+
+	/**
+	 * The data from inserting a card.
+	 */
+	public final class CardInsertData implements CardData {
+		CardInsertData(String pin) throws InvalidPINException {
+			if(!testPIN(pin))
+				throw new InvalidPINException();
+		}
+
+		@Override
+		public String getType() {
+			return randomize(type, PROBABILITY_OF_CHIP_CORRUPTION);
+		}
+
+		@Override
+		public String getNumber() {
+			return randomize(number, PROBABILITY_OF_CHIP_CORRUPTION);
+		}
+
+		@Override
+		public String getCardholder() {
+			return randomize(cardholder, PROBABILITY_OF_CHIP_CORRUPTION);
+		}
+
+		@Override
+		public String getCVV() {
+			return randomize(cvv, PROBABILITY_OF_CHIP_CORRUPTION);
+		}
+
+		private boolean testPIN(String pinToTest) {
+			if(pinToTest == pin) {
+				failedTrials = 0;
+				return true;
+			}
+
+			if(++failedTrials >= 3)
+				isBlocked = true;
+
+			return false;
+		}
+	}
+}
diff --git a/src/org/lsmr/selfcheckout/ChipFailureException.java b/src/org/lsmr/selfcheckout/ChipFailureException.java
new file mode 100644
index 0000000..971cf50
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/ChipFailureException.java
@@ -0,0 +1,15 @@
+package org.lsmr.selfcheckout;
+
+import java.io.IOException;
+
+/**
+ * Represents exceptions arising from failures of the chip.
+ */
+public class ChipFailureException extends IOException {
+	private static final long serialVersionUID = 3518203688837080092L;
+
+	/**
+	 * Create an exception.
+	 */
+	public ChipFailureException() {}
+}
diff --git a/src/org/lsmr/selfcheckout/Coin.java b/src/org/lsmr/selfcheckout/Coin.java
new file mode 100644
index 0000000..5681c26
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/Coin.java
@@ -0,0 +1,98 @@
+package org.lsmr.selfcheckout;
+
+import java.math.BigDecimal;
+import java.util.Currency;
+
+import org.lsmr.selfcheckout.devices.SimulationException;
+
+/**
+ * Instances of this class represent individual coins.
+ */
+public class Coin {
+	private BigDecimal value;
+	private Currency currency;
+
+	/**
+	 * Rather than specifying a currency for every coin, a default currency can be
+	 * specified which will be used when the currency is not specified.
+	 */
+	public static Currency DEFAULT_CURRENCY;
+
+	/**
+	 * Constructs a coin, using the default currency.
+	 * 
+	 * @param value
+	 *            The value of the coin, in multiples of the unit of currency.
+	 * @throws SimulationException
+	 *             If the value is &le;0.
+	 * @throws SimulationException
+	 *             If the argument is null.
+	 */
+	public Coin(BigDecimal value) {
+		if(value == null)
+			throw new SimulationException(new NullPointerException("value is null"));
+
+		if(DEFAULT_CURRENCY == null)
+			throw new SimulationException(new NullPointerException("Default currency is null"));
+
+		if(value.compareTo(BigDecimal.ZERO) <= 0)
+			throw new SimulationException(
+				new IllegalArgumentException("The value must be greater than 0: the argument passed was " + value));
+
+		this.value = value;
+		this.currency = DEFAULT_CURRENCY;
+	}
+		
+	/**
+	 * Constructs a coin.
+	 * 
+	 * @param currency
+	 *            The currency represented by this coin.
+	 * @param value
+	 *            The value of the coin, in multiples of the unit of currency.
+	 * @throws SimulationException
+	 *             If the value is &le;0.
+	 * @throws SimulationException
+	 *             If either argument is null.
+	 */
+	public Coin(Currency currency, BigDecimal value) {
+		if(value == null)
+			throw new SimulationException(new NullPointerException("value is null"));
+
+		if(currency == null)
+			throw new SimulationException(new NullPointerException("currency is null"));
+
+		if(value.compareTo(BigDecimal.ZERO) <= 0)
+			throw new SimulationException(
+				new IllegalArgumentException("The value must be greater than 0: the argument passed was " + value));
+
+		this.value = value;
+		this.currency = currency;
+	}
+
+	/**
+	 * Accessor for the value.
+	 * 
+	 * @return The value of the coin. Should always be greater than 0.
+	 */
+	public BigDecimal getValue() {
+		return value;
+	}
+
+	/**
+	 * Accessor for the currency.
+	 * 
+	 * @return The currency for this coin. Note that this is not the same as the
+	 *             "denomination" (e.g., a Canadian dime is worth 0.1 Canadian
+	 *             dollars, so a Canadian dime would have currency "Canadian
+	 *             dollars").
+	 */
+	public Currency getCurrency() {
+		return currency;
+	}
+
+	@Override
+	public String toString() {
+		return value.toString() + " " + currency;
+	}
+}
diff --git a/src/org/lsmr/selfcheckout/devices/AbstractDevice.java b/src/org/lsmr/selfcheckout/devices/AbstractDevice.java
new file mode 100644
index 0000000..89f4880
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/devices/AbstractDevice.java
@@ -0,0 +1,193 @@
+package org.lsmr.selfcheckout.devices;
+
+import java.util.ArrayList;
+
+import org.lsmr.selfcheckout.devices.observers.AbstractDeviceObserver;
+
+/**
+ * The abstract base class for all devices involved in the simulator.
+ * <p>
+ * This class utilizes the Observer design pattern. Subclasses inherit the
+ * attach method, but each must define its own notifyXXX methods.
+ * </p>
+ * <p>
+ * Each device must be coupled to an appropriate observer interface, which
+ * extends AbstractDeviceObserver; the type parameter T represents this
+ * observer.
+ * <p>
+ * <p>
+ * Any individual device can be disabled, which means it will not permit
+ * physical movements to be caused by the software. Any method that could cause
+ * a physical movement will declare that it throws DisabledException.
+ * </p>
+ * 
+ * @param <T>
+ *            The type of observers used for this device. For a device whose
+ *            class is X, its corresponding observer interface would typically
+ *            be XObserver.
+ */
+public abstract class AbstractDevice<T extends AbstractDeviceObserver> {
+	/**
+	 * Used to represent the operation phase of this device.
+	 */
+	protected enum Phase {
+		/**
+		 * The device is being configured.
+		 */
+		CONFIGURATION,
+		/**
+		 * The device is in normal operation.
+		 */
+		NORMAL,
+		/**
+		 * The device has undergone a fatal error requiring physical repair and reset.
+		 */
+		ERROR
+	}
+
+	/**
+	 * The current operation phase of this device.
+	 */
+	protected Phase phase = Phase.CONFIGURATION;
+
+	/**
+	 * Many devices require configuration before their use. Before configuration is
+	 * complete, the device should not operate. Once configuration is complete, any
+	 * further configuration attempts should cause exceptions.
+	 */
+	public void endConfigurationPhase() {
+		phase = Phase.NORMAL;
+	}
+
+	/**
+	 * For testing purposes only. Forces this device into an erroneous state.
+	 */
+	public void forceErrorPhase() {
+		phase = Phase.ERROR;
+	}
+
+	/**
+	 * A list of the registered observers on this device.
+	 */
+	protected ArrayList<T> observers = new ArrayList<>();
+
+	/**
+	 * Locates the indicated observer and removes it such that it will no longer be
+	 * informed of events from this device. If the observer is not currently
+	 * registered with this device, calls to this method will return false, but
+	 * otherwise have no effect.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 * 
+	 * @param observer
+	 *            The observer to remove.
+	 * @return true if the observer was found and removed, false otherwise.
+	 */
+	public final boolean detach(T observer) {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+
+		return observers.remove(observer);
+	}
+
+	/**
+	 * All observers registered with this device are removed. If there are none,
+	 * calls to this method have no effect.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 */
+	public final void detachAll() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+
+		observers.clear();
+	}
+
+	/**
+	 * Registers the indicated observer to receive event notifications from this
+	 * device.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 * 
+	 * @param observer
+	 *            The observer to be added.
+	 */
+	public final void attach(T observer) {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+
+		if(observer == null)
+			throw new SimulationException(new IllegalArgumentException(
+				"This method may not receive null, as it has no analogue in the real world."));
+
+		observers.add(observer);
+	}
+
+	private boolean disabled = false;
+
+	/**
+	 * Disables this device from receiving input and producing output.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 */
+	public final void disable() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		disabled = true;
+		notifyDisabled();
+	}
+
+	private void notifyDisabled() {
+		for(T observer : observers)
+			observer.disabled(this);
+	}
+
+	/**
+	 * Enables this device for receiving input and producing output.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 */
+	public final void enable() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		disabled = false;
+		notifyEnabled();
+	}
+
+	private void notifyEnabled() {
+		for(T observer : observers)
+			observer.enabled(this);
+	}
+
+	/**
+	 * Returns whether this device is currently disabled from receiving input and
+	 * producing output.
+	 * <p>
+	 * This operation is illegal during the configuration phase.
+	 * 
+	 * @return true if the device is disabled; false if the device is enabled.
+	 */
+	public final boolean isDisabled() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		return disabled;
+	}
+}
diff --git a/src/org/lsmr/selfcheckout/devices/Acceptor.java b/src/org/lsmr/selfcheckout/devices/Acceptor.java
new file mode 100644
index 0000000..4534b94
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/devices/Acceptor.java
@@ -0,0 +1,37 @@
+package org.lsmr.selfcheckout.devices;
+
+import org.lsmr.selfcheckout.Coin;
+
+/**
+ * A simple interface for devices that accept things.
+ * 
+ * @param <T>
+ *            The type of the things to accept.
+ */
+public interface Acceptor<T> {
+	/**
+	 * Instructs the device to take the thing as input.
+	 * <p>
+	 * This operation may not be called during the configuration phase.
+	 * 
+	 * @param thing
+	 *            The thing to be taken as input.
+	 * @throws OverloadException
+	 *             If the device does not have enough space for the thing.
+	 * @throws DisabledException
+	 *             If the device is disabled.
+	 */
+	public void accept(T thing) throws OverloadException, DisabledException;
+
+	/**
+	 * Checks whether the device has enough space to expect one more thing. If this
+	 * method returns true, an immediate call to accept should not throw
+	 * CapacityExceededException, unless an asynchronous addition has occurred in
+	 * the meantime.
+	 * <p>
+	 * This operation may not be called during the configuration phase.
+	 * 
+	 * @return true If there is space; otherwise, false.
+	 */
+	public boolean hasSpace();
+}
diff --git a/src/org/lsmr/selfcheckout/devices/BanknoteDispenser.java b/src/org/lsmr/selfcheckout/devices/BanknoteDispenser.java
new file mode 100644
index 0000000..de25f9c
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/devices/BanknoteDispenser.java
@@ -0,0 +1,213 @@
+package org.lsmr.selfcheckout.devices;
+
+import java.util.ArrayList;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Queue;
+
+import org.lsmr.selfcheckout.Banknote;
+import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
+import org.lsmr.selfcheckout.devices.observers.BanknoteDispenserObserver;
+
+/**
+ * Represents a device that stores banknotes (as known as bills, paper money,
+ * etc.) of a particular denomination to dispense them as change.
+ * <p>
+ * Banknote dispensers can receive banknotes from other sources. To simplify the
+ * simulation, no check is performed on the value of each banknote.
+ * </p>
+ */
+public final class BanknoteDispenser extends AbstractDevice<BanknoteDispenserObserver>
+	implements FromStorageEmitter<Banknote> {
+	private int maxCapacity;
+	private Queue<Banknote> queue = new LinkedList<Banknote>();
+	private UnidirectionalChannel<Banknote> sink;
+
+	/**
+	 * Creates a banknote dispenser with the indicated maximum capacity.
+	 * 
+	 * @param capacity
+	 *            The maximum number of banknotes that can be stored in the
+	 *            dispenser. Must be positive.
+	 * @throws SimulationException
+	 *             If capacity is not positive.
+	 */
+	public BanknoteDispenser(int capacity) {
+		if(capacity <= 0)
+			throw new SimulationException(new IllegalArgumentException("Capacity must be positive: " + capacity));
+
+		this.maxCapacity = capacity;
+	}
+
+	/**
+	 * Accesses the current number of banknotes in the dispenser.
+	 * <p>
+	 * This operation is illegal during the configuration phase.
+	 * 
+	 * @return The number of banknotes currently in the dispenser.
+	 */
+	public int size() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		return queue.size();
+	}
+
+	/**
+	 * Allows a set of banknotes to be loaded into the dispenser directly. Existing
+	 * banknotes in the dispenser are not removed.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 * 
+	 * @param banknotes
+	 *            A sequence of banknotes to be added. Each may not be null.
+	 * @throws OverloadException
+	 *             if the number of banknotes to be loaded exceeds the capacity of
+	 *             the dispenser.
+	 * @throws SimulationException
+	 *             If any banknote is null.
+	 */
+	public void load(Banknote... banknotes) throws SimulationException, OverloadException {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+
+		if(maxCapacity < queue.size() + banknotes.length)
+			throw new OverloadException("Capacity of dispenser is exceeded by load");
+
+		for(Banknote banknote : banknotes)
+			if(banknote == null)
+				throw new SimulationException(new NullPointerException("A banknote is null."));
+			else
+				queue.add(banknote);
+
+		notifyBanknotesLoaded(banknotes);
+	}
+
+	/**
+	 * Unloads banknotes from the dispenser directly. Causes a "banknotesUnloaded"
+	 * event to be announced.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 * 
+	 * @return A list of the banknotes unloaded. May be empty. Will never be null.
+	 */
+	public List<Banknote> unload() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+
+		List<Banknote> result = new ArrayList<>(queue);
+		queue.clear();
+
+		notifyBanknotesUnoaded(result.toArray(new Banknote[result.size()]));
+
+		return result;
+	}
+
+	/**
+	 * Connects an output channel to this banknote dispenser. Any existing output
+	 * channels are disconnected. Causes no events to be announced.
+	 * <p>
+	 * This operation is permissible only during the configuration phase.
+	 * 
+	 * @param sink
+	 *            The new output device to act as output. Can be null, which leaves
+	 *            the channel without an output.
+	 */
+	public void connect(UnidirectionalChannel<Banknote> sink) {
+		if(phase != Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may only be called during the configuration phase."));
+
+		this.sink = sink;
+	}
+
+	/**
+	 * Returns the maximum capacity of this banknote dispenser.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 * 
+	 * @return The capacity. Will be positive.
+	 */
+	public int getCapacity() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+
+		return maxCapacity;
+	}
+
+	/**
+	 * Emits a single banknote from this banknote dispenser. If successful, a
+	 * "banknoteRemoved" event is announced to its observers. If a successful
+	 * banknote removal causes the dispenser to become empty, a "banknotesEmpty"
+	 * event is instead announced to its observers.
+	 * <p>
+	 * This operation is illegal during the configuration phase.
+	 * 
+	 * @throws OverloadException
+	 *             if the output channel is unable to accept another banknote.
+	 * @throws EmptyException
+	 *             if no banknotes are present in the dispenser to release.
+	 * @throws DisabledException
+	 *             if the dispenser is currently disabled.
+	 */
+	public void emit() throws EmptyException, DisabledException, OverloadException {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		if(isDisabled())
+			throw new DisabledException();
+
+		if(queue.size() == 0)
+			throw new EmptyException();
+
+		Banknote banknote = queue.remove();
+
+		if(sink.hasSpace())
+			try {
+				sink.deliver(banknote);
+			}
+			catch(OverloadException e) {
+				// Should never happen
+				phase = Phase.ERROR;
+				throw new SimulationException(e);
+			}
+		else
+			throw new OverloadException("The sink is full.");
+
+		if(queue.isEmpty())
+			notifyBanknotesEmpty();
+		else
+			notifyBanknoteRemoved(banknote);
+	}
+
+	private void notifyBanknoteRemoved(Banknote banknote) {
+		for(BanknoteDispenserObserver observer : observers)
+			observer.banknoteRemoved(this, banknote);
+	}
+
+	private void notifyBanknotesEmpty() {
+		for(BanknoteDispenserObserver observer : observers)
+			observer.banknotesEmpty(this);
+	}
+
+	private void notifyBanknotesLoaded(Banknote[] banknotes) {
+		for(BanknoteDispenserObserver observer : observers)
+			observer.banknotesLoaded(this, banknotes);
+	}
+
+	private void notifyBanknotesUnoaded(Banknote[] banknotes) {
+		for(BanknoteDispenserObserver observer : observers)
+			observer.banknotesUnloaded(this, banknotes);
+	}
+}
diff --git a/src/org/lsmr/selfcheckout/devices/BanknoteSlot.java b/src/org/lsmr/selfcheckout/devices/BanknoteSlot.java
new file mode 100644
index 0000000..9037e26
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/devices/BanknoteSlot.java
@@ -0,0 +1,191 @@
+package org.lsmr.selfcheckout.devices;
+
+import org.lsmr.selfcheckout.Banknote;
+import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
+import org.lsmr.selfcheckout.devices.observers.BanknoteSlotObserver;
+
+/**
+ * Represents a simple banknote slot device that can either accept a banknote or
+ * eject the most recently inserted banknote, leaving it dangling until the
+ * customer removes it, via {@link #removeDanglingBanknote()}.
+ */
+public class BanknoteSlot extends AbstractDevice<BanknoteSlotObserver>
+	implements Acceptor<Banknote>, FlowThroughEmitter<Banknote> {
+	private BidirectionalChannel<Banknote> sink;
+	private boolean invert;
+
+	/**
+	 * Creates a banknote slot.
+	 * 
+	 * @param invert
+	 *            If the slot is to be inverted.
+	 */
+	public BanknoteSlot(boolean invert) {
+		this.invert = invert;
+	}
+
+	/**
+	 * Connects an output channel to the banknote slot. Causes no events.
+	 * <p>
+	 * This operation is permissible only during the configuration phase.
+	 * 
+	 * @param sink
+	 *            Where banknotes are passed into the machine.
+	 */
+	public void connect(BidirectionalChannel<Banknote> sink) {
+		if(phase != Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may only be called during the configuration phase."));
+
+		this.sink = sink;
+	}
+
+	/**
+	 * Tells the banknote slot that the indicated banknote is being inserted. If the
+	 * sink can accept the banknote, the banknote is passed to the sink and a
+	 * "banknoteInserted" event is announced to the slot's observers; otherwise, a
+	 * "banknoteEjected" event is announced to the slot's observers, meaning that
+	 * the banknote is returned to the user.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @param banknote
+	 *            The banknote to be added. Cannot be null.
+	 * @throws DisabledException
+	 *             if the banknote slot is currently disabled.
+	 * @throws SimulationException
+	 *             If the banknote is null.
+	 * @throws OverloadException
+	 *             If a banknote is dangling from the slot.
+	 */
+	public void accept(Banknote banknote) throws DisabledException, OverloadException {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		if(isDisabled())
+			throw new DisabledException();
+
+		if(danglingEjectedBanknote != null)
+			throw new OverloadException("A banknote is dangling from the slot. Remove that before adding another.");
+
+		notifyBanknoteInserted();
+
+		if(!invert && sink.hasSpace()) {
+			try {
+				sink.deliver(banknote);
+			}
+			catch(OverloadException e) {
+				// Should never happen
+				phase = Phase.ERROR;
+				throw new SimulationException(e);
+			}
+		}
+		else {
+			danglingEjectedBanknote = banknote;
+			notifyBanknoteEjected();
+		}
+	}
+
+	private Banknote danglingEjectedBanknote = null;
+
+	/**
+	 * Ejects the indicated banknote, leaving it dangling until the customer grabs
+	 * it.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @param banknote
+	 *            The banknote to be ejected.
+	 * @throws DisabledException
+	 *             If the device is disabled.
+	 * @throws SimulationException
+	 *             If the argument is null.
+	 * @throws SimulationException
+	 *             If a banknote is already dangling from the slot.
+	 */
+	public void emit(Banknote banknote) throws DisabledException, SimulationException {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		if(isDisabled())
+			throw new DisabledException();
+
+		if(banknote == null)
+			throw new SimulationException(new NullPointerException("banknote is null"));
+
+		if(danglingEjectedBanknote != null)
+			throw new SimulationException(
+				"A banknote is already dangling from the slot. Remove that before ejecting another.");
+
+		danglingEjectedBanknote = banknote;
+
+		notifyBanknoteEjected();
+	}
+
+	/**
+	 * Simulates the user removing a banknote that is dangling from the slot.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @return The formerly dangling banknote.
+	 */
+	public Banknote removeDanglingBanknote() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		if(danglingEjectedBanknote == null)
+			throw new SimulationException("A banknote that does not exist cannot be removed.");
+
+		Banknote b = danglingEjectedBanknote;
+		danglingEjectedBanknote = null;
+		notifyBanknoteRemoved();
+
+		return b;
+	}
+
+	/**
+	 * Tests whether a banknote can be accepted by or ejected from this slot.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @return True if the slot is not occupied by a dangling banknote; otherwise,
+	 *             false.
+	 */
+	public boolean hasSpace() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		return danglingEjectedBanknote == null;
+	}
+
+	private void notifyBanknoteInserted() {
+		for(BanknoteSlotObserver observer : observers)
+			observer.banknoteInserted(this);
+	}
+
+	private void notifyBanknoteEjected() {
+		for(BanknoteSlotObserver observer : observers)
+			observer.banknoteEjected(this);
+	}
+
+	private void notifyBanknoteRemoved() {
+		for(BanknoteSlotObserver observer : observers)
+			observer.banknoteRemoved(this);
+	}
+}
diff --git a/src/org/lsmr/selfcheckout/devices/BanknoteStorageUnit.java b/src/org/lsmr/selfcheckout/devices/BanknoteStorageUnit.java
new file mode 100644
index 0000000..34e6a81
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/devices/BanknoteStorageUnit.java
@@ -0,0 +1,199 @@
+package org.lsmr.selfcheckout.devices;
+
+import java.util.Arrays;
+import java.util.List;
+
+import org.lsmr.selfcheckout.Banknote;
+import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
+import org.lsmr.selfcheckout.devices.observers.BanknoteStorageUnitObserver;
+
+/**
+ * Represents devices that store banknotes. They only receive banknotes, not
+ * dispense them. To access the banknotes inside, a human operator needs to
+ * physically remove the banknotes, simulated with the {@link #unload()} method.
+ * A {@link #load(Banknote...)} method is provided for symmetry.
+ */
+public class BanknoteStorageUnit extends AbstractDevice<BanknoteStorageUnitObserver> implements Acceptor<Banknote> {
+	private Banknote[] storage;
+	private int nextIndex = 0;
+
+	/**
+	 * Creates a banknote storage unit that can hold the indicated number of
+	 * banknotes.
+	 * 
+	 * @param capacity
+	 *            The maximum number of banknotes that the unit can hold.
+	 * @throws SimulationException
+	 *             If the capacity is not positive.
+	 */
+	public BanknoteStorageUnit(int capacity) {
+		if(capacity <= 0)
+			throw new SimulationException(new IllegalArgumentException("The capacity must be positive."));
+
+		storage = new Banknote[capacity];
+	}
+
+	/**
+	 * Gets the maximum number of banknotes that this storage unit can hold.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 * 
+	 * @return The capacity.
+	 */
+	public int getCapacity() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+
+		return storage.length;
+	}
+
+	/**
+	 * Gets the current count of banknotes contained in this storage unit.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 * 
+	 * @return The current count.
+	 */
+	public int getBanknoteCount() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+
+		return nextIndex;
+	}
+
+	/**
+	 * Allows a set of banknotes to be loaded into the storage unit directly.
+	 * Existing banknotes in the dispenser are not removed. Causes a
+	 * "banknotesLoaded" event to be announced. Disabling has no effect on
+	 * loading/unloading.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 * 
+	 * @param banknotes
+	 *            A sequence of banknotes to be added. Each cannot be null.
+	 * @throws SimulationException
+	 *             if the number of banknotes to be loaded exceeds the capacity of
+	 *             the unit.
+	 * @throws SimulationException
+	 *             If the banknotes argument is null.
+	 * @throws SimulationException
+	 *             If any banknote is null.
+	 * @throws OverloadException
+	 *             If too many banknotes are stuffed in the unit.
+	 */
+	public void load(Banknote... banknotes) throws SimulationException, OverloadException {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+
+		if(banknotes == null)
+			throw new SimulationException(
+				new NullPointerException("banknotes is null which has no analogue in the real world"));
+
+		if(banknotes.length + nextIndex > storage.length)
+			throw new OverloadException("You tried to stuff too many banknotes in the storage unit.");
+
+		for(Banknote banknote : banknotes)
+			if(banknote == null)
+				throw new SimulationException(
+					new NullPointerException("No banknote may be null, which has no analogue in the real world."));
+
+		System.arraycopy(banknotes, 0, storage, nextIndex, banknotes.length);
+		nextIndex += banknotes.length;
+
+		notifyBanknotesLoaded();
+	}
+
+	/**
+	 * Unloads banknotes from the storage unit directly. Causes a
+	 * "banknotesUnloaded" event to be announced.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 * 
+	 * @return A list of the banknotes unloaded. May be empty. Will never be null.
+	 */
+	public List<Banknote> unload() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+
+		List<Banknote> banknotes = Arrays.asList(storage);
+
+		storage = new Banknote[storage.length];
+		nextIndex = 0;
+		notifyBanknotesUnloaded();
+
+		return banknotes;
+	}
+
+	/**
+	 * Causes the indicated banknote to be added to the storage unit. If successful,
+	 * a "banknoteAdded" event is announced to its observers. If a successful
+	 * banknote addition causes the unit to become full, a "banknotesFull" event is
+	 * instead announced to its observers.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @param banknote
+	 *            The banknote to add.
+	 * @throws DisabledException
+	 *             If the unit is currently disabled.
+	 * @throws SimulationException
+	 *             If banknote is null.
+	 * @throws OverloadException
+	 *             If the unit is already full.
+	 */
+	public void accept(Banknote banknote) throws DisabledException, OverloadException {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		if(isDisabled())
+			throw new DisabledException();
+
+		if(banknote == null)
+			throw new SimulationException(
+				new NullPointerException("banknote is null, which has no analogue in the real world."));
+
+		if(nextIndex < storage.length) {
+			storage[nextIndex++] = banknote;
+
+			if(nextIndex == storage.length)
+				notifyBanknotesFull();
+			else
+				notifyBanknoteAdded();
+		}
+		else
+			throw new OverloadException();
+	}
+
+	@Override
+	public boolean hasSpace() {
+		return nextIndex < storage.length;
+	}
+
+	private void notifyBanknotesLoaded() {
+		for(BanknoteStorageUnitObserver l : observers)
+			l.banknotesLoaded(this);
+	}
+
+	private void notifyBanknotesUnloaded() {
+		for(BanknoteStorageUnitObserver l : observers)
+			l.banknotesUnloaded(this);
+	}
+
+	private void notifyBanknotesFull() {
+		for(BanknoteStorageUnitObserver l : observers)
+			l.banknotesFull(this);
+	}
+
+	private void notifyBanknoteAdded() {
+		for(BanknoteStorageUnitObserver l : observers)
+			l.banknoteAdded(this);
+	}
+}
diff --git a/src/org/lsmr/selfcheckout/devices/BanknoteValidator.java b/src/org/lsmr/selfcheckout/devices/BanknoteValidator.java
new file mode 100644
index 0000000..e014ea9
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/devices/BanknoteValidator.java
@@ -0,0 +1,201 @@
+package org.lsmr.selfcheckout.devices;
+
+import java.util.Arrays;
+import java.util.Currency;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Random;
+
+import org.lsmr.selfcheckout.Banknote;
+import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
+import org.lsmr.selfcheckout.devices.observers.BanknoteValidatorObserver;
+
+/**
+ * Represents a device for optically and/or magnetically validating banknotes.
+ * Banknotes deemed valid are moved to storage; banknotes deemed invalid are
+ * ejected.
+ */
+public final class BanknoteValidator extends AbstractDevice<BanknoteValidatorObserver>
+	implements Acceptor<Banknote>, Emitter<Banknote> {
+	private final Currency currency;
+	private final int[] denominations;
+	private BidirectionalChannel<Banknote> source;
+	private UnidirectionalChannel<Banknote> sink;
+
+	/**
+	 * Creates a banknote validator that recognizes banknotes of the specified
+	 * denominations (i.e., values) and currency.
+	 * 
+	 * @param currency
+	 *            The kind of currency to accept.
+	 * @param denominations
+	 *            An array of the valid banknote denominations (like $5, $10, etc.)
+	 *            to accept. Each value must be &gt;0 and unique in this array.
+	 * @throws SimulationException
+	 *             If either argument is null.
+	 * @throws SimulationException
+	 *             If the denominations array does not contain at least one value.
+	 * @throws SimulationException
+	 *             If any value in the denominations array is non-positive.
+	 * @throws SimulationException
+	 *             If any value in the denominations array is non-unique.
+	 */
+	public BanknoteValidator(Currency currency, int[] denominations) {
+		if(currency == null)
+			throw new SimulationException(
+				new NullPointerException("currency is null, which has no analogue in the real world."));
+
+		if(denominations == null)
+			throw new SimulationException(
+				new NullPointerException("denominations is null, which has no analogue in the real world."));
+
+		if(denominations.length < 1)
+			throw new SimulationException(new IllegalArgumentException("There must be at least one denomination."));
+
+		this.currency = currency;
+		Arrays.sort(denominations);
+
+		HashSet<Integer> set = new HashSet<>();
+
+		for(int denomination : denominations) {
+			if(denomination <= 0)
+				throw new SimulationException(
+					new IllegalArgumentException("Non-positive denomination detected: " + denomination + "."));
+
+			if(set.contains(denomination))
+				throw new SimulationException(new IllegalArgumentException(
+					"Each denomination must be unique, but " + denomination + " is repeated."));
+
+			set.add(denomination);
+		}
+
+		this.denominations = denominations;
+	}
+
+	/**
+	 * Connects input and output channels to the banknote validator. Causes no events.
+	 * <p>
+	 * This operation is permissible only during the configuration phase.
+	 * 
+	 * @param source
+	 *            The channel from which banknotes normally arrive for validation,
+	 *            and to which invalid banknotes will be ejected.
+	 * @param sink
+	 *            The channel to which all valid banknotes are routed.
+	 */
+	public void connect(BidirectionalChannel<Banknote> source, UnidirectionalChannel<Banknote> sink) {
+		if(phase != Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may only be called during the configuration phase."));
+
+		this.source = source;
+		this.sink = sink;
+	}
+
+	private final Random pseudoRandomNumberGenerator = new Random();
+	private static final int PROBABILITY_OF_FALSE_REJECTION = 1; /* out of 100 */
+
+	private boolean isValid(Banknote banknote) {
+		if(currency.equals(banknote.getCurrency()))
+			for(int denomination : denominations)
+				if(denomination == banknote.getValue())
+					return pseudoRandomNumberGenerator.nextInt(100) >= PROBABILITY_OF_FALSE_REJECTION;
+
+		return false;
+	}
+
+	/**
+	 * Tells the banknote validator that the indicated banknote is being inserted.
+	 * If the banknote is valid, a "validBanknoteDetected" event is announced to its
+	 * observers; otherwise, an "invalidBanknoteDetected" event is announced to its
+	 * observers.
+	 * <p>
+	 * If there is space in the machine to store a valid banknote, it is passed to
+	 * the sink channel.
+	 * </p>
+	 * <p>
+	 * If there is no space in the machine to store it or the banknote is invalid,
+	 * the banknote is ejected to the source.
+	 * </p>
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @param banknote
+	 *            The banknote to be added. Cannot be null.
+	 * @throws DisabledException
+	 *             if the banknote validator is currently disabled.
+	 * @throws SimulationException
+	 *             If the banknote is null.
+	 */
+	@Override
+	public void accept(Banknote banknote) throws DisabledException {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		if(isDisabled())
+			throw new DisabledException();
+
+		if(banknote == null)
+			throw new SimulationException(new NullPointerException("banknote is null"));
+
+		if(isValid(banknote)) {
+			notifyValidBanknoteDetected(banknote);
+
+			if(sink.hasSpace()) {
+				try {
+					sink.deliver(banknote);
+				}
+				catch(OverloadException e) {
+					// Should never happen
+					phase = Phase.ERROR;
+					throw new SimulationException(e);
+				}
+			}
+			else {
+				try {
+					source.eject(banknote);
+				}
+				catch(OverloadException e) {
+					// Should never happen
+					phase = Phase.ERROR;
+					throw new SimulationException(e);
+				}
+			}
+		}
+		else {
+			notifyInvalidBanknoteDetected();
+
+			try {
+				source.eject(banknote);
+			}
+			catch(OverloadException e) {
+				// Should never happen
+				phase = Phase.ERROR;
+				throw new SimulationException("Unable to route banknote: sink is full");
+			}
+		}
+	}
+
+	@Override
+	public boolean hasSpace() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+
+		return true;
+	}
+
+	private void notifyValidBanknoteDetected(Banknote banknote) {
+		for(BanknoteValidatorObserver observer : observers)
+			observer.validBanknoteDetected(this, banknote.getCurrency(), banknote.getValue());
+	}
+
+	private void notifyInvalidBanknoteDetected() {
+		for(BanknoteValidatorObserver observer : observers)
+			observer.invalidBanknoteDetected(this);
+	}
+}
diff --git a/src/org/lsmr/selfcheckout/devices/BarcodeScanner.java b/src/org/lsmr/selfcheckout/devices/BarcodeScanner.java
new file mode 100644
index 0000000..872da0e
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/devices/BarcodeScanner.java
@@ -0,0 +1,60 @@
+package org.lsmr.selfcheckout.devices;
+
+import java.util.Random;
+
+import org.lsmr.selfcheckout.BarcodedItem;
+import org.lsmr.selfcheckout.Item;
+import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
+import org.lsmr.selfcheckout.devices.observers.BarcodeScannerObserver;
+
+/**
+ * A complex device hidden behind a simple simulation. They can scan and that is
+ * about all.
+ */
+public class BarcodeScanner extends AbstractDevice<BarcodeScannerObserver> {
+	/**
+	 * Create a barcode scanner.
+	 */
+	public BarcodeScanner() {}
+
+	private Random random = new Random();
+	private static final int PROBABILITY_OF_FAILED_SCAN = 10; /* out of 100 */
+
+	/**
+	 * Simulates the customer's action of scanning an item. The result of the scan
+	 * is only announced to any registered observers.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @param item
+	 *            The item to scan. Of course, it will only work if the item has a
+	 *            barcode, and maybe not even then.
+	 * @throws SimulationException
+	 *             If item is null.
+	 */
+	public void scan(Item item) {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		if(isDisabled())
+			return; // silently ignore it
+
+		if(item == null)
+			throw new SimulationException(
+				new NullPointerException("item is null, which has no analogue in the real world."));
+
+		if(item instanceof BarcodedItem && random.nextInt(100) >= PROBABILITY_OF_FAILED_SCAN)
+			notifyBarcodeScanned((BarcodedItem)item);
+
+		// otherwise, silently ignore it
+	}
+
+	private void notifyBarcodeScanned(BarcodedItem item) {
+		for(BarcodeScannerObserver l : observers)
+			l.barcodeScanned(this, item.getBarcode());
+	}
+}
diff --git a/src/org/lsmr/selfcheckout/devices/BidirectionalChannel.java b/src/org/lsmr/selfcheckout/devices/BidirectionalChannel.java
new file mode 100644
index 0000000..4d67894
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/devices/BidirectionalChannel.java
@@ -0,0 +1,69 @@
+package org.lsmr.selfcheckout.devices;
+
+import org.lsmr.selfcheckout.Banknote;
+import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
+
+/**
+ * Represents a simple device (like, say, a tube or just a physical connection)
+ * that moves things between other devices. This channel is bidirectional.
+ * 
+ * @param <T>
+ *            The type of the things to move.
+ */
+public final class BidirectionalChannel<T> {
+	private FlowThroughEmitter<T> source;
+	private Acceptor<T> sink;
+
+	/**
+	 * Constructs a new channel whose input is connected to the indicated source and
+	 * whose output is connected to the indicated sink.
+	 * 
+	 * @param source
+	 *            The device at the output end of the channel.
+	 * @param sink
+	 *            The device at the output end of the channel.
+	 */
+	public BidirectionalChannel(FlowThroughEmitter<T> source, Acceptor<T> sink) {
+		this.source = source;
+		this.sink = sink;
+	}
+
+	/**
+	 * Moves the indicated thing to the source. This method should be called by
+	 * the sink device, and not by an external application.
+	 * 
+	 * @param thing
+	 *            The thing to transport via the channel.
+	 * @throws OverloadException
+	 *             if the sink has no space for the banknote.
+	 * @throws DisabledException
+	 *             if the sink is currently disabled.
+	 */
+	public void eject(T thing) throws OverloadException, DisabledException {
+		source.emit(thing);
+	}
+
+	/**
+	 * Moves the indicated banknote to the sink. This method should be called by the
+	 * source device, and not by an external application.
+	 * 
+	 * @param banknote
+	 *            The banknote to transport via the channel.
+	 * @throws OverloadException
+	 *             if the sink has no space for the banknote.
+	 * @throws DisabledException
+	 *             if the sink is currently disabled.
+	 */
+	public void deliver(T banknote) throws OverloadException, DisabledException {
+		sink.accept(banknote);
+	}
+
+	/**
+	 * Returns whether the sink has space for at least one more banknote.
+	 * 
+	 * @return true if the sink can accept a banknote; false otherwise.
+	 */
+	public boolean hasSpace() {
+		return sink.hasSpace();
+	}
+}
diff --git a/src/org/lsmr/selfcheckout/devices/CardReader.java b/src/org/lsmr/selfcheckout/devices/CardReader.java
new file mode 100644
index 0000000..de592f1
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/devices/CardReader.java
@@ -0,0 +1,185 @@
+package org.lsmr.selfcheckout.devices;
+
+import java.awt.image.BufferedImage;
+import java.io.IOException;
+import java.util.concurrent.ThreadLocalRandom;
+
+import org.lsmr.selfcheckout.Card;
+import org.lsmr.selfcheckout.Card.CardData;
+import org.lsmr.selfcheckout.ChipFailureException;
+import org.lsmr.selfcheckout.MagneticStripeFailureException;
+import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
+import org.lsmr.selfcheckout.devices.observers.CardReaderObserver;
+
+/**
+ * Represents the card reader, capable of tap, chip insert, and swipe. Either
+ * the reader or the card may fail, or the data read in can be corrupted, with
+ * varying probabilities.
+ */
+public class CardReader extends AbstractDevice<CardReaderObserver> {
+	private boolean cardIsInserted = false;
+
+	/**
+	 * Create a card reader.
+	 */
+	public CardReader() {}
+
+	private final static ThreadLocalRandom random = ThreadLocalRandom.current();
+	private final static double PROBABILITY_OF_TAP_FAILURE = 0.01;
+	private final static double PROBABILITY_OF_INSERT_FAILURE = 0.01;
+	private final static double PROBABILITY_OF_SWIPE_FAILURE = 0.1;
+
+	/**
+	 * Tap the card.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @param card
+	 *            The card to tap.
+	 * @return The card's (possibly corrupted) data, or null if the card is not tap
+	 *             enabled.
+	 * @throws IOException
+	 *             If the tap failed (lack of failure does not mean that the data is
+	 *             not corrupted).
+	 */
+	public CardData tap(Card card) throws IOException {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		if(card.isTapEnabled) {
+			notifyCardTapped();
+
+			if(random.nextDouble(0.0, 1.0) > PROBABILITY_OF_TAP_FAILURE) {
+				CardData data = card.tap();
+
+				notifyCardDataRead(data);
+
+				return data;
+			}
+			else
+				throw new ChipFailureException();
+		}
+
+		// else ignore
+		return null;
+	}
+
+	/**
+	 * Swipe the card.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @param card
+	 *            The card to swipe.
+	 * @return The card data.
+	 * @throws IOException
+	 *             If the swipe failed.
+	 */
+	public CardData swipe(Card card) throws IOException {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		notifyCardSwiped();
+
+		if(random.nextDouble(0.0, 1.0) > PROBABILITY_OF_SWIPE_FAILURE) {
+			CardData data = card.swipe();
+
+			notifyCardDataRead(data);
+
+			return data;
+		}
+
+		throw new MagneticStripeFailureException();
+	}
+
+	/**
+	 * Insert the card.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @param card
+	 *            The card to insert.
+	 * @param pin
+	 *            The customer's PIN.
+	 * @return The card data.
+	 * @throws SimulationException
+	 *             If there is already a card in the slot.
+	 * @throws IOException
+	 *             The insertion failed.
+	 */
+	public CardData insert(Card card, String pin) throws IOException {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		if(cardIsInserted)
+			throw new IllegalStateException("There is already a card in the slot");
+
+		cardIsInserted = true;
+
+		notifyCardInserted();
+
+		if(card.hasChip && random.nextDouble(0.0, 1.0) > PROBABILITY_OF_INSERT_FAILURE) {
+			CardData data = card.insert(pin);
+
+			notifyCardDataRead(data);
+
+			return data;
+		}
+
+		throw new ChipFailureException();
+	}
+
+	/**
+	 * Remove the card from the slot.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 */
+	public void remove() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		cardIsInserted = false;
+		notifyCardRemoved();
+	}
+
+	private void notifyCardTapped() {
+		for(CardReaderObserver l : observers)
+			l.cardTapped(this);
+	}
+
+	private void notifyCardInserted() {
+		for(CardReaderObserver l : observers)
+			l.cardInserted(this);
+	}
+
+	private void notifyCardSwiped() {
+		for(CardReaderObserver l : observers)
+			l.cardSwiped(this);
+	}
+
+	private void notifyCardDataRead(CardData data) {
+		for(CardReaderObserver l : observers)
+			l.cardDataRead(this, data);
+	}
+
+	private void notifyCardRemoved() {
+		for(CardReaderObserver l : observers)
+			l.cardRemoved(this);
+	}
+}
diff --git a/src/org/lsmr/selfcheckout/devices/CoinDispenser.java b/src/org/lsmr/selfcheckout/devices/CoinDispenser.java
new file mode 100644
index 0000000..e6cdc73
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/devices/CoinDispenser.java
@@ -0,0 +1,262 @@
+package org.lsmr.selfcheckout.devices;
+
+import java.util.ArrayList;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Queue;
+
+import org.lsmr.selfcheckout.Coin;
+import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
+import org.lsmr.selfcheckout.devices.observers.CoinDispenserObserver;
+
+/**
+ * Represents a device that stores coins of a particular denomination to
+ * dispense them as change.
+ * <p>
+ * Coin dispensers can receive coins from other sources. To simplify the
+ * simulation, no check is performed on the value of each coin, meaning it is an
+ * external responsibility to ensure the correct routing of coins.
+ * </p>
+ */
+public final class CoinDispenser extends AbstractDevice<CoinDispenserObserver>
+	implements Acceptor<Coin>, FromStorageEmitter<Coin> {
+	private int maxCapacity;
+	private Queue<Coin> queue = new LinkedList<Coin>();
+	private UnidirectionalChannel<Coin> sink;
+
+	/**
+	 * Creates a coin dispenser with the indicated maximum capacity.
+	 * 
+	 * @param capacity
+	 *            The maximum number of coins that can be stored in the dispenser.
+	 *            Must be positive.
+	 * @throws SimulationException
+	 *             if capacity is not positive.
+	 */
+	public CoinDispenser(int capacity) {
+		if(capacity <= 0)
+			throw new SimulationException(new IllegalArgumentException("Capacity must be positive: " + capacity));
+
+		this.maxCapacity = capacity;
+	}
+
+	/**
+	 * Accesses the current number of coins in the dispenser.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 * 
+	 * @return The number of coins currently in the dispenser.
+	 */
+	public int size() {
+		return queue.size();
+	}
+
+	/**
+	 * Allows a set of coins to be loaded into the dispenser directly. Existing
+	 * coins in the dispenser are not removed. Causes a "coinsLoaded" event to be
+	 * announced.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 * 
+	 * @param coins
+	 *            A sequence of coins to be added. Each cannot be null.
+	 * @throws OverloadException
+	 *             if the number of coins to be loaded exceeds the capacity of the
+	 *             dispenser.
+	 * @throws SimulationException
+	 *             If any coin is null.
+	 */
+	public void load(Coin... coins) throws SimulationException, OverloadException {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+
+		if(maxCapacity < queue.size() + coins.length)
+			throw new OverloadException("Capacity of dispenser is exceeded by load");
+
+		for(Coin coin : coins)
+			if(coin == null)
+				throw new SimulationException(new NullPointerException("A coin is null"));
+			else
+				queue.add(coin);
+
+		notifyLoad(coins);
+	}
+
+	private void notifyLoad(Coin[] coins) {
+		for(CoinDispenserObserver observer : observers)
+			observer.coinsLoaded(this, coins);
+	}
+
+	/**
+	 * Unloads coins from the dispenser directly. Causes a "coinsUnloaded" event to
+	 * be announced.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 * 
+	 * @return A list of the coins unloaded. May be empty. Will never be null.
+	 */
+	public List<Coin> unload() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+
+		List<Coin> result = new ArrayList<>(queue);
+		queue.clear();
+
+		notifyUnload(result.toArray(new Coin[result.size()]));
+
+		return result;
+	}
+
+	private void notifyUnload(Coin[] coins) {
+		for(CoinDispenserObserver observer : observers)
+			observer.coinsUnloaded(this, coins);
+	}
+
+	/**
+	 * Connects an output channel to this coin dispenser. Any existing output
+	 * channels are disconnected. Causes no events to be announced.
+	 * <p>
+	 * This operation is only permissible during the configuration phase.
+	 * 
+	 * @param sink
+	 *            The new output device to act as output. Can be null, which leaves
+	 *            the channel without an output.
+	 */
+	public void connect(UnidirectionalChannel<Coin> sink) {
+		if(phase != Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may only be called during the configuration phase."));
+
+		this.sink = sink;
+	}
+
+	/**
+	 * Returns the maximum capacity of this coin dispenser.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 * 
+	 * @return The capacity. Will be positive.
+	 */
+	public int getCapacity() {
+		return maxCapacity;
+	}
+
+	/**
+	 * Causes the indicated coin to be added into the dispenser. If successful, a
+	 * "coinAdded" event is announced to its observers. If a successful coin
+	 * addition causes the dispenser to become full, a "coinsFull" event is
+	 * announced to its observers.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @throws DisabledException
+	 *             If the coin dispenser is currently disabled.
+	 * @throws SimulationException
+	 *             If coin is null.
+	 * @throws OverloadException
+	 *             If the coin dispenser is already full.
+	 */
+	@Override
+	public void accept(Coin coin) throws OverloadException, DisabledException {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		if(isDisabled())
+			throw new DisabledException();
+
+		if(coin == null)
+			throw new SimulationException(
+				new NullPointerException("coin is null, which has no analogue in the real world."));
+
+		if(queue.size() >= maxCapacity)
+			throw new OverloadException();
+
+		queue.add(coin);
+		notifyCoinAdded(coin);
+
+		if(queue.size() >= maxCapacity)
+			notifyCoinsFull();
+	}
+
+	/**
+	 * Releases a single coin from this coin dispenser. If successful, a
+	 * "coinRemoved" event is announced to its observers. If a successful coin
+	 * removal causes the dispenser to become empty, a "coinsEmpty" event is
+	 * announced to its observers.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @throws OverloadException
+	 *             If the output channel is unable to accept another coin.
+	 * @throws EmptyException
+	 *             If no coins are present in the dispenser to release.
+	 * @throws DisabledException
+	 *             If the dispenser is currently disabled.
+	 */
+	public void emit() throws OverloadException, EmptyException, DisabledException {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		if(isDisabled())
+			throw new DisabledException();
+
+		if(queue.size() == 0)
+			throw new EmptyException();
+
+		Coin coin = queue.remove();
+
+		notifyCoinRemoved(coin);
+		sink.deliver(coin);
+
+		if(queue.isEmpty())
+			notifyCoinsEmpty();
+	}
+
+	/**
+	 * Returns whether this coin dispenser has enough space to accept at least one
+	 * more coin. Announces no events.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 */
+	@Override
+	public boolean hasSpace() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		return queue.size() < maxCapacity;
+	}
+
+	private void notifyCoinAdded(Coin coin) {
+		for(CoinDispenserObserver observer : observers)
+			observer.coinAdded(this, coin);
+	}
+
+	private void notifyCoinRemoved(Coin coin) {
+		for(CoinDispenserObserver observer : observers)
+			observer.coinRemoved(this, coin);
+	}
+
+	private void notifyCoinsFull() {
+		for(CoinDispenserObserver observer : observers)
+			observer.coinsFull(this);
+	}
+
+	private void notifyCoinsEmpty() {
+		for(CoinDispenserObserver observer : observers)
+			observer.coinsEmpty(this);
+	}
+}
diff --git a/src/org/lsmr/selfcheckout/devices/CoinSlot.java b/src/org/lsmr/selfcheckout/devices/CoinSlot.java
new file mode 100644
index 0000000..514af14
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/devices/CoinSlot.java
@@ -0,0 +1,97 @@
+package org.lsmr.selfcheckout.devices;
+
+import org.lsmr.selfcheckout.Coin;
+import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
+import org.lsmr.selfcheckout.devices.observers.CoinSlotObserver;
+
+/**
+ * Represents a simple coin slot device that has one output channel. The slot is
+ * stupid: it has no functionality other than being enabled/disabled, and cannot
+ * determine the value and currency of the coin.
+ */
+public final class CoinSlot extends AbstractDevice<CoinSlotObserver> implements Acceptor<Coin> {
+	private UnidirectionalChannel<Coin> sink;
+
+	/**
+	 * Creates a coin slot.
+	 */
+	public CoinSlot() {}
+
+	/**
+	 * Connects channels to the coin slot. Causes no events.
+	 * <p>
+	 * This operation is permissible only during the configuration phase.
+	 * 
+	 * @param sink
+	 *            Where coins will always be passed.
+	 */
+	public void connect(UnidirectionalChannel<Coin> sink) {
+		if(phase != Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may only be called during the configuration phase."));
+
+		this.sink = sink;
+	}
+
+	/**
+	 * Tells the coin slot that the indicated coin is being inserted. If the slot is
+	 * enabled, this causes a "coinInserted" event to be announced to its observers.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @param coin
+	 *            The coin to be added. Cannot be null.
+	 * @throws DisabledException
+	 *             If the coin slot is currently disabled.
+	 * @throws SimulationException
+	 *             If coin is null.
+	 * @throws NullPointerException
+	 *             If the coin is null.
+	 */
+	public void accept(Coin coin) throws DisabledException {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		if(isDisabled())
+			throw new DisabledException();
+
+		if(coin == null)
+			throw new SimulationException(new NullPointerException("coin is null"));
+
+		notifyCoinInserted();
+
+		if(sink.hasSpace()) {
+			try {
+				sink.deliver(coin);
+			}
+			catch(OverloadException e) {
+				// Should never happen
+				phase = Phase.ERROR;
+				throw new SimulationException(e);
+			}
+		}
+		else
+			throw new SimulationException("Unable to route coin: Output channel is full");
+	}
+
+	@Override
+	public boolean hasSpace() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		return sink.hasSpace();
+	}
+
+	private void notifyCoinInserted() {
+		for(CoinSlotObserver observer : observers)
+			observer.coinInserted(this);
+	}
+}
diff --git a/src/org/lsmr/selfcheckout/devices/CoinStorageUnit.java b/src/org/lsmr/selfcheckout/devices/CoinStorageUnit.java
new file mode 100644
index 0000000..6fc0059
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/devices/CoinStorageUnit.java
@@ -0,0 +1,186 @@
+package org.lsmr.selfcheckout.devices;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+
+import org.lsmr.selfcheckout.Coin;
+import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
+import org.lsmr.selfcheckout.devices.observers.CoinStorageUnitObserver;
+
+/**
+ * Represents devices that store coins. They only receive coins, not dispense
+ * them. To access the coins inside, a human operator needs to physically remove
+ * the coins, simulated with the {@link #unload()} method. A
+ * {@link #load(Coin...)} method is provided for symmetry.
+ */
+public class CoinStorageUnit extends AbstractDevice<CoinStorageUnitObserver> implements Acceptor<Coin> {
+	private Coin[] storage;
+	private int nextIndex = 0;
+
+	/**
+	 * Creates a coin storage unit that can hold the indicated number of coins.
+	 * 
+	 * @param capacity
+	 *            The maximum number of coins that the unit can hold.
+	 * @throws SimulationException
+	 *             If the capacity is not positive.
+	 */
+	public CoinStorageUnit(int capacity) {
+		if(capacity <= 0)
+			throw new SimulationException(new IllegalArgumentException("The capacity must be positive."));
+
+		storage = new Coin[capacity];
+	}
+
+	/**
+	 * Gets the maximum number of coins that this storage unit can hold.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 * 
+	 * @return The capacity.
+	 */
+	public int getCapacity() {
+		return storage.length;
+	}
+
+	/**
+	 * Gets the current count of coins contained in this storage unit.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 * 
+	 * @return The current count.
+	 */
+	public int getCoinCount() {
+		return nextIndex;
+	}
+
+	/**
+	 * Allows a set of coins to be loaded into the storage unit directly. Existing
+	 * coins in the dispenser are not removed. Causes a "coinsLoaded" event to be
+	 * announced. Disabling has no effect on loading/unloading.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @param coins
+	 *            A sequence of coins to be added. Each cannot be null.
+	 * @throws SimulationException
+	 *             if the number of coins to be loaded exceeds the capacity of the
+	 *             unit.
+	 * @throws SimulationException
+	 *             If coins is null.
+	 * @throws SimulationException
+	 *             If any coin is null.
+	 * @throws OverloadException
+	 *             If too many coins are loaded.
+	 */
+	public void load(Coin... coins) throws SimulationException, OverloadException {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+
+		if(coins == null)
+			throw new SimulationException(
+				new NullPointerException("coins is null, which has no analogue in the real world."));
+
+		if(coins.length + nextIndex > storage.length)
+			throw new OverloadException("You tried to stuff too many coins in the storage unit.");
+
+		for(Coin coin : coins)
+			if(coin == null)
+				throw new SimulationException(new NullPointerException("No coin may be null"));
+
+		System.arraycopy(coins, 0, storage, nextIndex, coins.length);
+		nextIndex += coins.length;
+
+		notifyCoinsLoaded();
+	}
+
+	/**
+	 * Unloads coins from the storage unit directly. Causes a "coinsUnloaded" event
+	 * to be announced.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 * 
+	 * @return A list of the coins unloaded. May be empty. Will never be null.
+	 */
+	public List<Coin> unload() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+
+		List<Coin> coins = Arrays.asList(storage);
+
+		storage = new Coin[storage.length];
+		nextIndex = 0;
+		notifyCoinsUnloaded();
+
+		return coins;
+	}
+
+	/**
+	 * Causes the indicated coin to be added to the storage unit. If successful, a
+	 * "coinAdded" event is announced to its observers. If a successful coin
+	 * addition instead causes the unit to become full, a "coinsFull" event is
+	 * announced to its observers.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @throws DisabledException
+	 *             If the unit is currently disabled.
+	 * @throws SimulationException
+	 *             If coin is null.
+	 * @throws OverloadException
+	 *             If the unit is already full.
+	 */
+	public void accept(Coin coin) throws DisabledException, OverloadException {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		if(isDisabled())
+			throw new DisabledException();
+
+		if(coin == null)
+			throw new SimulationException(new NullPointerException("coin is null"));
+
+		if(nextIndex < storage.length) {
+			storage[nextIndex++] = coin;
+
+			if(nextIndex == storage.length)
+				notifyCoinsFull();
+			else
+				notifyCoinAdded();
+		}
+		else
+			throw new OverloadException();
+	}
+
+	@Override
+	public boolean hasSpace() {
+		return nextIndex < storage.length;
+	}
+
+	private void notifyCoinsLoaded() {
+		for(CoinStorageUnitObserver l : observers)
+			l.coinsLoaded(this);
+	}
+
+	private void notifyCoinsUnloaded() {
+		for(CoinStorageUnitObserver l : observers)
+			l.coinsUnloaded(this);
+	}
+
+	private void notifyCoinsFull() {
+		for(CoinStorageUnitObserver l : observers)
+			l.coinsFull(this);
+	}
+
+	private void notifyCoinAdded() {
+		for(CoinStorageUnitObserver l : observers)
+			l.coinAdded(this);
+	}
+}
diff --git a/src/org/lsmr/selfcheckout/devices/CoinTray.java b/src/org/lsmr/selfcheckout/devices/CoinTray.java
new file mode 100644
index 0000000..dabc9c3
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/devices/CoinTray.java
@@ -0,0 +1,102 @@
+package org.lsmr.selfcheckout.devices;
+
+import java.util.Arrays;
+import java.util.List;
+
+import org.lsmr.selfcheckout.Coin;
+import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
+import org.lsmr.selfcheckout.devices.observers.CoinTrayObserver;
+
+/**
+ * Simulates the tray where dispensed coins go for the user to collect them.
+ */
+public class CoinTray extends AbstractDevice<CoinTrayObserver> implements Acceptor<Coin> {
+	private Coin[] coins;
+	private int nextIndex = 0;
+
+	/**
+	 * Creates a coin tray.
+	 * 
+	 * @param capacity
+	 *            The maximum number of coins that this tray can hold without
+	 *            overflowing.
+	 * @throws SimulationException
+	 *             If the capacity is &le;0.
+	 */
+	public CoinTray(int capacity) {
+		if(capacity <= 0)
+			throw new SimulationException(new IllegalArgumentException("capacity must be positive."));
+
+		coins = new Coin[capacity];
+	}
+
+	/**
+	 * Causes the indicated coin to be added to the tray. A "coinAdded" event is
+	 * announced to observers.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @param coin
+	 *            The coin to add.
+	 * @throws SimulationException
+	 *             If coin is null.
+	 * @throws OverloadException
+	 *             If the tray overflows.
+	 */
+	public void accept(Coin coin) throws OverloadException, DisabledException {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		if(coin == null)
+			throw new SimulationException(
+				new NullPointerException("coin is null, which has no analogue in the real world."));
+
+		if(nextIndex < coins.length) {
+			coins[nextIndex++] = coin;
+			notifyCoinAdded();
+		}
+		else
+			throw new OverloadException("The tray has overflowed.");
+	}
+
+	/**
+	 * Simulates the act of physically removing coins from the try by a user.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @return The list of coins collected. May not be null. May be empty.
+	 */
+	public List<Coin> collectCoins() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		List<Coin> result = Arrays.asList(coins);
+
+		coins = new Coin[coins.length];
+		nextIndex = 0;
+
+		return result;
+	}
+
+	/**
+	 * Returns whether this coin receptacle has enough space to accept at least one
+	 * more coin: always true. Causes no events.
+	 */
+	@Override
+	public boolean hasSpace() {
+		return nextIndex < coins.length;
+	}
+
+	private void notifyCoinAdded() {
+		for(CoinTrayObserver l : observers)
+			l.coinAdded(this);
+	}
+}
diff --git a/src/org/lsmr/selfcheckout/devices/CoinValidator.java b/src/org/lsmr/selfcheckout/devices/CoinValidator.java
new file mode 100644
index 0000000..faf47e3
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/devices/CoinValidator.java
@@ -0,0 +1,268 @@
+package org.lsmr.selfcheckout.devices;
+
+import java.math.BigDecimal;
+import java.util.Collections;
+import java.util.Currency;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Random;
+
+import org.lsmr.selfcheckout.Coin;
+import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
+import org.lsmr.selfcheckout.devices.observers.CoinValidatorObserver;
+
+/**
+ * Represents a device for optically and/or physically validating coins. Coins
+ * deemed valid are moved to storage; coins deemed invalid are ejected.
+ */
+public final class CoinValidator extends AbstractDevice<CoinValidatorObserver> implements Acceptor<Coin> {
+	public final Currency currency;
+	private List<BigDecimal> denominations;
+	private UnidirectionalChannel<Coin> rejectionSink, overflowSink;
+	private Map<BigDecimal, UnidirectionalChannel<Coin>> standardSinks = null;
+
+	/**
+	 * Creates a coin validator that recognizes coins of the specified denominations
+	 * (i.e., values) and currency.
+	 * 
+	 * @param currency
+	 *            The kind of currency to accept.
+	 * @param denominations
+	 *            An array of the valid coin denominations (like $0.05, $0.10, etc.)
+	 *            to accept. Each value must be &gt;0 and unique in this array.
+	 * @throws SimulationException
+	 *             If either argument is null.
+	 * @throws SimulationException
+	 *             If the denominations array does not contain at least one value.
+	 * @throws SimulationException
+	 *             If any value in the denominations array is non-positive.
+	 * @throws SimulationException
+	 *             If any value in the denominations array is non-unique.
+	 */
+	public CoinValidator(Currency currency, List<BigDecimal> denominations) {
+		if(currency == null)
+			throw new SimulationException(
+				new NullPointerException("currency is null, which has no analogue in the real world."));
+
+		if(denominations == null)
+			throw new SimulationException(
+				new NullPointerException("denominations is null, which has no analogue in the real world."));
+
+		if(denominations.size() < 1)
+			throw new SimulationException(new IllegalArgumentException("There must be at least one denomination."));
+
+		this.currency = currency;
+		Collections.sort(denominations);
+
+		standardSinks = new HashMap<>();
+
+		for(BigDecimal denomination : denominations) {
+			if(denomination == null)
+				throw new SimulationException(new NullPointerException("A denomination is null"));
+
+			if(denomination.compareTo(BigDecimal.ZERO) <= 0)
+				throw new SimulationException(
+					new IllegalArgumentException("Non-positive denomination detected: " + denomination + "."));
+
+			if(standardSinks.containsKey(denomination))
+				throw new SimulationException(new IllegalArgumentException(
+					"Each denomination must be unique, but " + denomination + " is repeated."));
+
+			standardSinks.put(denomination, null);
+		}
+
+		this.denominations = denominations;
+	}
+
+	/**
+	 * Connects input and output channels to the coin slot. Causes no events.
+	 * <p>
+	 * This operation is permissible only during the configuration phase.
+	 * 
+	 * @param rejectionSink
+	 *            The channel to which rejected coins are routed.
+	 * @param overflowSink
+	 *            The channel to which valid coins are routed when the normal sink
+	 *            is full.
+	 * @param standardSinks
+	 *            The channels to which valid coins are normally routed. There must
+	 *            be one sink to correspond to each valid currency denomination, and
+	 *            they must be in the same order as the valid denominations.
+	 * @throws SimulationException
+	 *             If any argument is null.
+	 * @throws SimulationException
+	 *             If any standard sink is null.
+	 * @throws SimulationException
+	 *             If the number of standard sinks differs from the number of
+	 *             denominations.
+	 * @throws SimulationException
+	 *             If any sink is used in more than one position.
+	 */
+	public void connect(UnidirectionalChannel<Coin> rejectionSink,
+		Map<BigDecimal, UnidirectionalChannel<Coin>> standardSinks, UnidirectionalChannel<Coin> overflowSink) {
+		if(phase != Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may only be called during the configuration phase."));
+
+		if(rejectionSink == null)
+			throw new SimulationException(
+				new NullPointerException("rejectionSink is null, which has no analogue in the real world."));
+
+		if(overflowSink == null)
+			throw new SimulationException(
+				new NullPointerException("overflowSink is null, which has no analogue in the real world."));
+
+		if(standardSinks == null)
+			throw new SimulationException(
+				new NullPointerException("standardSinks is null, which has no analogue in the real world."));
+
+		if(standardSinks.keySet().size() != denominations.size())
+			throw new SimulationException(
+				new IllegalArgumentException("The number of standard sinks must equal the number of denominations."));
+
+		this.rejectionSink = rejectionSink;
+		this.overflowSink = overflowSink;
+
+		HashSet<UnidirectionalChannel<Coin>> set = new HashSet<>();
+
+		for(BigDecimal denomination : standardSinks.keySet()) {
+			UnidirectionalChannel<Coin> sink = standardSinks.get(denomination);
+			if(sink == null)
+				throw new SimulationException(
+					new NullPointerException("The sink for denomination " + denomination + " is null."));
+			else {
+				if(set.contains(sink))
+					throw new SimulationException(new IllegalArgumentException("Each channel must be unique."));
+
+				set.add(sink);
+			}
+		}
+
+		this.standardSinks = standardSinks;
+
+		if(set.contains(rejectionSink))
+			throw new SimulationException(new IllegalArgumentException("Each channel must be unique."));
+		else
+			set.add(rejectionSink);
+
+		if(set.contains(overflowSink))
+			throw new SimulationException(new IllegalArgumentException("Each channel must be unique."));
+
+		this.overflowSink = overflowSink;
+	}
+
+	private final Random pseudoRandomNumberGenerator = new Random();
+	private static final int PROBABILITY_OF_FALSE_REJECTION = 1; /* out of 100 */
+
+	private boolean isValid(Coin coin) {
+		if(currency.equals(coin.getCurrency()))
+			for(BigDecimal denomination : denominations)
+				if(denomination.equals(coin.getValue()))
+					return pseudoRandomNumberGenerator.nextInt(100) >= PROBABILITY_OF_FALSE_REJECTION;
+
+		return false;
+	}
+
+	/**
+	 * Tells the coin validator that the indicated coin is being inserted. If the
+	 * coin is valid, a "validCoinDetected" event is announced to its observers;
+	 * otherwise, an "invalidCoinDetected" event is announced to its observers.
+	 * <p>
+	 * If there is space in the machine to store a valid coin, it is passed to the
+	 * sink channel corresponding to the denomination of the coin.
+	 * </p>
+	 * <p>
+	 * If there is no space in the machine to store it or the coin is invalid, the
+	 * coin is ejected to the source.
+	 * </p>
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @param coin
+	 *            The coin to be added. Cannot be null.
+	 * @throws DisabledException
+	 *             if the coin validator is currently disabled.
+	 * @throws SimulationException
+	 *             If the coin is null.
+	 * @throws SimulationException
+	 *             If the coin cannot be delivered.
+	 */
+	public void accept(Coin coin) throws DisabledException {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		if(isDisabled())
+			throw new DisabledException();
+
+		if(coin == null)
+			throw new SimulationException(
+				new NullPointerException("coin is null, which has no analogue in the real world."));
+
+		if(isValid(coin)) {
+			notifyValidCoinDetected(coin);
+
+			UnidirectionalChannel<Coin> sink = standardSinks.get(coin.getValue());
+
+			if(sink.hasSpace()) {
+				try {
+					sink.deliver(coin);
+				}
+				catch(OverloadException e) {
+					// Should never happen
+					phase = Phase.ERROR;
+					throw new SimulationException(e);
+				}
+			}
+			else {
+				try {
+					rejectionSink.deliver(coin);
+				}
+				catch(OverloadException e) {
+					// Should never happen
+					phase = Phase.ERROR;
+					throw new SimulationException(e);
+				}
+			}
+		}
+		else {
+			notifyInvalidCoinDetected(coin);
+
+			try {
+				rejectionSink.deliver(coin);
+			}
+			catch(OverloadException e) {
+				// Should never happen
+				phase = Phase.ERROR;
+				throw new SimulationException(e);
+			}
+		}
+	}
+
+	@Override
+	public boolean hasSpace() {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		return true; // Since we cannot know yet where a coin will route, assume that it is OK.
+	}
+
+	private void notifyValidCoinDetected(Coin coin) {
+		for(CoinValidatorObserver observer : observers)
+			observer.validCoinDetected(this, coin.getValue());
+	}
+
+	private void notifyInvalidCoinDetected(Coin coin) {
+		for(CoinValidatorObserver observer : observers)
+			observer.invalidCoinDetected(this);
+	}
+}
diff --git a/src/org/lsmr/selfcheckout/devices/DisabledException.java b/src/org/lsmr/selfcheckout/devices/DisabledException.java
new file mode 100644
index 0000000..6f1690f
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/devices/DisabledException.java
@@ -0,0 +1,8 @@
+package org.lsmr.selfcheckout.devices;
+
+/**
+ * Issued when a device cannot perform its usual functions because it has been
+ * disabled.
+ */
+@SuppressWarnings("serial")
+public class DisabledException extends Exception {}
diff --git a/src/org/lsmr/selfcheckout/devices/ElectronicScale.java b/src/org/lsmr/selfcheckout/devices/ElectronicScale.java
new file mode 100644
index 0000000..ffdc112
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/devices/ElectronicScale.java
@@ -0,0 +1,171 @@
+package org.lsmr.selfcheckout.devices;
+
+import java.util.ArrayList;
+
+import org.lsmr.selfcheckout.Item;
+import org.lsmr.selfcheckout.devices.AbstractDevice.Phase;
+import org.lsmr.selfcheckout.devices.observers.ElectronicScaleObserver;
+
+public class ElectronicScale extends AbstractDevice<ElectronicScaleObserver> {
+	private ArrayList<Item> items = new ArrayList<>();
+
+	private double weightLimitInGrams;
+	private double currentWeightInGrams = 0;
+	private double weightAtLastEvent = 0;
+	private double sensitivity;
+
+	/**
+	 * Constructs an electronic scale with the indicated maximum weight that it can
+	 * handle before going into overload.
+	 * 
+	 * @param weightLimitInGrams
+	 *            The weight threshold beyond which the scale will overload.
+	 * @param sensitivity
+	 *            The number of grams that can be added or removed since the last
+	 *            change event, without causing a new change event.
+	 * @throws SimulationException
+	 *             If either argument is &le;0.
+	 */
+	public ElectronicScale(int weightLimitInGrams, int sensitivity) {
+		if(weightLimitInGrams <= 0)
+			throw new SimulationException(new IllegalArgumentException("The maximum weight cannot be zero or less."));
+
+		if(sensitivity <= 0)
+			throw new SimulationException(new IllegalArgumentException("The sensitivity cannot be zero or less."));
+
+		this.weightLimitInGrams = weightLimitInGrams;
+		this.sensitivity = sensitivity;
+	}
+
+	/**
+	 * Gets the weight limit for the scale.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 * 
+	 * @return The weight limit.
+	 */
+	public double getWeightLimit() {
+		return weightLimitInGrams;
+	}
+
+	/**
+	 * Gets the current weight on the scale.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @return The current weight.
+	 * @throws OverloadException
+	 *             If the weight has overloaded the scale.
+	 */
+	public double getCurrentWeight() throws OverloadException {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		if(currentWeightInGrams <= weightLimitInGrams)
+			return currentWeightInGrams;
+
+		throw new OverloadException();
+	}
+
+	/**
+	 * Gets the sensitivity of the scale. Changes smaller than this limit are not
+	 * noticed or announced.
+	 * <p>
+	 * This operation is permissible during the configuration phase.
+	 * 
+	 * @return The sensitivity.
+	 */
+	public double getSensitivity() {
+		return sensitivity;
+	}
+
+	/**
+	 * Adds an item to the scale.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @param item
+	 *            The item to add.
+	 * @throws SimulationException
+	 *             If the same item is added more than once.
+	 */
+	public void add(Item item) {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		if(items.contains(item))
+			throw new SimulationException("The same item cannot be added more than once to the scale.");
+
+		currentWeightInGrams += item.getWeight();
+
+		items.add(item);
+
+		if(currentWeightInGrams > weightLimitInGrams)
+			notifyOverload();
+		else if(currentWeightInGrams - weightAtLastEvent > sensitivity)
+			notifyWeightChanged();
+	}
+
+	/**
+	 * Removes an item from the scale.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @param item
+	 *            The item to remove.
+	 * @throws SimulationException
+	 *             If the item is not on the scale.
+	 */
+	public void remove(Item item) {
+		if(phase == Phase.ERROR)
+			throw new SimulationException(new IllegalStateException(
+				"This method may not be used when the device is in an erroneous operation phase."));
+		if(phase == Phase.CONFIGURATION)
+			throw new SimulationException(
+				new IllegalStateException("This method may not be called during the configuration phase."));
+
+		if(!items.remove(item))
+			throw new SimulationException("The item was not found amongst those on the scale.");
+
+		// To avoid drift in the sum due to round-off error, recalculate the weight.
+		double newWeightInGrams = 0.0;
+		for(Item itemOnScale : items)
+			newWeightInGrams += itemOnScale.getWeight();
+
+		double original = currentWeightInGrams;
+		currentWeightInGrams = newWeightInGrams;
+
+		if(original > weightLimitInGrams && newWeightInGrams <= weightLimitInGrams)
+			notifyOutOfOverload();
+
+		if(currentWeightInGrams <= weightLimitInGrams && weightAtLastEvent - currentWeightInGrams >= sensitivity)
+			notifyWeightChanged();
+	}
+
+	private void notifyOverload() {
+		for(ElectronicScaleObserver l : observers)
+			l.overload(this);
+	}
+
+	private void notifyOutOfOverload() {
+		weightAtLastEvent = currentWeightInGrams;
+
+		for(ElectronicScaleObserver l : observers)
+			l.outOfOverload(this);
+	}
+
+	private void notifyWeightChanged() {
+		weightAtLastEvent = currentWeightInGrams;
+
+		for(ElectronicScaleObserver l : observers)
+			l.weightChanged(this, currentWeightInGrams);
+	}
+}
diff --git a/src/org/lsmr/selfcheckout/devices/Emitter.java b/src/org/lsmr/selfcheckout/devices/Emitter.java
new file mode 100644
index 0000000..a8ab600
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/devices/Emitter.java
@@ -0,0 +1,12 @@
+package org.lsmr.selfcheckout.devices;
+
+import org.lsmr.selfcheckout.Coin;
+
+/**
+ * A simple base interface for devices that emit things.
+ * 
+ * @param <T>
+ *            The type of the things to emit.
+ */
+public interface Emitter<T> {
+}
diff --git a/src/org/lsmr/selfcheckout/devices/EmptyException.java b/src/org/lsmr/selfcheckout/devices/EmptyException.java
new file mode 100644
index 0000000..b726903
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/devices/EmptyException.java
@@ -0,0 +1,9 @@
+package org.lsmr.selfcheckout.devices;
+
+/**
+ * Represents the situation when a device is emptied but an attempt is made to
+ * remove something from it.
+ */
+public class EmptyException extends Exception {
+	private static final long serialVersionUID = 3566954386000387724L;
+}
diff --git a/src/org/lsmr/selfcheckout/devices/FlowThroughEmitter.java b/src/org/lsmr/selfcheckout/devices/FlowThroughEmitter.java
new file mode 100644
index 0000000..ff60458
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/devices/FlowThroughEmitter.java
@@ -0,0 +1,26 @@
+package org.lsmr.selfcheckout.devices;
+
+import org.lsmr.selfcheckout.Coin;
+
+/**
+ * A simple interface for devices that emit things.
+ * 
+ * @param <T>
+ *            The type of the things to emit.
+ */
+public interface FlowThroughEmitter<T> {
+	/**
+	 * Instructs the device to emit a specific thing, meaning that the device is
+	 * being handed this thing to pass onwards.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @param thing
+	 *            The thing to emit.
+	 * @throws DisabledException
+	 *             If the device is disabled.
+	 * @throws OverloadException
+	 *             If the receiving device is already full.
+	 */
+	public void emit(T thing) throws DisabledException, OverloadException;
+}
diff --git a/src/org/lsmr/selfcheckout/devices/FromStorageEmitter.java b/src/org/lsmr/selfcheckout/devices/FromStorageEmitter.java
new file mode 100644
index 0000000..ddb964a
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/devices/FromStorageEmitter.java
@@ -0,0 +1,26 @@
+package org.lsmr.selfcheckout.devices;
+
+import org.lsmr.selfcheckout.Coin;
+
+/**
+ * A simple interface for devices that emit things.
+ * 
+ * @param <T>
+ *            The type of the things to emit.
+ */
+public interface FromStorageEmitter<T> {
+	/**
+	 * Instructs the device to emit one thing, meaning that the device stores a set
+	 * of things and one of them is to be emitted.
+	 * <p>
+	 * This operation is not permissible during the configuration phase.
+	 * 
+	 * @throws DisabledException
+	 *             If the device is disabled.
+	 * @throws EmptyException
+	 *             If the device is empty and cannot emit.
+	 * @throws OverloadException
+	 *             If the receiving device is already full.
+	 */
+	public void emit() throws DisabledException, EmptyException, OverloadException;
+}
diff --git a/src/org/lsmr/selfcheckout/devices/observers/AbstractDeviceObserver.java b/src/org/lsmr/selfcheckout/devices/observers/AbstractDeviceObserver.java
new file mode 100644
index 0000000..ced7820
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/devices/observers/AbstractDeviceObserver.java
@@ -0,0 +1,26 @@
+package org.lsmr.selfcheckout.devices.observers;
+
+import org.lsmr.selfcheckout.devices.AbstractDevice;
+
+/**
+ * This class represents the abstract interface for all device observers. All
+ * subclasses should add their own event notification methods, the first
+ * parameter of which should always be the device affected.
+ */
+public interface AbstractDeviceObserver {
+	/**
+	 * Announces that the indicated device has been enabled.
+	 * 
+	 * @param device
+	 *                 The device that has been enabled.
+	 */
+	public void enabled(AbstractDevice<? extends AbstractDeviceObserver> device);
+
+	/**
+	 * Announces that the indicated device has been disabled.
+	 * 
+	 * @param device
+	 *                 The device that has been enabled.
+	 */
+	public void disabled(AbstractDevice<? extends AbstractDeviceObserver> device);
+}
diff --git a/src/org/lsmr/selfcheckout/devices/observers/BanknoteDispenserObserver.java b/src/org/lsmr/selfcheckout/devices/observers/BanknoteDispenserObserver.java
new file mode 100644
index 0000000..d4363bf
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/devices/observers/BanknoteDispenserObserver.java
@@ -0,0 +1,71 @@
+package org.lsmr.selfcheckout.devices.observers;
+
+import org.lsmr.selfcheckout.Banknote;
+import org.lsmr.selfcheckout.devices.BanknoteDispenser;
+
+/**
+ * Observes events emanating from a banknote dispenser.
+ */
+public interface BanknoteDispenserObserver extends AbstractDeviceObserver {
+	/**
+	 * Announces that the indicated banknote dispenser is full of banknotes.
+	 * 
+	 * @param dispenser
+	 *            The dispenser where the event occurred.
+	 */
+	void moneyFull(BanknoteDispenser dispenser);
+
+	/**
+	 * Announces that the indicated banknote dispenser is empty of banknotes.
+	 * 
+	 * @param dispenser
+	 *            The dispenser where the event occurred.
+	 */
+	void banknotesEmpty(BanknoteDispenser dispenser);
+
+	/**
+	 * Announces that the indicated banknote has been added to the indicated
+	 * banknote dispenser.
+	 * 
+	 * @param dispenser
+	 *            The dispenser where the event occurred.
+	 * @param banknote
+	 *            The banknote that was added.
+	 */
+	void billAdded(BanknoteDispenser dispenser, Banknote banknote);
+
+	/**
+	 * Announces that the indicated banknote has been added to the indicated
+	 * banknote dispenser.
+	 * 
+	 * @param dispenser
+	 *            The dispenser where the event occurred.
+	 * @param banknote
+	 *            The banknote that was removed.
+	 */
+	void banknoteRemoved(BanknoteDispenser dispenser, Banknote banknote);
+
+	/**
+	 * Announces that the indicated sequence of banknotes has been added to the
+	 * indicated banknote dispenser. Used to simulate direct, physical loading of
+	 * the dispenser.
+	 * 
+	 * @param dispenser
+	 *            The dispenser where the event occurred.
+	 * @param banknotes
+	 *            The banknotes that were loaded.
+	 */
+	void banknotesLoaded(BanknoteDispenser dispenser, Banknote... banknotes);
+
+	/**
+	 * Announces that the indicated sequence of banknotes has been removed to the
+	 * indicated banknote dispenser. Used to simulate direct, physical unloading of
+	 * the dispenser.
+	 * 
+	 * @param dispenser
+	 *            The dispenser where the event occurred.
+	 * @param banknotes
+	 *            The banknotes that were unloaded.
+	 */
+	void banknotesUnloaded(BanknoteDispenser dispenser, Banknote... banknotes);
+}
diff --git a/src/org/lsmr/selfcheckout/devices/observers/BanknoteSlotObserver.java b/src/org/lsmr/selfcheckout/devices/observers/BanknoteSlotObserver.java
new file mode 100644
index 0000000..20ced82
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/devices/observers/BanknoteSlotObserver.java
@@ -0,0 +1,34 @@
+package org.lsmr.selfcheckout.devices.observers;
+
+import org.lsmr.selfcheckout.Banknote;
+import org.lsmr.selfcheckout.devices.BanknoteSlot;
+
+/**
+ * Observes events emanating from a banknote slot.
+ */
+public interface BanknoteSlotObserver extends AbstractDeviceObserver {
+	/**
+	 * An event announcing that a banknote has been inserted.
+	 * 
+	 * @param slot
+	 *            The device on which the event occurred.
+	 */
+	void banknoteInserted(BanknoteSlot slot);
+
+	/**
+	 * An event announcing that a banknote has been returned to the user, dangling
+	 * from the slot.
+	 * 
+	 * @param slot
+	 *            The device on which the event occurred.
+	 */
+	void banknoteEjected(BanknoteSlot slot);
+
+	/**
+	 * An event announcing that a dangling banknote has been removed by the user.
+	 * 
+	 * @param slot
+	 *            The device on which the event occurred.
+	 */
+	void banknoteRemoved(BanknoteSlot slot);
+}
diff --git a/src/org/lsmr/selfcheckout/devices/observers/BanknoteStorageUnitObserver.java b/src/org/lsmr/selfcheckout/devices/observers/BanknoteStorageUnitObserver.java
new file mode 100644
index 0000000..9f17942
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/devices/observers/BanknoteStorageUnitObserver.java
@@ -0,0 +1,43 @@
+package org.lsmr.selfcheckout.devices.observers;
+
+import org.lsmr.selfcheckout.Banknote;
+import org.lsmr.selfcheckout.devices.BanknoteStorageUnit;
+
+/**
+ * Observes events emanating from a banknote storage unit.
+ */
+public interface BanknoteStorageUnitObserver extends AbstractDeviceObserver {
+	/**
+	 * Announces that the indicated banknote storage unit is full of banknotes.
+	 * 
+	 * @param unit
+	 *            The storage unit where the event occurred.
+	 */
+	void banknotesFull(BanknoteStorageUnit unit);
+
+	/**
+	 * Announces that a banknote has been added to the indicated storage unit.
+	 * 
+	 * @param unit
+	 *            The storage unit where the event occurred.
+	 */
+	void banknoteAdded(BanknoteStorageUnit unit);
+
+	/**
+	 * Announces that the indicated storage unit has been loaded with banknotes.
+	 * Used to simulate direct, physical loading of the unit.
+	 * 
+	 * @param unit
+	 *            The storage unit where the event occurred.
+	 */
+	void banknotesLoaded(BanknoteStorageUnit unit);
+
+	/**
+	 * Announces that the storage unit has been emptied of banknotes. Used to
+	 * simulate direct, physical unloading of the unit.
+	 * 
+	 * @param unit
+	 *            The storage unit where the event occurred.
+	 */
+	void banknotesUnloaded(BanknoteStorageUnit unit);
+}
diff --git a/src/org/lsmr/selfcheckout/devices/observers/BanknoteValidatorObserver.java b/src/org/lsmr/selfcheckout/devices/observers/BanknoteValidatorObserver.java
new file mode 100644
index 0000000..583fa9d
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/devices/observers/BanknoteValidatorObserver.java
@@ -0,0 +1,33 @@
+package org.lsmr.selfcheckout.devices.observers;
+
+import java.util.Currency;
+
+import org.lsmr.selfcheckout.Banknote;
+import org.lsmr.selfcheckout.devices.BanknoteValidator;
+
+/**
+ * Observes events emanating from a banknote validator.
+ */
+public interface BanknoteValidatorObserver extends AbstractDeviceObserver {
+	/**
+	 * An event announcing that the indicated banknote has been detected and
+	 * determined to be valid.
+	 * 
+	 * @param validator
+	 *            The device on which the event occurred.
+	 * @param currency
+	 *            The kind of currency of the inserted banknote.
+	 * @param value
+	 *            The value of the inserted banknote.
+	 */
+	void validBanknoteDetected(BanknoteValidator validator, Currency currency, int value);
+
+	/**
+	 * An event announcing that the indicated banknote has been detected and
+	 * determined to be invalid.
+	 * 
+	 * @param validator
+	 *            The device on which the event occurred.
+	 */
+	void invalidBanknoteDetected(BanknoteValidator validator);
+}
diff --git a/src/org/lsmr/selfcheckout/devices/observers/BarcodeScannerObserver.java b/src/org/lsmr/selfcheckout/devices/observers/BarcodeScannerObserver.java
new file mode 100644
index 0000000..5a73307
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/devices/observers/BarcodeScannerObserver.java
@@ -0,0 +1,20 @@
+package org.lsmr.selfcheckout.devices.observers;
+
+import org.lsmr.selfcheckout.Barcode;
+import org.lsmr.selfcheckout.devices.BarcodeScanner;
+
+/**
+ * Observes events emanating from a barcode scanner.
+ */
+public interface BarcodeScannerObserver extends AbstractDeviceObserver {
+	/**
+	 * An event announcing that the indicated barcode has been successfully scanned.
+	 * 
+	 * @param barcodeScanner
+	 *            The device on which the event occurred.
+	 * @param barcode
+	 *            The barcode that was read by the scanner.
+	 */
+	void barcodeScanned(BarcodeScanner barcodeScanner, Barcode barcode);
+
+}
diff --git a/src/org/lsmr/selfcheckout/devices/observers/CardReaderObserver.java b/src/org/lsmr/selfcheckout/devices/observers/CardReaderObserver.java
new file mode 100644
index 0000000..9256e3a
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/devices/observers/CardReaderObserver.java
@@ -0,0 +1,52 @@
+package org.lsmr.selfcheckout.devices.observers;
+
+import org.lsmr.selfcheckout.Card.CardData;
+import org.lsmr.selfcheckout.devices.CardReader;
+
+/**
+ * Observes events emanating from a coin dispenser.
+ */
+public interface CardReaderObserver extends AbstractDeviceObserver {
+	/**
+	 * Announces that a card has been inserted in the indicated card reader.
+	 * 
+	 * @param reader
+	 *            The reader where the event occurred.
+	 */
+	void cardInserted(CardReader reader);
+
+	/**
+	 * Announces that a card has been removed from the indicated card reader.
+	 * 
+	 * @param reader
+	 *            The reader where the event occurred.
+	 */
+	void cardRemoved(CardReader reader);
+
+	/**
+	 * Announces that a (tap-enabled) card has been tapped on the indicated card
+	 * reader.
+	 * 
+	 * @param reader
+	 *            The reader where the event occurred.
+	 */
+	void cardTapped(CardReader reader);
+
+	/**
+	 * Announces that a card has swiped on the indicated card reader.
+	 * 
+	 * @param reader
+	 *            The reader where the event occurred.
+	 */
+	void cardSwiped(CardReader reader);
+
+	/**
+	 * Announces that the data has been read from a card.
+	 * 
+	 * @param reader
+	 *            The reader where the event occurred.
+	 * @param data
+	 *            The data that was read. Note that this data may be corrupted.
+	 */
+	void cardDataRead(CardReader reader, CardData data);
+}
diff --git a/src/org/lsmr/selfcheckout/devices/observers/CoinDispenserObserver.java b/src/org/lsmr/selfcheckout/devices/observers/CoinDispenserObserver.java
new file mode 100644
index 0000000..d388e06
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/devices/observers/CoinDispenserObserver.java
@@ -0,0 +1,67 @@
+package org.lsmr.selfcheckout.devices.observers;
+
+import org.lsmr.selfcheckout.Coin;
+import org.lsmr.selfcheckout.devices.CoinDispenser;
+
+/**
+ * Observes events emanating from a coin dispenser.
+ */
+public interface CoinDispenserObserver extends AbstractDeviceObserver {
+	/**
+	 * Announces that the indicated coin dispenser is full of coins.
+	 * 
+	 * @param dispenser
+	 *             The dispenser where the event occurred.
+	 */
+	void coinsFull(CoinDispenser dispenser);
+
+	/**
+	 * Announces that the indicated coin dispenser is empty of coins.
+	 * 
+	 * @param dispenser
+	 *             The dispenser where the event occurred.
+	 */
+	void coinsEmpty(CoinDispenser dispenser);
+
+	/**
+	 * Announces that the indicated coin has been added to the indicated coin dispenser.
+	 * 
+	 * @param dispenser
+	 *             The dispenser where the event occurred.
+	 * @param coin
+	 *             The coin that was added.
+	 */
+	void coinAdded(CoinDispenser dispenser, Coin coin);
+
+	/**
+	 * Announces that the indicated coin has been added to the indicated coin dispenser.
+	 * 
+	 * @param dispenser
+	 *             The dispenser where the event occurred.
+	 * @param coin
+	 *             The coin that was removed.
+	 */
+	void coinRemoved(CoinDispenser dispenser, Coin coin);
+
+	/**
+	 * Announces that the indicated sequence of coins has been added to the
+	 * indicated coin dispenser. Used to simulate direct, physical loading of the dispenser.
+	 * 
+	 * @param dispenser
+	 *              The dispenser where the event occurred.
+	 * @param coins
+	 *              The coins that were loaded.
+	 */
+	void coinsLoaded(CoinDispenser dispenser, Coin... coins);
+
+	/**
+	 * Announces that the indicated sequence of coins has been removed to the
+	 * indicated coin dispenser. Used to simulate direct, physical unloading of the dispenser.
+	 * 
+	 * @param dispenser
+	 *              The dispenser where the event occurred.
+	 * @param coins
+	 *              The coins that were unloaded.
+	 */
+	void coinsUnloaded(CoinDispenser dispenser, Coin... coins);
+}
diff --git a/src/org/lsmr/selfcheckout/devices/observers/CoinSlotObserver.java b/src/org/lsmr/selfcheckout/devices/observers/CoinSlotObserver.java
new file mode 100644
index 0000000..a091cb2
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/devices/observers/CoinSlotObserver.java
@@ -0,0 +1,17 @@
+package org.lsmr.selfcheckout.devices.observers;
+
+import org.lsmr.selfcheckout.Coin;
+import org.lsmr.selfcheckout.devices.CoinSlot;
+
+/**
+ * Observes events emanating from a coin slot.
+ */
+public interface CoinSlotObserver extends AbstractDeviceObserver {
+	/**
+	 * An event announcing that a coin has been inserted.
+	 * 
+	 * @param slot
+	 *             The device on which the event occurred.
+	 */
+	void coinInserted(CoinSlot slot);
+}
diff --git a/src/org/lsmr/selfcheckout/devices/observers/CoinStorageUnitObserver.java b/src/org/lsmr/selfcheckout/devices/observers/CoinStorageUnitObserver.java
new file mode 100644
index 0000000..6049c36
--- /dev/null
+++ b/src/org/lsmr/selfcheckout/devices/observers/CoinStorageUnitObserver.java
@@ -0,0 +1,43 @@
+package org.lsmr.selfcheckout.devices.observers;
+
+import org.lsmr.selfcheckout.Coin;
+import org.lsmr.selfcheckout.devices.CoinStorageUnit;
+
+/**
+ * Observes events emanating from a coin storage unit.
+ */
+public interface CoinStorageUnitObserver extends AbstractDeviceObserver {
+	/**
+	 * Announces that the indicated coin storage unit is full of coins.
+	 * 
+	 * @param unit
+	 *            The storage unit where the event occurred.
+	 */
+	void coinsFull(CoinStorageUnit unit);
+
+	/**
+	 * Announces that a coin has been added to the indicated storage unit.
+	 * 
+	 * @param unit
+	 *            The storage unit where the event occurred.
+	 */
+	void coinAdded(CoinStorageUnit unit);
+
+	/**
+	 * Announces that the indicated storage unit has been loaded with coins.
+	 * Used to simulate direct, physical loading of the unit.
+	 * 
+	 * @param unit
+	 *            The storage unit where the event occurred.
+	 */
+	void coinsLoaded(CoinStorageUnit unit);
+
+	/**
+	 * Announces that the storage unit has been emptied of coins. Used to
+	 * simulate direct, physical unloading of the unit.
+	 * 
+	 * @param unit
+	 *            The storage unit where the event occurred.
+	 */
+	void coinsUnloaded(CoinStorageUnit unit);
+}

commit 0d94155eb9a13fc2013a9708a6e655e4eaf65836
Author: kev9268 <99704077+kev9268@users.noreply.github.com>
Date:   Sun Mar 13 10:25:01 2022 -0600

    Delete SCS - Hardware - v1.0.zip

diff --git a/SCS - Hardware - v1.0.zip b/SCS - Hardware - v1.0.zip
deleted file mode 100644
index d941435..0000000
Binary files a/SCS - Hardware - v1.0.zip and /dev/null differ

commit 41fe5a8153d93d47e64fe6815cbebc01f6135a6c
Author: basselhasan <47043095+basselhasan@users.noreply.github.com>
Date:   Sun Mar 13 10:22:58 2022 -0600

    Delete .settings

diff --git a/.settings b/.settings
deleted file mode 100644
index 8b13789..0000000
--- a/.settings
+++ /dev/null
@@ -1 +0,0 @@
-

commit bac08daf53529143725564c6de8cddfc93b2c17a
Author: basselhasan <47043095+basselhasan@users.noreply.github.com>
Date:   Sun Mar 13 10:22:45 2022 -0600

    Create .settings

diff --git a/.settings b/.settings
new file mode 100644
index 0000000..8b13789
--- /dev/null
+++ b/.settings
@@ -0,0 +1 @@
+

commit 6d180de4017ac0778e94304651e5ca6ebca1d7f2
Author: kev9268 <99704077+kev9268@users.noreply.github.com>
Date:   Sun Mar 13 10:16:45 2022 -0600

    Add files via upload

diff --git a/SCS - Hardware - v1.0.zip b/SCS - Hardware - v1.0.zip
new file mode 100644
index 0000000..d941435
Binary files /dev/null and b/SCS - Hardware - v1.0.zip differ
